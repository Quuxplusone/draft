<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>D2767R1: flat_map/flat_set omnibus</title>
<style data-fill-with="stylesheet">/******************************************************************************
 *                   Style sheet for the W3C specifications                   *
 *
 * Special classes handled by this style sheet include:
 *
 * Indices
 *   - .toc for the Table of Contents (<ol class="toc">)
 *     + <span class="secno"> for the section numbers
 *   - #toc for the Table of Contents (<nav id="toc">)
 *   - ul.index for Indices (<a href="#ref">term</a><span>, in § N.M</span>)
 *   - table.index for Index Tables (e.g. for properties or elements)
 *
 * Structural Markup
 *   - table.data for general data tables
 *     -> use 'scope' attribute, <colgroup>, <thead>, and <tbody> for best results !
 *     -> use <table class='complex data'> for extra-complex tables
 *     -> use <td class='long'> for paragraph-length cell content
 *     -> use <td class='pre'> when manual line breaks/indentation would help readability
 *   - dl.switch for switch statements
 *   - ol.algorithm for algorithms (helps to visualize nesting)
 *   - .figure and .caption (HTML4) and figure and figcaption (HTML5)
 *     -> .sidefigure for right-floated figures
 *   - ins/del
 *     -> ins/del.c### for candidate and proposed changes (amendments)
 *
 * Code
 *   - pre and code
 *
 * Special Sections
 *   - .note       for informative notes             (div, p, span, aside, details)
 *   - .example    for informative examples          (div, p, pre, span)
 *   - .issue      for issues                        (div, p, span)
 *   - .advisement for loud normative statements     (div, p, strong)
 *   - .annoying-warning for spec obsoletion notices (div, aside, details)
 *   - .correction for "candidate corrections"       (div, aside, details, section)
 *   - .addition   for "candidate additions"         (div, aside, details, section)
 *   - .correction.proposed for "proposed corrections" (div, aside, details, section)
 *   - .addition.proposed   for "proposed additions"   (div, aside, details, section)
 *
 * Definition Boxes
 *   - pre.def   for WebIDL definitions
 *   - table.def for tables that define other entities (e.g. CSS properties)
 *   - dl.def    for definition lists that define other entitles (e.g. HTML elements)
 *
 * Numbering
 *   - .secno for section numbers in .toc and headings (<span class='secno'>3.2</span>)
 *   - .marker for source-inserted example/figure/issue numbers (<span class='marker'>Issue 4</span>)
 *   - ::before styled for CSS-generated issue/example/figure numbers:
 *     -> Documents wishing to use this only need to add
 *        figcaption::before,
 *        .caption::before { content: "Figure "  counter(figure) " ";  }
 *        .example::before { content: "Example " counter(example) " "; }
 *        .issue::before   { content: "Issue "   counter(issue) " ";   }
 *
 * Header Stuff (ignore, just don't conflict with these classes)
 *   - .head for the header
 *   - .copyright for the copyright
 *
 * Outdated warning for old specs
 *
 * Miscellaneous
 *   - .overlarge for things that should be as wide as possible, even if
 *     that overflows the body text area. This can be used on an item or
 *     on its container, depending on the effect desired.
 *     Note that this styling basically doesn't help at all when printing,
 *     since A4 paper isn't much wider than the max-width here.
 *     It's better to design things to fit into a narrower measure if possible.
 *
 *   - js-added ToC jump links (see fixup.js)
 *
 ******************************************************************************/

/* color variables included separately for reliability */

/******************************************************************************/
/*                                    Body                                    */
/******************************************************************************/

	html {
	}

	body {
		counter-reset: example figure issue;

		/* Layout */
		max-width: 50em;			  /* limit line length to 50em for readability   */
		margin: 0 auto;				/* center text within page                    */
		padding: 1.6em 1.5em 2em 50px; /* assume 16px font size for downlevel clients */
		padding: 1.6em 1.5em 2em calc(26px + 1.5em); /* leave space for status flag    */

		/* Typography */
		line-height: 1.5;
		font-family: sans-serif;
		widows: 2;
		orphans: 2;
		word-wrap: break-word;
		overflow-wrap: break-word;
		hyphens: auto;

		color: black;
		color: var(--text);
		background: white top left fixed no-repeat;
		background: var(--bg) top left fixed no-repeat;
		background-size: 25px auto;
	}


/******************************************************************************/
/*                         Front Matter & Navigation                          */
/******************************************************************************/

/** Header ********************************************************************/

	div.head { margin-bottom: 1em; }
	div.head hr { border-style: solid; }

	div.head h1 {
		font-weight: bold;
		margin: 0 0 .1em;
		font-size: 220%;
	}

	div.head h2 { margin-bottom: 1.5em;}

/** W3C Logo ******************************************************************/

	.head .logo {
		float: right;
		margin: 0.4rem 0 0.2rem .4rem;
	}

	.head img[src*="logos/W3C"] {
		display: block;
		border: solid #1a5e9a;
		border: solid var(--logo-bg);
		border-width: .65rem .7rem .6rem;
		border-radius: .4rem;
		background: #1a5e9a;
		background: var(--logo-bg);
		color: white;
		color: var(--logo-text);
		font-weight: bold;
	}

	.head a:hover > img[src*="logos/W3C"],
	.head a:focus > img[src*="logos/W3C"] {
		opacity: .8;
	}

	.head a:active > img[src*="logos/W3C"] {
		background: #c00;
		background: var(--logo-active-bg);
		border-color: #c00;
		border-color: var(--logo-active-bg);
	}

	/* see also additional rules in Link Styling section */

/** Copyright *****************************************************************/

	p.copyright,
	p.copyright small { font-size: small; }

/** Back to Top / ToC Toggle **************************************************/

	@media print {
		#toc-nav {
			display: none;
		}
	}
	@media not print {
		#toc-nav {
			position: fixed;
			z-index: 3;
			bottom: 0; left: 0;
			margin: 0;
			min-width: 1.33em;
			border-top-right-radius: 2rem;
			box-shadow: 0 0 2px;
			font-size: 1.5em;
		}
		#toc-nav > a {
			display: block;
			white-space: nowrap;

			height: 1.33em;
			padding: .1em 0.3em;
			margin: 0;

			box-shadow: 0 0 2px;
			border: none;
			border-top-right-radius: 1.33em;

			color: #707070;
			color: var(--tocnav-normal-text);
			background: white;
			background: var(--tocnav-normal-bg);
		}
		#toc-nav > a:hover,
		#toc-nav > a:focus {
			color: black;
			color: var(--tocnav-hover-text);
			background: #f8f8f8;
			background: var(--tocnav-hover-bg);
		}
		#toc-nav > a:active {
			color: #c00;
			color: var(--tocnav-active-text);
			background: white;
			background: var(--tocnav-active-bg);
		}

		#toc-nav > #toc-jump {
			padding-bottom: 2em;
			margin-bottom: -1.9em;
		}

		/* statusbar gets in the way on keyboard focus; remove once browsers fix */
		#toc-nav > a[href="#toc"]:not(:hover):focus:last-child {
			padding-bottom: 1.5rem;
		}

		#toc-nav:not(:hover) > a:not(:focus) > span + span {
			/* Ideally this uses :focus-within on #toc-nav */
			display: none;
		}
		#toc-nav > a > span + span {
			padding-right: 0.2em;
		}
	}

/** ToC Sidebar ***************************************************************/

	/* Floating sidebar */
	@media screen {
		body.toc-sidebar #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			max-width: 80%;
			max-width: calc(100% - 2em - 26px);
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			color: black;
			color: var(--tocsidebar-text);
			background: inherit;
			background-color: #f7f8f9;
			background-color: var(--tocsidebar-bg);
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
			box-shadow: -.1em 0 .25em var(--tocsidebar-shadow) inset;
		}
		body.toc-sidebar #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
			color: var(--tocsidebar-heading-text);
		}
		body.toc-sidebar #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	/* Hide main scroller when only the ToC is visible anyway */
	@media screen and (max-width: 28em) {
		body.toc-sidebar {
			overflow: hidden;
		}
	}

	/* Sidebar with its own space */
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			color: black;
			color: var(--tocsidebar-text);
			background: inherit;
			background-color: #f7f8f9;
			background-color: var(--tocsidebar-bg);
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
			box-shadow: -.1em 0 .25em var(--tocsidebar-shadow) inset;
		}
		body:not(.toc-inline) #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
			color: var(--tocsidebar-heading-text);
		}

		body:not(.toc-inline) {
			padding-left: 29em;
		}
		/* See also Overflow section at the bottom */

		body:not(.toc-inline) #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) {
			margin: 0 4em;
		}
	}

/******************************************************************************/
/*                                Sectioning                                  */
/******************************************************************************/

/** Headings ******************************************************************/

	h1, h2, h3, h4, h5, h6, dt {
		page-break-after: avoid;
		page-break-inside: avoid;
		font: 100% sans-serif;   /* Reset all font styling to clear out UA styles */
		font-family: inherit;	/* Inherit the font family. */
		line-height: 1.2;		/* Keep wrapped headings compact */
		hyphens: manual;		/* Hyphenated headings look weird */
	}

	h2, h3, h4, h5, h6 {
		margin-top: 3rem;
	}

	h1, h2, h3 {
		color: #005A9C;
		color: var(--heading-text);
	}

	h1 { font-size: 170%; }
	h2 { font-size: 140%; }
	h3 { font-size: 120%; }
	h4 { font-weight: bold; }
	h5 { font-style: italic; }
	h6 { font-variant: small-caps; }
	dt { font-weight: bold; }

/** Subheadings ***************************************************************/

	h1 + h2,
	#profile-and-date {
		/* #profile-and-date is a subtitle in an H2 under the H1 */
		margin-top: 0;
	}
	h2 + h3,
	h3 + h4,
	h4 + h5,
	h5 + h6 {
		margin-top: 1.2em; /* = 1 x line-height */
	}

/** Section divider ***********************************************************/

	:not(.head) > :not(.head) + hr {
		font-size: 1.5em;
		text-align: center;
		margin: 1em auto;
		height: auto;
		color: black;
		color: var(--hr-text);
		border: transparent solid 0;
		background: transparent;
	}
	:not(.head) > hr::before {
		content: "\2727\2003\2003\2727\2003\2003\2727";
	}

/******************************************************************************/
/*                            Paragraphs and Lists                            */
/******************************************************************************/

	p {
		margin: 1em 0;
	}

	dd > p:first-child,
	li > p:first-child {
		margin-top: 0;
	}

	ul, ol {
		margin-left: 0;
		padding-left: 2em;
	}

	li {
		margin: 0.25em 0 0.5em;
		padding: 0;
	}

	dl dd {
		margin: 0 0 .5em 2em;
	}

	.head dd + dd { /* compact for header */
		margin-top: -.5em;
	}

	/* Style for algorithms */
	ol.algorithm ol:not(.algorithm),
	.algorithm > ol ol:not(.algorithm) {
	border-left: 0.5em solid #DEF;
	border-left: 0.5em solid var(--algo-border);
	}

	/* Put nice boxes around each algorithm. */
	[data-algorithm]:not(.heading) {
	 padding: .5em;
	 border: thin solid #ddd;
	 border: thin solid var(--algo-border);
	 border-radius: .5em;
	 margin: .5em calc(-0.5em - 1px);
	}
	[data-algorithm]:not(.heading) > :first-child {
	 margin-top: 0;
	}
	[data-algorithm]:not(.heading) > :last-child {
	 margin-bottom: 0;
	}

	/* Style for switch/case <dl>s */
	dl.switch > dd > ol.only,
	dl.switch > dd > .only > ol {
	margin-left: 0;
	}
	dl.switch > dd > ol.algorithm,
	dl.switch > dd > .algorithm > ol {
	margin-left: -2em;
	}
	dl.switch {
	padding-left: 2em;
	}
	dl.switch > dt {
	text-indent: -1.5em;
	margin-top: 1em;
	}
	dl.switch > dt + dt {
	margin-top: 0;
	}
	dl.switch > dt::before {
	content: '\21AA';
	padding: 0 0.5em 0 0;
	display: inline-block;
	width: 1em;
	text-align: right;
	line-height: 0.5em;
	}

/** Terminology Markup ********************************************************/


/******************************************************************************/
/*                                 Inline Markup                              */
/******************************************************************************/

/** Terminology Markup ********************************************************/
	dfn   { /* Defining instance */
		font-weight: bolder;
	}
	a > i { /* Instance of term */
		font-style: normal;
	}
	dt dfn code, code.idl {
		font-size: inherit;
	}
	dfn var {
		font-style: normal;
	}

/** Change Marking ************************************************************/

	del {
		color: #aa0000;
		color: var(--del-text);
		background: transparent;
		background: var(--del-bg);
		text-decoration: line-through;
	}
	ins {
		color: #006100;
		color: var(--ins-text);
		background: transparent;
		background: var(--ins-bg);
		text-decoration: underline;
	}

	/* for amendments (candidate/proposed changes) */

	.amendment ins, .correction ins, .addition ins,
	ins[class^=c] {
		text-decoration-style: dotted;
	}
	.amendment del, .correction del, .addition del,
	del[class^=c] {
		text-decoration-style: dotted;
	}
	.amendment.proposed ins, .correction.proposed ins, .addition.proposed ins,
	ins[class^=c].proposed {
		text-decoration-style: double;
	}
	.amendment.proposed del, .correction.proposed del, .addition.proposed del,
	del[class^=c].proposed {
		text-decoration-style: double;
	}

/** Miscellaneous improvements to inline formatting ***************************/

	sup {
		vertical-align: super;
		font-size: 80%
	}

/******************************************************************************/
/*                                    Code                                    */
/******************************************************************************/

/** General monospace/pre rules ***********************************************/

	pre, code, samp {
		font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
		font-size: .9em;
		hyphens: none;
		text-transform: none;
		text-align: left;
		text-align: start;
		font-variant: normal;
		orphans: 3;
		widows: 3;
		page-break-before: avoid;
	}
	pre code,
	code code {
		font-size: 100%;
	}

	pre {
		margin-top: 1em;
		margin-bottom: 1em;
		overflow: auto;
	}

/** Inline Code fragments *****************************************************/

	/* Do something nice. */

/******************************************************************************/
/*                                    Links                                   */
/******************************************************************************/

/** General Hyperlinks ********************************************************/

	/* We hyperlink a lot, so make it less intrusive */
	a[href] {
		color: #034575;
		color: var(--a-normal-text);
		text-decoration: underline #707070;
		text-decoration: underline var(--a-normal-underline);
		text-decoration-skip-ink: none;
	}
	a:visited {
		color: #034575;
		color: var(--a-visited-text);
		text-decoration-color: #bbb;
		text-decoration-color: var(--a-visited-underline);
	}

	/* Indicate interaction with the link */
	a[href]:focus,
	a[href]:hover {
		text-decoration-thickness: 2px;
	}
	a[href]:active {
		color: #c00;
		color: var(--a-active-text);
		text-decoration-color: #c00;
		text-decoration-color: var(--a-active-underline);
	}

	/* Backout above styling for W3C logo */
	.head .logo,
	.head .logo a {
		border: none;
		text-decoration: none;
		background: transparent;
	}

/******************************************************************************/
/*                                    Images                                  */
/******************************************************************************/

	img {
		border-style: none;
	}

	img, svg {
		/* Intentionally not color-scheme aware. */
		background: white;
	}

	/* For autogen numbers, add
	  .caption::before, figcaption::before { content: "Figure " counter(figure) ". "; }
	*/

	figure, .figure, .sidefigure {
		page-break-inside: avoid;
		text-align: center;
		margin: 2.5em 0;
	}
	.figure img,	.sidefigure img,	figure img,
	.figure object, .sidefigure object, figure object {
		max-width: 100%;
		margin: auto;
		height: auto;
	}
	.figure pre, .sidefigure pre, figure pre {
		text-align: left;
		display: table;
		margin: 1em auto;
	}
	.figure table, figure table {
		margin: auto;
	}
	@media screen and (min-width: 20em) {
		.sidefigure {
			float: right;
			width: 50%;
			margin: 0 0 0.5em 0.5em;
		}
	}
	.caption, figcaption, caption {
		font-style: italic;
		font-size: 90%;
	}
	.caption::before, figcaption::before, figcaption > .marker {
		font-weight: bold;
	}
	.caption, figcaption {
		counter-increment: figure;
	}

	/* DL list is indented 2em, but figure inside it is not */
	dd > .figure, dd > figure { margin-left: -2em; }

/******************************************************************************/
/*                             Colored Boxes                                  */
/******************************************************************************/

	.issue, .note, .example, .assertion, .advisement, blockquote,
	.amendment, .correction, .addition {
		margin: 1em auto;
		padding: .5em;
		border: .5em;
		border-left-style: solid;
		page-break-inside: avoid;
	}
	span.issue, span.note {
		padding: .1em .5em .15em;
		border-right-style: solid;
	}

	blockquote > :first-child,
	.note  > p:first-child,
	.issue > p:first-child,
	.amendment > p:first-child,
	.correction > p:first-child,
	.addition > p:first-child {
		margin-top: 0;
	}
	blockquote > :last-child,
	.note  > p:last-child,
	.issue > p:last-child,
	.amendment > p:last-child,
	.correction > p:last-child,
	.addition > p:last-child {
		margin-bottom: 0;
	}


	.issue::before, .issue > .marker,
	.example::before, .example > .marker,
	.note::before, .note > .marker,
	details.note > summary > .marker,
	.amendment::before, .amendment > .marker,
	details.amendment > summary > .marker,
	.addition::before, .addition > .marker,
	addition.amendment > summary > .marker,
	.correction::before, .correction > .marker,
	correction.amendment > summary > .marker
	{
		text-transform: uppercase;
		padding-right: 1em;
	}

	.example::before, .example > .marker {
		display: block;
		padding-right: 0em;
	}

/** Blockquotes ***************************************************************/

	blockquote {
		border-color: silver;
		border-color: var(--blockquote-border);
		background: transparent;
		background: var(--blockquote-bg);
		color: currentcolor;
		color: var(--blockquote-text);
	}

/** Open issue ****************************************************************/

	.issue {
		border-color: #e05252;
		border-color: var(--issue-border);
		background: #fbe9e9;
		background: var(--issue-bg);
		color: black;
		color: var(--issue-text);
		counter-increment: issue;
		overflow: auto;
	}
	.issue::before, .issue > .marker {
		color: #831616;
		color: var(--issueheading-text);
	}
	/* Add .issue::before { content: "Issue " counter(issue) " "; } for autogen numbers,
	  or use class="marker" to mark up the issue number in source. */

/** Example *******************************************************************/

	.example {
		border-color: #e0cb52;
		border-color: var(--example-border);
		background: #fcfaee;
		background: var(--example-bg);
		color: black;
		color: var(--example-text);
		counter-increment: example;
		overflow: auto;
		clear: both;
	}
	.example::before, .example > .marker {
		color: #574b0f;
		color: var(--exampleheading-text);
	}
	/* Add .example::before { content: "Example " counter(example) " "; } for autogen numbers,
	  or use class="marker" to mark up the example number in source. */

/** Non-normative Note ********************************************************/

	.note {
		border-color: #52e052;
		border-color: var(--note-border);
		background: #e9fbe9;
		background: var(--note-bg);
		color: black;
		color: var(--note-text);
		overflow: auto;
	}

	.note::before, .note > .marker,
	details.note > summary {
		color: hsl(120, 70%, 30%);
		color: var(--noteheading-text);
	}
	/* Add .note::before { content: "Note "; } for autogen label,
	  or use class="marker" to mark up the label in source. */

	details.note[open] > summary {
		border-bottom: 1px silver solid;
		border-bottom: 1px var(--notesummary-underline) solid;
	}

/** Assertion Box *************************************************************/
	/*  for assertions in algorithms */

	.assertion {
		border-color: #AAA;
		border-color: var(--assertion-border);
		background: #EEE;
		background: var(--assertion-bg);
		color: black;
		color: var(--assertion-text);
	}

/** Advisement Box ************************************************************/
	/*  for attention-grabbing normative statements */

	.advisement {
		border-color: orange;
		border-color: var(--advisement-border);
		border-style: none solid;
		background: #fec;
		background: var(--advisement-bg);
		color: black;
		color: var(--advisement-text);
	}
	strong.advisement {
		display: block;
		text-align: center;
	}
	.advisement::before, .advisement > .marker {
		color: #b35f00;
		color: var(--advisementheading-text);
	}

/** Amendment Box *************************************************************/

	.amendment, .correction, .addition {
		border-color: #330099;
		border-color: var(--amendment-border);
		background: #F5F0FF;
		background: var(--amendment-bg);
		color: black;
		color: var(--amendment-text);
	}
	.amendment.proposed, .correction.proposed, .addition.proposed {
		border-style: solid;
		border-block-width: 0.25em;
	}
	.amendment::before, .amendment > .marker,
	details.amendment > summary::before, details.amendment > summary > .marker,
	.correction::before, .correction > .marker,
	details.correction > summary::before, details.correction > summary > .marker,
	.addition::before, .addition > .marker,
	details.addition > summary::before, details.addition > summary > .marker {
		color: #220066;
		color: var(--amendmentheading-text);
	}
	.amendment.proposed::before, .amendment.proposed > .marker,
	details.amendment.proposed > summary::before, details.amendment.proposed > summary > .marker,
	.correction.proposed::before, .correction.proposed > .marker,
	details.correction.proposed > summary::before, details.correction.proposed > summary > .marker,
	.addition.proposed::before, .addition.proposed > .marker,
	details.addition.proposed > summary::before, details.addition.proposed > summary > .marker {
		font-weight: bold;
	}

/** Spec Obsoletion Notice ****************************************************/
	/* obnoxious obsoletion notice for older/abandoned specs. */

	details {
		display: block;
	}
	summary {
		font-weight: bolder;
	}

	.annoying-warning:not(details),
	details.annoying-warning:not([open]) > summary,
	details.annoying-warning[open] {
		background: hsla(40,100%,50%,0.95);
		background: var(--warning-bg);
		color: black;
		color: var(--warning-text);
		padding: .75em 1em;
		border: red;
		border: var(--warning-border);
		border-style: solid none;
		box-shadow: 0 2px 8px black;
		text-align: center;
	}
	.annoying-warning :last-child {
		margin-bottom: 0;
	}

@media not print {
	details.annoying-warning[open] {
		position: fixed;
		left: 0;
		right: 0;
		bottom: 2em;
		z-index: 1000;
	}
}

	details.annoying-warning:not([open]) > summary {
		text-align: center;
	}

/** Entity Definition Boxes ***************************************************/

	.def {
		padding: .5em 1em;
		background: #def;
		background: var(--def-bg);
		margin: 1.2em 0;
		border-left: 0.5em solid #8ccbf2;
		border-left: 0.5em solid var(--def-border);
		color: black;
		color: var(--def-text);
	}

/******************************************************************************/
/*                                    Tables                                  */
/******************************************************************************/

	th, td {
		text-align: left;
		text-align: start;
	}

/** Property/Descriptor Definition Tables *************************************/

	table.def {
		/* inherits .def box styling, see above */
		width: 100%;
		border-spacing: 0;
	}

	table.def td,
	table.def th {
		padding: 0.5em;
		vertical-align: baseline;
		border-bottom: 1px solid #bbd7e9;
		border-bottom: 1px solid var(--defrow-border);
	}

	table.def > tbody > tr:last-child th,
	table.def > tbody > tr:last-child td {
		border-bottom: 0;
	}

	table.def th {
		font-style: italic;
		font-weight: normal;
		padding-left: 1em;
		width: 3em;
	}

	/* For when values are extra-complex and need formatting for readability */
	table td.pre {
		white-space: pre-wrap;
	}

	/* A footnote at the bottom of a def table */
	table.def td.footnote {
		padding-top: 0.6em;
	}
	table.def td.footnote::before {
		content: " ";
		display: block;
		height: 0.6em;
		width: 4em;
		border-top: thin solid;
	}

/** Data tables (and properly marked-up index tables) *************************/
	/*
		<table class="data"> highlights structural relationships in a table
		when correct markup is used (e.g. thead/tbody, th vs. td, scope attribute)

		Use class="complex data" for particularly complicated tables --
		(This will draw more lines: busier, but clearer.)

		Use class="long" on table cells with paragraph-like contents
		(This will adjust text alignment accordingly.)
		Alternately use class="longlastcol" on tables, to have the last column assume "long".
	*/

	table {
		word-wrap: normal;
		overflow-wrap: normal;
		hyphens: manual;
	}

	table.data,
	table.index {
		margin: 1em auto;
		border-collapse: collapse;
		border: hidden;
		width: 100%;
	}
	table.data caption,
	table.index caption {
		max-width: 50em;
		margin: 0 auto 1em;
	}

	table.data td,  table.data th,
	table.index td, table.index th {
		padding: 0.5em 1em;
		border-width: 1px;
		border-color: silver;
		border-color: var(--datacell-border);
		border-top-style: solid;
	}

	table.data thead td:empty {
		padding: 0;
		border: 0;
	}

	table.data  thead,
	table.index thead,
	table.data  tbody,
	table.index tbody {
		border-bottom: 2px solid;
	}

	table.data colgroup,
	table.index colgroup {
		border-left: 2px solid;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		border-right: 2px solid;
		border-top: 1px solid silver;
		border-top: 1px solid var(--datacell-border);
		padding-right: 1em;
	}

	table.data th[colspan],
	table.data td[colspan] {
		text-align: center;
	}

	table.complex.data th,
	table.complex.data td {
		border: 1px solid silver;
		border: 1px solid var(--datacell-border);
		text-align: center;
	}

	table.data.longlastcol td:last-child,
	table.data td.long {
		vertical-align: baseline;
		text-align: left;
	}

	table.data img {
		vertical-align: middle;
	}


/*
Alternate table alignment rules

	table.data,
	table.index {
		text-align: center;
	}

	table.data  thead th[scope="row"],
	table.index thead th[scope="row"] {
		text-align: right;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		text-align: right;
	}

Possible extra rowspan handling

	table.data  tbody th[rowspan]:not([rowspan='1']),
	table.index tbody th[rowspan]:not([rowspan='1']),
	table.data  tbody td[rowspan]:not([rowspan='1']),
	table.index tbody td[rowspan]:not([rowspan='1']) {
		border-left: 1px solid silver;
	}

	table.data  tbody th[rowspan]:first-child,
	table.index tbody th[rowspan]:first-child,
	table.data  tbody td[rowspan]:first-child,
	table.index tbody td[rowspan]:first-child{
		border-left: 0;
		border-right: 1px solid silver;
	}
*/

/******************************************************************************/
/*                                  Indices                                   */
/******************************************************************************/


/** Table of Contents *********************************************************/

	.toc a {
		/* More spacing; use padding to make it part of the click target. */
		padding: 0.1rem 1px 0;
		/* Larger, more consistently-sized click target */
		display: block;
		/* Switch to using border-bottom for underlines */
		text-decoration: none;
		border-bottom: 1px solid;
		/* Reverse color scheme */
		color: black;
		color: var(--toclink-text);
		border-color: #3980b5;
		border-color: var(--toclink-underline);
	}
	.toc a:visited {
		color: black;
		color: var(--toclink-visited-text);
		border-color: #054572;
		border-color: var(--toclink-visited-underline);
	}
	.toc a:focus,
	.toc a:hover {
		background: rgba(75%, 75%, 75%, .25);
		background: var(--a-hover-bg);
		border-bottom-width: 3px;
		margin-bottom: -2px;
	}
	.toc a:not(:focus):not(:hover) {
		/* Allow colors to cascade through from link styling */
		border-bottom-color: transparent;
	}

	.toc, .toc ol, .toc ul, .toc li {
		list-style: none; /* Numbers must be inlined into source */
		/* because generated content isn't search/selectable and markers can't do multilevel yet */
		margin:  0;
		padding: 0;
	}
	.toc {
		line-height: 1.1em;
	}

	/* ToC not indented until third level, but font style & margins show hierarchy */
	.toc > li			{ font-weight: bold;   }
	.toc > li li		 { font-weight: normal; }
	.toc > li li li	  { font-size:   95%;	}
	.toc > li li li li	{ font-size:   90%;	}
	.toc > li li li li li { font-size:   85%;	}

	/* @supports not (display:grid) { */
		.toc > li			{ margin: 1.5rem 0;	}
		.toc > li li		 { margin: 0.3rem 0;	}
		.toc > li li li	  { margin-left: 2rem;   }

		/* Section numbers in a column of their own */
		.toc .secno {
			float: left;
			width: 4rem;
			white-space: nowrap;
		}
		.toc > li li li li .secno { font-size: 85%; }
		.toc > li li li li li .secno { font-size: 100%; }

		.toc li {
			clear: both;
		}

		:not(li) > .toc			 { margin-left:  5rem; }
		.toc .secno				 { margin-left: -5rem; }
		.toc > li li li .secno	  { margin-left: -7rem; }
		.toc > li li li li .secno	{ margin-left: -9rem; }
		.toc > li li li li li .secno { margin-left: -11rem; }

		/* Tighten up indentation in narrow ToCs */
		@media (max-width: 30em) {
			:not(li) > .toc			 { margin-left:  4rem; }
			.toc .secno				 { margin-left: -4rem; }
			.toc > li li li			 { margin-left:  1rem; }
			.toc > li li li .secno	  { margin-left: -5rem; }
			.toc > li li li li .secno	{ margin-left: -6rem; }
			.toc > li li li li li .secno { margin-left: -7rem; }
		}
		/* Loosen it on wide screens */
		@media screen and (min-width: 78em) {
			body:not(.toc-inline) :not(li) > .toc			 { margin-left:  4rem; }
			body:not(.toc-inline) .toc .secno				 { margin-left: -4rem; }
			body:not(.toc-inline) .toc > li li li			 { margin-left:  1rem; }
			body:not(.toc-inline) .toc > li li li .secno	  { margin-left: -5rem; }
			body:not(.toc-inline) .toc > li li li li .secno	{ margin-left: -6rem; }
			body:not(.toc-inline) .toc > li li li li li .secno { margin-left: -7rem; }
	}
	/* } */

	@supports (display:grid) and (display:contents) {
		/* Use #toc over .toc to override non-@supports rules. */
		#toc {
			display: grid;
			align-content: start;
			grid-template-columns: auto 1fr;
			grid-column-gap: 1rem;
			column-gap: 1rem;
			grid-row-gap: .6rem;
			row-gap: .6rem;
		}
		#toc h2 {
			grid-column: 1 / -1;
			margin-bottom: 0;
		}
		#toc ol,
		#toc li,
		#toc a {
			display: contents;
			/* Switch <a> to subgrid when supported */
		}
		#toc span {
			margin: 0;
		}
		#toc > .toc > li > a > span {
			/* The spans of the top-level list,
			  comprising the first items of each top-level section. */
			margin-top: 1.1rem;
		}
		#toc#toc .secno { /* Ugh, need more specificity to override base.css */
			grid-column: 1;
			width: auto;
			margin-left: 0;
		}
		#toc .content {
			grid-column: 2;
			width: auto;
			margin-right: 1rem;
			border-bottom: 3px solid transparent;
			margin-bottom: -3px;
		}
		#toc .content:hover,
		#toc .content:focus {
			background: rgba(75%, 75%, 75%, .25);
			background: var(--a-hover-bg);
			border-bottom-color: #054572;
			border-bottom-color: var(--toclink-underline);
		}
		#toc li li li .content {
			margin-left: 1rem;
		}
		#toc li li li li .content {
			margin-left: 2rem;
		}
	}


/** Index *********************************************************************/

	/* Index Lists: Layout */
	ul.index	  { margin-left: 0; columns: 15em; text-indent: 1em hanging; }
	ul.index li	{ margin-left: 0; list-style: none; break-inside: avoid; }
	ul.index li li { margin-left: 1em; }
	ul.index dl	{ margin-top: 0; }
	ul.index dt	{ margin: .2em 0 .2em 20px;}
	ul.index dd	{ margin: .2em 0 .2em 40px;}
	/* Index Lists: Typography */
	ul.index ul,
	ul.index dl { font-size: smaller; }
	@media not print {
		ul.index li a + span {
			white-space: nowrap;
			color: transparent; }
		ul.index li a:hover + span,
		ul.index li a:focus + span {
			color: #707070;
			color: var(--indexinfo-text);
		}
	}

/** Index Tables *****************************************************/
	/* See also the data table styling section, which this effectively subclasses */

	table.index {
		font-size: small;
		border-collapse: collapse;
		border-spacing: 0;
		text-align: left;
		margin: 1em 0;
	}

	table.index td,
	table.index th {
		padding: 0.4em;
	}

	table.index tr:hover td:not([rowspan]),
	table.index tr:hover th:not([rowspan]) {
		color: black;
		color: var(--indextable-hover-text);
		background: #f7f8f9;
		background: var(--indextable-hover-bg);
	}

	/* The link in the first column in the property table (formerly a TD) */
	table.index th:first-child a {
		font-weight: bold;
	}

/** Outdated warning **********************************************************/

.outdated-spec {
	color: black;
	color: var(--outdatedspec-text);
	background-color: rgba(0,0,0,0.5);
	background-color: var(--outdatedspec-bg);
}

.outdated-warning {
	position: fixed;
	bottom: 50%;
	left: 0;
	right: 0;
	margin: 0 auto;
	width: 50%;
	background: maroon;
	background: var(--outdated-bg);
	color: white;
	color: var(--outdated-text);
	border-radius: 1em;
	box-shadow: 0 0 1em red;
	box-shadow: 0 0 1em var(--outdated-shadow);
	padding: 2em;
	text-align: center;
	z-index: 2;
}

.outdated-warning a {
	color: currentcolor;
	background: transparent;
}

.edited-rec-warning {
	background: darkorange;
	background: var(--editedrec-bg);
	box-shadow: 0 0 1em;
}

.outdated-warning button {
	color: var(--outdated-text);
	border-radius: 1em;
	box-shadow: 0 0 1em red;
	box-shadow: 0 0 1em var(--outdated-shadow);
	padding: 2em;
	text-align: center;
	z-index: 2;
}

.outdated-warning a {
	color: currentcolor;
	background: transparent;
}

.edited-rec-warning {
	background: darkorange;
	background: var(--editedrec-bg);
	box-shadow: 0 0 1em;
}

.outdated-warning button {
	position: absolute;
	top: 0;
	right:0;
	margin: 0;
	border: 0;
	padding: 0.25em 0.5em;
	background: transparent;
	color: white;
	color: var(--outdated-text);
	font:1em sans-serif;
	text-align:center;
}

.outdated-warning span {
	display: block;
}

.outdated-collapsed {
	bottom: 0;
	border-radius: 0;
	width: 100%;
	padding: 0;
}

/******************************************************************************/
/*                                    Print                                   */
/******************************************************************************/

	@media print {
		/* Pages have their own margins. */
		html {
			margin: 0;
		}
		/* Serif for print. */
		body {
			font-family: serif;
		}

		.outdated-warning {
			position: absolute;
			border-style: solid;
			border-color: red;
		}

		.outdated-warning input {
			display: none;
		}
	}
	@page {
		margin: 1.5cm 1.1cm;
	}



/******************************************************************************/
/*                             Overflow Control                               */
/******************************************************************************/

	.figure .caption, .sidefigure .caption, figcaption {
		/* in case figure is overlarge, limit caption to 50em */
		max-width: 50rem;
		margin-left: auto;
		margin-right: auto;
	}
	.overlarge {
		/* Magic to create good item positioning:
		  "content column" is 50ems wide at max; less on smaller screens.
		  Extra space (after ToC + content) is empty on the right.

		  1. When item < content column, centers item in column.
		  2. When content < item < available, left-aligns.
		  3. When item > available, fills available + scroll bar.
		*/
		display: grid;
		grid-template-columns: minmax(0, 50em);
	}
	.overlarge > table {
		/* limit preferred width of table */
		max-width: 50em;
		margin-left: auto;
		margin-right: auto;
	}

	@media (min-width: 55em) {
		.overlarge {
			margin-right: calc(13px + 26.5rem - 50vw);
			max-width: none;
		}
	}
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) .overlarge {
			/* 30.5em body padding 50em content area */
			margin-right: calc(40em - 50vw) !important;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) .overlarge {
			/* 4em html margin 30.5em body padding 50em content area */
			margin-right: calc(84.5em - 100vw) !important;
		}
	}

	@media not print {
		.overlarge {
			overflow-x: auto;
			/* See Lea Verou's explanation background-attachment:
			* http://lea.verou.me/2012/04/background-attachment-local/
			*
			background: top left  / 4em 100% linear-gradient(to right,  #ffffff, rgba(255, 255, 255, 0)) local,
						top right / 4em 100% linear-gradient(to left, #ffffff, rgba(255, 255, 255, 0)) local,
						top left  / 1em 100% linear-gradient(to right,  #c3c3c5, rgba(195, 195, 197, 0)) scroll,
						top right / 1em 100% linear-gradient(to left, #c3c3c5, rgba(195, 195, 197, 0)) scroll,
						white;
			background-repeat: no-repeat;
			*/
		}
	}
</style>
<style>
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      vertical-align: top;
    }
    th, td {
      border-left: none;
      border-right: none;
      padding: 0px 10px;
    }
    th {
      text-align: center;
    }

    del { background: #fcc; color: #000; text-decoration: line-through; }
    ins { background: #cfc; color: #000; }
    blockquote .highlight:not(.idl) { background: initial; margin: initial; padding: 0.5em }
    blockquote ul { background: inherit; }
    blockquote code.highlight:not(.idl) { padding: initial; }
    blockquote c-[a] { color: inherit; } /* Keyword.Declaration */
    blockquote c-[b] { color: inherit; } /* Keyword.Type */
    blockquote c-[c] { color: inherit; } /* Comment */
    blockquote c-[d] { color: inherit; } /* Comment.Multiline */
    blockquote c-[e] { color: inherit; } /* Name.Attribute */
    blockquote c-[f] { color: inherit; } /* Name.Tag */
    blockquote c-[g] { color: inherit; } /* Name.Variable */
    blockquote c-[k] { color: inherit; } /* Keyword */
    blockquote c-[l] { color: inherit; } /* Literal */
    blockquote c-[m] { color: inherit; } /* Literal.Number */
    blockquote c-[n] { color: inherit; } /* Name */
    blockquote c-[o] { color: inherit; } /* Operator */
    blockquote c-[p] { color: inherit; } /* Punctuation */
    blockquote c-[s] { color: inherit; } /* Literal.String */
    blockquote c-[t] { color: inherit; } /* Literal.String.Single */
    blockquote c-[u] { color: inherit; } /* Literal.String.Double */
    blockquote c-[cp] { color: inherit; } /* Comment.Preproc */
    blockquote c-[c1] { color: inherit; } /* Comment.Single */
    blockquote c-[cs] { color: inherit; } /* Comment.Special */
    blockquote c-[kc] { color: inherit; } /* Keyword.Constant */
    blockquote c-[kn] { color: inherit; } /* Keyword.Namespace */
    blockquote c-[kp] { color: inherit; } /* Keyword.Pseudo */
    blockquote c-[kr] { color: inherit; } /* Keyword.Reserved */
    blockquote c-[ld] { color: inherit; } /* Literal.Date */
    blockquote c-[nc] { color: inherit; } /* Name.Class */
    blockquote c-[no] { color: inherit; } /* Name.Constant */
    blockquote c-[nd] { color: inherit; } /* Name.Decorator */
    blockquote c-[ni] { color: inherit; } /* Name.Entity */
    blockquote c-[ne] { color: inherit; } /* Name.Exception */
    blockquote c-[nf] { color: inherit; } /* Name.Function */
    blockquote c-[nl] { color: inherit; } /* Name.Label */
    blockquote c-[nn] { color: inherit; } /* Name.Namespace */
    blockquote c-[py] { color: inherit; } /* Name.Property */
    blockquote c-[ow] { color: inherit; } /* Operator.Word */
    blockquote c-[mb] { color: inherit; } /* Literal.Number.Bin */
    blockquote c-[mf] { color: inherit; } /* Literal.Number.Float */
    blockquote c-[mh] { color: inherit; } /* Literal.Number.Hex */
    blockquote c-[mi] { color: inherit; } /* Literal.Number.Integer */
    blockquote c-[mo] { color: inherit; } /* Literal.Number.Oct */
    blockquote c-[sb] { color: inherit; } /* Literal.String.Backtick */
    blockquote c-[sc] { color: inherit; } /* Literal.String.Char */
    blockquote c-[sd] { color: inherit; } /* Literal.String.Doc */
    blockquote c-[se] { color: inherit; } /* Literal.String.Escape */
    blockquote c-[sh] { color: inherit; } /* Literal.String.Heredoc */
    blockquote c-[si] { color: inherit; } /* Literal.String.Interpol */
    blockquote c-[sx] { color: inherit; } /* Literal.String.Other */
    blockquote c-[sr] { color: inherit; } /* Literal.String.Regex */
    blockquote c-[ss] { color: inherit; } /* Literal.String.Symbol */
    blockquote c-[vc] { color: inherit; } /* Name.Variable.Class */
    blockquote c-[vg] { color: inherit; } /* Name.Variable.Global */
    blockquote c-[vi] { color: inherit; } /* Name.Variable.Instance */
    blockquote c-[il] { color: inherit; } /* Literal.Number.Integer.Long */
  </style>
  <meta content="Bikeshed version b06c00b8e, updated Tue Jul 11 13:41:16 2023 -0700" name="generator">
  <link href="https://isocpp.org/favicon.ico" rel="icon">
<style>
hilite  {background-color: #FFFF00; font-weight: bold;}
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
src  {background-color: #FFDDFF; text-decoration: line-through;}
dst  {background-color: #CCFFEE; text-decoration: underline;}
</style>
<style>/* Boilerplate: style-autolinks */
.css.css, .property.property, .descriptor.descriptor {
    color: var(--a-normal-text);
    font-size: inherit;
    font-family: inherit;
}
.css::before, .property::before, .descriptor::before {
    content: "‘";
}
.css::after, .property::after, .descriptor::after {
    content: "’";
}
.property, .descriptor {
    /* Don't wrap property and descriptor names */
    white-space: nowrap;
}
.type { /* CSS value <type> */
    font-style: italic;
}
pre .property::before, pre .property::after {
    content: "";
}
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {
    content: "‘";
}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {
    content: "’";
}

[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after {
    content: "";
}

[data-link-type=element],
[data-link-type=element-attr] {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
    font-size: .9em;
}
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after  { content: ">" }

[data-link-type=biblio] {
    white-space: pre;
}

@media (prefers-color-scheme: dark) {
    :root {
        --selflink-text: black;
        --selflink-bg: silver;
        --selflink-hover-text: white;
    }
}
</style>
<style>/* Boilerplate: style-colors */

/* Any --*-text not paired with a --*-bg is assumed to have a transparent bg */
:root {
    color-scheme: light dark;

    --text: black;
    --bg: white;

    --unofficial-watermark: url(https://www.w3.org/StyleSheets/TR/2016/logos/UD-watermark);

    --logo-bg: #1a5e9a;
    --logo-active-bg: #c00;
    --logo-text: white;

    --tocnav-normal-text: #707070;
    --tocnav-normal-bg: var(--bg);
    --tocnav-hover-text: var(--tocnav-normal-text);
    --tocnav-hover-bg: #f8f8f8;
    --tocnav-active-text: #c00;
    --tocnav-active-bg: var(--tocnav-normal-bg);

    --tocsidebar-text: var(--text);
    --tocsidebar-bg: #f7f8f9;
    --tocsidebar-shadow: rgba(0,0,0,.1);
    --tocsidebar-heading-text: hsla(203,20%,40%,.7);

    --toclink-text: var(--text);
    --toclink-underline: #3980b5;
    --toclink-visited-text: var(--toclink-text);
    --toclink-visited-underline: #054572;

    --heading-text: #005a9c;

    --hr-text: var(--text);

    --algo-border: #def;

    --del-text: red;
    --del-bg: transparent;
    --ins-text: #080;
    --ins-bg: transparent;

    --a-normal-text: #034575;
    --a-normal-underline: #bbb;
    --a-visited-text: var(--a-normal-text);
    --a-visited-underline: #707070;
    --a-hover-bg: rgba(75%, 75%, 75%, .25);
    --a-active-text: #c00;
    --a-active-underline: #c00;

    --blockquote-border: silver;
    --blockquote-bg: transparent;
    --blockquote-text: currentcolor;

    --issue-border: #e05252;
    --issue-bg: #fbe9e9;
    --issue-text: var(--text);
    --issueheading-text: #831616;

    --example-border: #e0cb52;
    --example-bg: #fcfaee;
    --example-text: var(--text);
    --exampleheading-text: #574b0f;

    --note-border: #52e052;
    --note-bg: #e9fbe9;
    --note-text: var(--text);
    --noteheading-text: hsl(120, 70%, 30%);
    --notesummary-underline: silver;

    --assertion-border: #aaa;
    --assertion-bg: #eee;
    --assertion-text: black;

    --advisement-border: orange;
    --advisement-bg: #fec;
    --advisement-text: var(--text);
    --advisementheading-text: #b35f00;

    --warning-border: red;
    --warning-bg: hsla(40,100%,50%,0.95);
    --warning-text: var(--text);

    --amendment-border: #330099;
    --amendment-bg: #F5F0FF;
    --amendment-text: var(--text);
    --amendmentheading-text: #220066;

    --def-border: #8ccbf2;
    --def-bg: #def;
    --def-text: var(--text);
    --defrow-border: #bbd7e9;

    --datacell-border: silver;

    --indexinfo-text: #707070;

    --indextable-hover-text: black;
    --indextable-hover-bg: #f7f8f9;

    --outdatedspec-bg: rgba(0, 0, 0, .5);
    --outdatedspec-text: black;
    --outdated-bg: maroon;
    --outdated-text: white;
    --outdated-shadow: red;

    --editedrec-bg: darkorange;
}

@media (prefers-color-scheme: dark) {
    :root {
        --text: #ddd;
        --bg: black;

        --unofficial-watermark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Cg fill='%23100808' transform='translate(200 200) rotate(-45) translate(-200 -200)' stroke='%23100808' stroke-width='3'%3E%3Ctext x='50%25' y='220' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EUNOFFICIAL%3C/text%3E%3Ctext x='50%25' y='305' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EDRAFT%3C/text%3E%3C/g%3E%3C/svg%3E");

        --logo-bg: #1a5e9a;
        --logo-active-bg: #c00;
        --logo-text: white;

        --tocnav-normal-text: #999;
        --tocnav-normal-bg: var(--bg);
        --tocnav-hover-text: var(--tocnav-normal-text);
        --tocnav-hover-bg: #080808;
        --tocnav-active-text: #f44;
        --tocnav-active-bg: var(--tocnav-normal-bg);

        --tocsidebar-text: var(--text);
        --tocsidebar-bg: #080808;
        --tocsidebar-shadow: rgba(255,255,255,.1);
        --tocsidebar-heading-text: hsla(203,20%,40%,.7);

        --toclink-text: var(--text);
        --toclink-underline: #6af;
        --toclink-visited-text: var(--toclink-text);
        --toclink-visited-underline: #054572;

        --heading-text: #8af;

        --hr-text: var(--text);

        --algo-border: #456;

        --del-text: #f44;
        --del-bg: transparent;
        --ins-text: #4a4;
        --ins-bg: transparent;

        --a-normal-text: #6af;
        --a-normal-underline: #555;
        --a-visited-text: var(--a-normal-text);
        --a-visited-underline: var(--a-normal-underline);
        --a-hover-bg: rgba(25%, 25%, 25%, .2);
        --a-active-text: #f44;
        --a-active-underline: var(--a-active-text);

        --borderedblock-bg: rgba(255, 255, 255, .05);

        --blockquote-border: silver;
        --blockquote-bg: var(--borderedblock-bg);
        --blockquote-text: currentcolor;

        --issue-border: #e05252;
        --issue-bg: var(--borderedblock-bg);
        --issue-text: var(--text);
        --issueheading-text: hsl(0deg, 70%, 70%);

        --example-border: hsl(50deg, 90%, 60%);
        --example-bg: var(--borderedblock-bg);
        --example-text: var(--text);
        --exampleheading-text: hsl(50deg, 70%, 70%);

        --note-border: hsl(120deg, 100%, 35%);
        --note-bg: var(--borderedblock-bg);
        --note-text: var(--text);
        --noteheading-text: hsl(120, 70%, 70%);
        --notesummary-underline: silver;

        --assertion-border: #444;
        --assertion-bg: var(--borderedblock-bg);
        --assertion-text: var(--text);

        --advisement-border: orange;
        --advisement-bg: #222218;
        --advisement-text: var(--text);
        --advisementheading-text: #f84;

        --warning-border: red;
        --warning-bg: hsla(40,100%,20%,0.95);
        --warning-text: var(--text);

        --amendment-border: #330099;
        --amendment-bg: #080010;
        --amendment-text: var(--text);
        --amendmentheading-text: #cc00ff;

        --def-border: #8ccbf2;
        --def-bg: #080818;
        --def-text: var(--text);
        --defrow-border: #136;

        --datacell-border: silver;

        --indexinfo-text: #aaa;

        --indextable-hover-text: var(--text);
        --indextable-hover-bg: #181818;

        --outdatedspec-bg: rgba(255, 255, 255, .5);
        --outdatedspec-text: black;
        --outdated-bg: maroon;
        --outdated-text: white;
        --outdated-shadow: red;

        --editedrec-bg: darkorange;
    }
    /* In case a transparent-bg image doesn't expect to be on a dark bg,
       which is quite common in practice... */
    img { background: white; }
}
</style>
<style>/* Boilerplate: style-counters */
body {
    counter-reset: example figure issue;
}
.issue {
    counter-increment: issue;
}
.issue:not(.no-marker)::before {
    content: "Issue " counter(issue);
}

.example {
    counter-increment: example;
}
.example:not(.no-marker)::before {
    content: "Example " counter(example);
}
.invalid.example:not(.no-marker)::before,
.illegal.example:not(.no-marker)::before {
    content: "Invalid Example" counter(example);
}

figcaption {
    counter-increment: figure;
}
figcaption:not(.no-marker)::before {
    content: "Figure " counter(figure) " ";
}
</style>
<style>/* Boilerplate: style-issues */
a[href].issue-return {
    float: right;
    float: inline-end;
    color: var(--issueheading-text);
    font-weight: bold;
    text-decoration: none;
}
</style>
<style>/* Boilerplate: style-md-lists */
/* This is a weird hack for me not yet following the commonmark spec
   regarding paragraph and lists. */
[data-md] > :first-child {
    margin-top: 0;
}
[data-md] > :last-child {
    margin-bottom: 0;
}
</style>
<style>/* Boilerplate: style-selflinks */

:root {
    --selflink-text: white;
    --selflink-bg: gray;
    --selflink-hover-text: black;
}
.heading, .issue, .note, .example, li, dt {
    position: relative;
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
}
a.self-link:hover {
    opacity: 1;
}
.heading > a.self-link {
    font-size: 83%;
}
.example > a.self-link,
.note > a.self-link,
.issue > a.self-link {
    /* These blocks are overflow:auto, so positioning outside
       doesn't work. */
    left: auto;
    right: 0;
}
li > a.self-link {
    left: calc(-1 * (3.5rem - 26px) - 2em);
}
dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: var(--selflink-bg);
    color: var(--selflink-text);
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
    opacity: 1;
}
dfn > a.self-link:hover {
    color: var(--selflink-hover-text);
}

a.self-link::before            { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before      { content: "#"; }
</style>
<style>/* Boilerplate: style-syntax-highlighting */

code.highlight { padding: .1em; border-radius: .3em; }
pre.highlight, pre > code.highlight { display: block; padding: 1em; margin: .5em 0; overflow: auto; border-radius: 0; }

.highlight:not(.idl) { background: rgba(0, 0, 0, .03); }
c-[a] { color: #990055 } /* Keyword.Declaration */
c-[b] { color: #990055 } /* Keyword.Type */
c-[c] { color: #708090 } /* Comment */
c-[d] { color: #708090 } /* Comment.Multiline */
c-[e] { color: #0077aa } /* Name.Attribute */
c-[f] { color: #669900 } /* Name.Tag */
c-[g] { color: #222222 } /* Name.Variable */
c-[k] { color: #990055 } /* Keyword */
c-[l] { color: #000000 } /* Literal */
c-[m] { color: #000000 } /* Literal.Number */
c-[n] { color: #0077aa } /* Name */
c-[o] { color: #999999 } /* Operator */
c-[p] { color: #999999 } /* Punctuation */
c-[s] { color: #a67f59 } /* Literal.String */
c-[t] { color: #a67f59 } /* Literal.String.Single */
c-[u] { color: #a67f59 } /* Literal.String.Double */
c-[cp] { color: #708090 } /* Comment.Preproc */
c-[c1] { color: #708090 } /* Comment.Single */
c-[cs] { color: #708090 } /* Comment.Special */
c-[kc] { color: #990055 } /* Keyword.Constant */
c-[kn] { color: #990055 } /* Keyword.Namespace */
c-[kp] { color: #990055 } /* Keyword.Pseudo */
c-[kr] { color: #990055 } /* Keyword.Reserved */
c-[ld] { color: #000000 } /* Literal.Date */
c-[nc] { color: #0077aa } /* Name.Class */
c-[no] { color: #0077aa } /* Name.Constant */
c-[nd] { color: #0077aa } /* Name.Decorator */
c-[ni] { color: #0077aa } /* Name.Entity */
c-[ne] { color: #0077aa } /* Name.Exception */
c-[nf] { color: #0077aa } /* Name.Function */
c-[nl] { color: #0077aa } /* Name.Label */
c-[nn] { color: #0077aa } /* Name.Namespace */
c-[py] { color: #0077aa } /* Name.Property */
c-[ow] { color: #999999 } /* Operator.Word */
c-[mb] { color: #000000 } /* Literal.Number.Bin */
c-[mf] { color: #000000 } /* Literal.Number.Float */
c-[mh] { color: #000000 } /* Literal.Number.Hex */
c-[mi] { color: #000000 } /* Literal.Number.Integer */
c-[mo] { color: #000000 } /* Literal.Number.Oct */
c-[sb] { color: #a67f59 } /* Literal.String.Backtick */
c-[sc] { color: #a67f59 } /* Literal.String.Char */
c-[sd] { color: #a67f59 } /* Literal.String.Doc */
c-[se] { color: #a67f59 } /* Literal.String.Escape */
c-[sh] { color: #a67f59 } /* Literal.String.Heredoc */
c-[si] { color: #a67f59 } /* Literal.String.Interpol */
c-[sx] { color: #a67f59 } /* Literal.String.Other */
c-[sr] { color: #a67f59 } /* Literal.String.Regex */
c-[ss] { color: #a67f59 } /* Literal.String.Symbol */
c-[vc] { color: #0077aa } /* Name.Variable.Class */
c-[vg] { color: #0077aa } /* Name.Variable.Global */
c-[vi] { color: #0077aa } /* Name.Variable.Instance */
c-[il] { color: #000000 } /* Literal.Number.Integer.Long */


@media (prefers-color-scheme: dark) {
    .highlight:not(.idl) { background: rgba(255, 255, 255, .05); }

    c-[a] { color: #d33682 } /* Keyword.Declaration */
    c-[b] { color: #d33682 } /* Keyword.Type */
    c-[c] { color: #2aa198 } /* Comment */
    c-[d] { color: #2aa198 } /* Comment.Multiline */
    c-[e] { color: #268bd2 } /* Name.Attribute */
    c-[f] { color: #b58900 } /* Name.Tag */
    c-[g] { color: #cb4b16 } /* Name.Variable */
    c-[k] { color: #d33682 } /* Keyword */
    c-[l] { color: #657b83 } /* Literal */
    c-[m] { color: #657b83 } /* Literal.Number */
    c-[n] { color: #268bd2 } /* Name */
    c-[o] { color: #657b83 } /* Operator */
    c-[p] { color: #657b83 } /* Punctuation */
    c-[s] { color: #6c71c4 } /* Literal.String */
    c-[t] { color: #6c71c4 } /* Literal.String.Single */
    c-[u] { color: #6c71c4 } /* Literal.String.Double */
    c-[ch] { color: #2aa198 } /* Comment.Hashbang */
    c-[cp] { color: #2aa198 } /* Comment.Preproc */
    c-[cpf] { color: #2aa198 } /* Comment.PreprocFile */
    c-[c1] { color: #2aa198 } /* Comment.Single */
    c-[cs] { color: #2aa198 } /* Comment.Special */
    c-[kc] { color: #d33682 } /* Keyword.Constant */
    c-[kn] { color: #d33682 } /* Keyword.Namespace */
    c-[kp] { color: #d33682 } /* Keyword.Pseudo */
    c-[kr] { color: #d33682 } /* Keyword.Reserved */
    c-[ld] { color: #657b83 } /* Literal.Date */
    c-[nc] { color: #268bd2 } /* Name.Class */
    c-[no] { color: #268bd2 } /* Name.Constant */
    c-[nd] { color: #268bd2 } /* Name.Decorator */
    c-[ni] { color: #268bd2 } /* Name.Entity */
    c-[ne] { color: #268bd2 } /* Name.Exception */
    c-[nf] { color: #268bd2 } /* Name.Function */
    c-[nl] { color: #268bd2 } /* Name.Label */
    c-[nn] { color: #268bd2 } /* Name.Namespace */
    c-[py] { color: #268bd2 } /* Name.Property */
    c-[ow] { color: #657b83 } /* Operator.Word */
    c-[mb] { color: #657b83 } /* Literal.Number.Bin */
    c-[mf] { color: #657b83 } /* Literal.Number.Float */
    c-[mh] { color: #657b83 } /* Literal.Number.Hex */
    c-[mi] { color: #657b83 } /* Literal.Number.Integer */
    c-[mo] { color: #657b83 } /* Literal.Number.Oct */
    c-[sa] { color: #6c71c4 } /* Literal.String.Affix */
    c-[sb] { color: #6c71c4 } /* Literal.String.Backtick */
    c-[sc] { color: #6c71c4 } /* Literal.String.Char */
    c-[dl] { color: #6c71c4 } /* Literal.String.Delimiter */
    c-[sd] { color: #6c71c4 } /* Literal.String.Doc */
    c-[se] { color: #6c71c4 } /* Literal.String.Escape */
    c-[sh] { color: #6c71c4 } /* Literal.String.Heredoc */
    c-[si] { color: #6c71c4 } /* Literal.String.Interpol */
    c-[sx] { color: #6c71c4 } /* Literal.String.Other */
    c-[sr] { color: #6c71c4 } /* Literal.String.Regex */
    c-[ss] { color: #6c71c4 } /* Literal.String.Symbol */
    c-[fm] { color: #268bd2 } /* Name.Function.Magic */
    c-[vc] { color: #cb4b16 } /* Name.Variable.Class */
    c-[vg] { color: #cb4b16 } /* Name.Variable.Global */
    c-[vi] { color: #cb4b16 } /* Name.Variable.Instance */
    c-[vm] { color: #cb4b16 } /* Name.Variable.Magic */
    c-[il] { color: #657b83 } /* Literal.Number.Integer.Long */
}
</style>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"></p>
   <h1 class="p-name no-ref" id="title">D2767R1<br>flat_map/flat_set omnibus</h1>
   <h2 class="no-num no-toc no-ref heading settled" id="profile-and-date"><span class="content">Draft Proposal, <time class="dt-updated" datetime="2023-07-14">2023-07-14</time></span></h2>
   <div data-fill-with="spec-metadata">
    <dl>
     <dt class="editor">Author:
     <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:arthur.j.odwyer@gmail.com">Arthur O'Dwyer</a>
     <dt>Audience:
     <dd>LWG
     <dt>Project:
     <dd>ISO/IEC JTC1/SC22/WG21 14882: Programming Language — C++
     <dt>Draft Revision:
     <dd>14
     <dt>Current Source:
     <dd><a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d2767-flat-omnibus.bs">github.com/Quuxplusone/draft/blob/gh-pages/d2767-flat-omnibus.bs</a>
     <dt>Current:
     <dd><a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d2767-flat-omnibus.html">rawgit.com/Quuxplusone/draft/gh-pages/d2767-flat-omnibus.html</a>
    </dl>
   </div>
   <div data-fill-with="warning"></div>
   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract">
   <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
   <p>Issues and resolutions in C++23 <code class="highlight"><c- n>flat_set</c-></code> and <code class="highlight"><c- n>flat_map</c-></code>, based on libc++'s implementation experience.</p>
  </div>
  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref" id="contents">Table of Contents</h2>
   <ol class="toc" role="directory">
    <li><a href="#changelog"><span class="secno">1</span> <span class="content">Changelog</span></a>
    <li><a href="#intro"><span class="secno">2</span> <span class="content">Introduction</span></a>
    <li><a href="#editorial-cons-alloc"><span class="secno">3</span> <span class="content">Editorial (merged in R0)</span></a>
    <li>
     <a href="#explicit-oops"><span class="secno">4</span> <span class="content">Accidentally explicit constructor</span></a>
     <ol class="toc">
      <li><a href="#wording-explicit-oops"><span class="secno">4.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#set-insert-range"><span class="secno">5</span> <span class="content">Add move semantics to <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>insert_range</c-></code></span></a>
     <ol class="toc">
      <li><a href="#wording-set-insert-range"><span class="secno">5.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#map-insert-range"><span class="secno">6</span> <span class="content">Add move semantics to <code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>insert_range</c-></code></span></a>
     <ol class="toc">
      <li><a href="#wording-map-insert-range"><span class="secno">6.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#insert-emplace"><span class="secno">7</span> <span class="content"><code class="highlight"><c- n>insert</c-></code> is more primitive than <code class="highlight"><c- n>emplace</c-></code></span></a>
     <ol class="toc">
      <li><a href="#heterogeneous-insert-multiset-redirect"><span class="secno">7.1</span> <span class="content">Heterogeneous <code class="highlight"><c- n>insert</c-></code> (to LEWG)</span></a>
      <li><a href="#emplace-phrasing"><span class="secno">7.2</span> <span class="content">"Initializes" phrasing</span></a>
      <li><a href="#emplace-constraint"><span class="secno">7.3</span> <span class="content">Unusual constraints</span></a>
      <li><a href="#insert-ambiguity"><span class="secno">7.4</span> <span class="content">Ambiguity with <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code></span></a>
      <li><a href="#multiset-emplace"><span class="secno">7.5</span> <span class="content"><code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>emplace</c-></code> by rotation</span></a>
      <li><a href="#wording-insert-emplace"><span class="secno">7.6</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#insert-range-sorted-unique"><span class="secno">8</span> <span class="content"><code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code></span></a>
     <ol class="toc">
      <li><a href="#wording-insert-range-sorted-unique"><span class="secno">8.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#sorting-complexity"><span class="secno">9</span> <span class="content">Complexity clauses of container constructors</span></a>
     <ol class="toc">
      <li><a href="#wording-sorting-complexity"><span class="secno">9.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#replace-by-value"><span class="secno">10</span> <span class="content"><code class="highlight"><c- n>replace</c-></code> should take by value</span></a>
     <ol class="toc">
      <li><a href="#wording-replace-by-value"><span class="secno">10.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#keys-method"><span class="secno">11</span> <span class="content">Add <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>keys</c-><c- p>()</c-></code></span></a>
     <ol class="toc">
      <li><a href="#wording-keys-method"><span class="secno">11.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#issues-for-discussion"><span class="secno">12</span> <span class="content">Issues for discussion</span></a>
     <ol class="toc">
      <li><a href="#stable-sorting"><span class="secno">12.1</span> <span class="content">Stable sorting in <code class="highlight"><c- n>insert</c-></code></span></a>
      <li><a href="#deceptive-redirect"><span class="secno">12.2</span> <span class="content">Non-explicit container constructor</span></a>
      <li>
       <a href="#complexity-equal-range"><span class="secno">12.3</span> <span class="content">Complexity of <code class="highlight"><c- n>equal_range</c-></code></span></a>
       <ol class="toc">
        <li><a href="#wording-complexity-equal-range"><span class="secno">12.3.1</span> <span class="content">Wording</span></a>
       </ol>
      <li><a href="#special-members"><span class="secno">12.4</span> <span class="content">Special member functions</span></a>
      <li>
       <a href="#move-from-comparator"><span class="secno">12.5</span> <span class="content">Moving from the comparator</span></a>
       <ol class="toc">
        <li><a href="#wording-special-members"><span class="secno">12.5.1</span> <span class="content">Possible wording</span></a>
       </ol>
      <li>
       <a href="#qualifies-container"><span class="secno">12.6</span> <span class="content">"Qualifies as a container"</span></a>
       <ol class="toc">
        <li><a href="#wording-qualifies-container"><span class="secno">12.6.1</span> <span class="content">Wording</span></a>
       </ol>
      <li><a href="#iterator-types"><span class="secno">12.7</span> <span class="content"><code class="highlight"><c- n>iterator</c-></code> and <code class="highlight"><c- n>const_iterator</c-></code></span></a>
      <li><a href="#containers"><span class="secno">12.8</span> <span class="content">Support for non-standard containers</span></a>
      <li><a href="#redundancy"><span class="secno">12.9</span> <span class="content">Inconsistent handling of redundancy in [flat.multiset] and [flat.multimap]</span></a>
      <li>
       <a href="#noexcept-swap"><span class="secno">12.10</span> <span class="content">Noexcept <code class="highlight"><c- n>swap</c-></code></span></a>
       <ol class="toc">
        <li><a href="#ranges-swap"><span class="secno">12.10.1</span> <span class="content">Specified in terms of <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-></code></span></a>
       </ol>
      <li><a href="#lwg-3802"><span class="secno">12.11</span> <span class="content">Allocator-extended container constructors lack move semantics</span></a>
     </ol>
    <li>
     <a href="#heterogeneous-insert-multiset"><span class="secno">13</span> <span class="content">Heterogeneous <code class="highlight"><c- n>multiset</c-><c- o>::</c-><c- n>insert</c-></code></span></a>
     <ol class="toc">
      <li><a href="#wording-heterogeneous-insert-multiset"><span class="secno">13.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#deceptive"><span class="secno">14</span> <span class="content">Non-explicit constructor from two containers</span></a>
     <ol class="toc">
      <li>
       <a href="#deceptive-explicit"><span class="secno">14.1</span> <span class="content">Make the container constructors explicit?</span></a>
       <ol class="toc">
        <li><a href="#wording-deceptive-explicit"><span class="secno">14.1.1</span> <span class="content">Possible wording for explicit ctor</span></a>
       </ol>
      <li>
       <a href="#deceptive-remove"><span class="secno">14.2</span> <span class="content">Remove the container constructors; make <code class="highlight"><c- n>replace</c-></code> sort by default</span></a>
       <ol class="toc">
        <li><a href="#wording-deceptive-remove"><span class="secno">14.2.1</span> <span class="content">Wording for tagged <code class="highlight"><c- n>replace</c-></code></span></a>
       </ol>
     </ol>
    <li><a href="#experience"><span class="secno">15</span> <span class="content">Implementation experience</span></a>
    <li><a href="#acknowledgments"><span class="secno">16</span> <span class="content">Acknowledgments</span></a>
    <li>
     <a href="#references"><span class="secno"></span> <span class="content">References</span></a>
     <ol class="toc">
      <li><a href="#informative"><span class="secno"></span> <span class="content">Informative References</span></a>
     </ol>
   </ol>
  </nav>
  <main>
   <h2 class="heading settled" data-level="1" id="changelog"><span class="secno">1. </span><span class="content">Changelog</span><a class="self-link" href="#changelog"></a></h2>
   <ul>
    <li data-md>
     <p>R1 (post-Varna 2023):</p>
     <ul>
      <li data-md>
       <p>LWG approved §3 as editorial.</p>
      <li data-md>
       <p>LWG reviewed §4,5,6,7. Update those sections' rationales and proposed wordings.</p>
      <li data-md>
       <p>Split <a href="#heterogeneous-insert-multiset-redirect">§ 7.1 Heterogeneous insert (to LEWG)</a> away from the rest of §7, because it (alone) requires LEWG input;
  it is now <a href="#heterogeneous-insert-multiset">§ 13 Heterogeneous multiset::insert</a>.</p>
      <li data-md>
       <p>Split <a href="#deceptive-redirect">§ 12.2 Non-explicit container constructor</a> away from the rest of §12, to draw attention;
  it is now <a href="#deceptive">§ 14 Non-explicit constructor from two containers</a>. Write its wording.</p>
     </ul>
    <li data-md>
     <p>R0 (pre-Varna 2023):</p>
     <ul>
      <li data-md>
       <p>Initial draft.</p>
     </ul>
   </ul>
   <h2 class="heading settled" data-level="2" id="intro"><span class="secno">2. </span><span class="content">Introduction</span><a class="self-link" href="#intro"></a></h2>
   <p>Arthur has implemented all of <a data-link-type="biblio" href="#biblio-p0429" title="A standard flat_map">[P0429]</a> <code class="highlight"><c- n>flat_map</c-></code> and <a data-link-type="biblio" href="#biblio-p1222" title="A standard flat_set">[P1222]</a> <code class="highlight"><c- n>flat_set</c-></code> for libc++.
As he implemented them, he and Louis Dionne collected issues that libc++ would like to see resolved
by LWG. This paper presents all of these issues together in one place, along with Arthur’s proposed
solutions for each one.</p>
   <p>Some of the proposed solutions are LEWG-level design changes. Contrariwise, some of the issues collected
here don’t have "solutions" at all, but are recorded merely For Your Information (for other vendors/implementors)
to document the design choices libc++ has made.</p>
   <h2 class="heading settled" data-level="3" id="editorial-cons-alloc"><span class="secno">3. </span><span class="content">Editorial (merged in R0)</span><a class="self-link" href="#editorial-cons-alloc"></a></h2>
   <p>P2767R0’s editorial change was reviewed by LWG in Varna (2023-06-16) and approved;
it is submitted as <a href="https://github.com/cplusplus/draft/pull/6274">#6274</a>.</p>
   <p>#6274 trivially merge-conflicts with the resolution of <a data-link-type="biblio" href="#biblio-lwg3884" title="flat_foo is missing allocator-extended copy/move constructors">[LWG3884]</a> (which adds new
allocator-extended constructors). I propose to rebase LWG3884’s resolution on top of #6274
as soon as #6274 is merged to trunk.</p>
   <h2 class="heading settled" data-level="4" id="explicit-oops"><span class="secno">4. </span><span class="content">Accidentally explicit constructor</span><a class="self-link" href="#explicit-oops"></a></h2>
   <p>STL style is that multi-argument constructors should be non-<code class="highlight"><c- k>explicit</c-></code>; see <a data-link-type="biblio" href="#biblio-p1163" title="Explicitly implicifying explicit constructors">[P1163]</a>.
This change is non-editorial, but should be non-controversial.</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>v</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-> <c- n>s</c-> <c- o>=</c-> <c- p>{</c-> <c- n>v</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- p>(),</c-> <c- n>std</c-><c- o>::</c-><c- n>allocator</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-><c- p>()</c-> <c- p>};</c->
  <c- c1>// OK</c->
<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-> <c- n>s</c-> <c- o>=</c-> <c- p>{</c-> <c- n>v</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- p>()</c-> <c- p>};</c->
  <c- c1>// Before: Ill-formed</c->
  <c- c1>// After: OK</c->
</pre>
   <h3 class="heading settled" data-level="4.1" id="wording-explicit-oops"><span class="secno">4.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-explicit-oops"></a></h3>
   <p class="note" role="note"><span class="marker">Note:</span> This section was updated in R1 following LWG’s preferred direction.
Thanks to Zhihao Yuan for finding the precedent for "Let <code class="highlight"><c- n>comp</c-></code> be..." in <a href="https://eel.is/c++draft/list.ops#20"><code class="highlight"><c- n>list</c-><c- o>::</c-><c- n>unique</c-></code></a>.</p>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.multiset.cons], constructors</c->
<c- n>flat_multiset</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->

<c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
  <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->

<del><c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
<ins><c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>);</c-></ins>
<ins><c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>);</c-></ins>

<c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>container_type</c-> <c- n>cont</c-><c- p>,</c->
              <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
  <c- o>:</c-> <c- n>c</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.cons">[flat.multiset.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><del><c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
<ins><c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>);</c-></ins>
<ins><c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>);</c-></ins>
</pre> <ins>x․ Let <code class="highlight"><c- n>comp</c-></code> be <code class="highlight"><c- n>key_compare</c-><c- p>()</c-></code> for the first overload.</ins> <p>1․ Effects: Initializes <i><code class="highlight"><c- n>c</c-></code></i> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <i><code class="highlight"><c- n>compare</c-></code></i> with <code class="highlight"><c- n>comp</c-></code>,
and sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <i><code class="highlight"><c- n>compare</c-></code></i>.</p> <p>2․ Complexity: Linear in <i>N</i> if <code class="highlight"><c- n>cont</c-></code> is already sorted with respect to <i><code class="highlight"><c- n>compare</c-></code></i> and otherwise <i>N</i> log <i>N</i>, where <i>N</i> is the value of <code class="highlight"><c- n>cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</p> </small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.set.cons], constructors</c->
<c- n>flat_set</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->

<c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
  <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->

<del><c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
<ins><c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>);</c-></ins>
<ins><c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>);</c-></ins>

<c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
  <c- o>:</c-> <c- n>c</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.cons">[flat.set.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><del><c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
<ins><c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>);</c-></ins>
<ins><c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>);</c-></ins>
</pre> <ins>x․ Let <code class="highlight"><c- n>comp</c-></code> be <code class="highlight"><c- n>key_compare</c-><c- p>()</c-></code> for the first overload.</ins> <p>1․ Effects: Initializes <i><code class="highlight"><c- n>c</c-></code></i> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <i><code class="highlight"><c- n>compare</c-></code></i> with <code class="highlight"><c- n>comp</c-></code>,
sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <i><code class="highlight"><c- n>compare</c-></code></i>,
and finally erases all but the first element from each group of consecutive equivalent elements.</p> <p>2․ Complexity: Linear in <i>N</i> if <code class="highlight"><c- n>cont</c-></code> is already sorted with respect to <i><code class="highlight"><c- n>compare</c-></code></i> and otherwise <i>N</i> log <i>N</i>, where <i>N</i> is the value of <code class="highlight"><c- n>cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="5" id="set-insert-range"><span class="secno">5. </span><span class="content">Add move semantics to <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>insert_range</c-></code></span><a class="self-link" href="#set-insert-range"></a></h2>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>fs1</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>v1</c-> <c- o>=</c-> <c- p>{</c-><c- s>"hello"</c-><c- p>,</c-> <c- s>"world"</c-><c- p>};</c->
<c- n>fs1</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>as_rvalue</c-><c- p>(</c-><c- n>v1</c-><c- p>));</c->
  <c- c1>// Before: Copies the strings.</c->
  <c- c1>// After: Moves the strings.</c->

<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>fs2</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>v2</c-><c- p>;</c->
<c- n>fs2</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>as_rvalue</c-><c- p>(</c-><c- n>v2</c-><c- p>));</c->
  <c- c1>// Before: Ill-formed.</c->
  <c- c1>// After: Moves the unique_ptrs.</c->
</pre>
   <p>Compare the current wording for <a href="https://eel.is/c++draft/flat.set#lib:insert_range,flat_set"><code class="highlight"><c- n>flat_set</c-><c- p>.</c-><c- n>insert_range</c-></code></a> (added by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf">P1222</a>) versus <a href="https://eel.is/c++draft/priority.queue#lib:push_range,priority_queue"><code class="highlight"><c- n>priority_queue</c-><c- p>.</c-><c- n>push_range</c-></code></a> (added in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1206r5.pdf">P1206R5</a> and tweaked in R6). <code class="highlight"><c- n>priority_queue</c-></code>’s wording is not only more robustly Rangified, but also more performant.</p>
   <p>Arthur doesn’t know why P1206R5/R6 chose to pass <code class="highlight"><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-></code> to <code class="highlight"><c- n>append_range</c-></code> but plain old lvalue <code class="highlight"><c- n>rg</c-></code> to <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>copy</c-></code>; it seems like it should have forwarded in both places or else forwarded in neither place.
Arthur is trying to find out from P1206’s authors. For now, by default, let’s just be consistent with P1206.</p>
   <h3 class="heading settled" data-level="5.1" id="wording-set-insert-range"><span class="secno">5.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-set-insert-range"></a></h3>
   <p class="note" role="note"><span class="marker">Note:</span> This section was updated in R1 following LWG’s preferred direction; see rationale above.</p>
   <p>Change <a href="https://eel.is/c++draft/flat.set#modifiers-10">[flat.set.modifiers]/10</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
</pre> <p>10․ Effects: <del>Adds elements to <i><code class="highlight"><c- n>c</c-></code></i> as if by:</del></p> <pre class="highlight"><del><c- k>for</c-> <c- p>(</c-><c- k>const</c-> <c- k>auto</c-><c- o>&amp;</c-> <c- n>e</c-> <c- o>:</c-> <c- n>rg</c-><c- p>)</c-> <c- p>{</c-></del>
  <del><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>e</c-><c- p>);</c-></del>
<del><c- p>}</c-></del>
</pre><ins>Adds all elements of <code class="highlight"><c- n>rg</c-></code> to <i><code class="highlight"><c- n>c</c-></code></i> via <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>append_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>))</c-></code> if that is a valid expression, or <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>copy</c-><c- p>(</c-><c- n>rg</c-><c- p>,</c-> <c- n>back_inserter</c-><c- p>(</c-><c- n>c</c-><c- p>))</c-></code> otherwise.</ins> Then,
sorts the range of newly inserted elements with respect to <i><code class="highlight"><c- n>compare</c-></code></i>;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases all but the first element from each group of consecutive equivalent elements. <p>11․ Complexity: <i>N</i> + <i>M</i> log <i>M</i>, where <i>N</i> is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> before the operation and <i>M</i> is <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>distance</c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-></code>.</p> <p>12․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</p> </small>
   </blockquote>
   <p>Add a new section to <a href="https://eel.is/c++draft/flat.multiset#modifiers">[flat.multiset.modifiers]</a> explaining the semantics of <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>insert_range</c-></code>.</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
</pre> <p><ins>x․ Effects: Adds all elements of <code class="highlight"><c- n>rg</c-></code> to <i><code class="highlight"><c- n>c</c-></code></i> via <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>append_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>))</c-></code> if that is a valid expression, or <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>copy</c-><c- p>(</c-><c- n>rg</c-><c- p>,</c-> <c- n>back_inserter</c-><c- p>(</c-><c- n>c</c-><c- p>))</c-></code> otherwise.
Then, sorts the range of newly inserted elements with respect to <i><code class="highlight"><c- n>compare</c-></code></i>, and
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range. </ins></p><p><ins>x․ Complexity: <i>N</i> + <i>M</i> log <i>M</i>, where <i>N</i> is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> before the operation and <i>M</i> is <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>distance</c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-></code>. </ins></p><p><ins>x․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</ins> </p></small>
   </blockquote>
   <h2 class="heading settled" data-level="6" id="map-insert-range"><span class="secno">6. </span><span class="content">Add move semantics to <code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>insert_range</c-></code></span><a class="self-link" href="#map-insert-range"></a></h2>
   <p><code class="highlight"><c- n>flat_map</c-></code>’s <code class="highlight"><c- n>insert_range</c-></code> has the same issue as <code class="highlight"><c- n>flat_set</c-></code>’s, at least on paper.</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>flat_map</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>fs2</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>>></c-> <c- n>v2</c-><c- p>;</c->
<c- n>fs2</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>as_rvalue</c-><c- p>(</c-><c- n>v2</c-><c- p>));</c->
  <c- c1>// Before: Ill-formed.</c->
  <c- c1>// After: Moves the unique_ptrs.</c->
</pre>
   <p>The <code class="highlight"><c- n>insert_range</c-></code> method is constrained on <i><code class="highlight"><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></code></i><code class="highlight"><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-></code>,
i.e. <code class="highlight"><c- n>convertible_to</c-><c- o>&lt;</c-><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>value_type</c-><c- o>></c-></code>.
But in fact the current spec’s algorithm never attempts to convert <code class="highlight"><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-></code> to <code class="highlight"><c- n>value_type</c-></code>.
Instead, it implicitly requires that <code class="highlight"><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>::</c-><c- n>first</c-></code> be convertible to <code class="highlight"><c- n>key_type</c-></code> and <code class="highlight"><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>::</c-><c- n>second</c-></code> be convertible to <code class="highlight"><c- n>mapped_type</c-></code>. If <code class="highlight"><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-></code> is
something without <code class="highlight"><c- n>first</c-></code> and <code class="highlight"><c- n>second</c-></code> members, the current spec doesn’t work at all.</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-> <c- n>p1</c-> <c- o>=</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>};</c->
<c- n>std</c-><c- o>::</c-><c- n>reference_wrapper</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>>></c-> <c- n>a</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- n>p1</c-> <c- p>};</c->
<c- n>std</c-><c- o>::</c-><c- n>flat_map</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-> <c- n>fm</c-><c- p>;</c->
<c- n>fm</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
  <c- c1>// Before: Ill-formed: reference_wrapper has no .first member</c->
  <c- c1>// After: OK</c->
</pre>
   <p>The wording below implicitly converts <code class="highlight"><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-></code> to <code class="highlight"><c- n>value_type</c-> <c- n>e</c-></code>, and then
move-constructs from <code class="highlight"><c- n>e</c-><c- p>.</c-><c- n>first</c-></code> and <code class="highlight"><c- n>e</c-><c- p>.</c-><c- n>second</c-></code> into the map’s containers. Note that <code class="highlight"><c- n>e</c-><c- p>.</c-><c- n>first</c-></code> and <code class="highlight"><c- n>e</c-><c- p>.</c-><c- n>second</c-></code> are never reference types, so <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-></code> is correct.</p>
   <p>LWG in Varna briefly feinted in the direction of trying to metaprogram away the extra move-construct
(e.g. by changing the lambda’s parameter type to something like <code class="highlight"><c- n>conditional_t</c-><c- o>&lt;</c-><c- n>same_as</c-><c- o>&lt;</c-><c- n>decay_t</c-><c- o>&lt;</c-><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>></c-><c- p>,</c-> <c- n>value_type</c-><c- o>></c-><c- p>,</c-> <c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>value_type</c-><c- o>></c-></code>),
but I felt strongly that the chance of getting that correct on the first try was near-nil.
Besides, we realized that we were trying to save O(M) move operations along a codepath
whose very next step was to do an O(M log M) sort and an O(N) <code class="highlight"><c- n>inplace_merge</c-></code>.</p>
   <p>If any library vendor actually wants to try that kind of metaprogramming,
they are welcome to do so under the As-If Rule. libc++ will not do it.</p>
   <h3 class="heading settled" data-level="6.1" id="wording-map-insert-range"><span class="secno">6.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-map-insert-range"></a></h3>
   <p class="note" role="note"><span class="marker">Note:</span> This section was updated in R1 following LWG’s preferred direction; see rationale above.</p>
   <p>We don’t need to touch [flat.multimap.modifiers]; in fact it does not currently exist;
because of <a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview]/4</a>:</p>
   <p><small></small></p>
   <blockquote><small> 4․ Except as otherwise noted, operations on <code class="highlight"><c- n>flat_multimap</c-></code> are equivalent to those of <code class="highlight"><c- n>flat_map</c-></code>,
except that <code class="highlight"><c- n>flat_multimap</c-></code> operations do not remove or replace elements with equal keys.<p></p> </small></blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.map.modifiers#12">[flat.map.modifiers]/12</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
</pre> <p>12․ Effects: Adds elements to <code class="highlight"><c- n>c</c-></code> as if by:</p> <pre class="highlight"><del><c- k>for</c-> <c- p>(</c-><c- k>const</c-> <c- k>auto</c-><c- o>&amp;</c-> <c- n>e</c-> <c- o>:</c-> <c- n>rg</c-><c- p>)</c-></del>
<ins><c- n>ranges</c-><c- o>::</c-><c- n>for_each</c-><c- p>(</c-><c- n>rg</c-><c- p>,</c-> <c- p>[</c-><c- o>&amp;</c-><c- n>c</c-><c- p>](</c-><c- n>value_type</c-> <c- n>e</c-><c- p>)</c-></ins> <c- p>{</c->
  <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <ins><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-></ins><c- n>e</c-><c- p>.</c-><c- n>first</c-><ins><c- p>)</c-></ins><c- p>);</c->
  <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <ins><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-></ins><c- n>e</c-><c- p>.</c-><c- n>second</c-><ins><c- p>)</c-></ins><c- p>);</c->
<c- p>}</c-><ins><c- p>);</c-></ins>
</pre><p>Then, sorts the range of newly inserted elements with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases the duplicate elements as if by:</p> <pre class="highlight"><c- k>auto</c-> <c- n>zv</c-> <c- o>=</c-> <c- n>views</c-><c- o>::</c-><c- n>zip</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>);</c->
<c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>unique</c-><c- p>(</c-><c- n>zv</c-><c- p>,</c-> <c- n>key_equiv</c-><c- p>(</c-><c- n>compare</c-><c- p>)).</c-><c- n>begin</c-><c- p>();</c->
<c- k>auto</c-> <c- n>dist</c-> <c- o>=</c-> <c- n>distance</c-><c- p>(</c-><c- n>zv</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>it</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
<c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
</pre> <p>13․ Complexity: N + M log M, where N is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> before the operation and M is <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>distance</c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-></code>.</p> <p>14․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="7" id="insert-emplace"><span class="secno">7. </span><span class="content"><code class="highlight"><c- n>insert</c-></code> is more primitive than <code class="highlight"><c- n>emplace</c-></code></span><a class="self-link" href="#insert-emplace"></a></h2>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>set_default_resource</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>null_memory_resource</c-><c- p>());</c->
<c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>monotonic_buffer_resource</c-> <c- nf>mr</c-><c- p>(</c-><c- mi>1</c->’<c- mo>000</c->’<c- mo>000</c-><c- p>);</c->

<c- k>auto</c-> <c- n>fm</c-> <c- o>=</c-> <c- n>PmrFlatSet</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- o>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-> <c- n>ps</c-><c- p>(</c-><c- s>"too long to fit in the small string buffer"</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>fm</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>ps</c-><c- p>);</c->
  <c- c1>// Before: runtime abort, cannot default-allocate t</c->
  <c- c1>// After: OK</c->
</pre>
   <p>Whenever we insert or emplace into a set or multiset, we have two tasks:</p>
   <ul>
    <li data-md>
     <p>Construct the new <code class="highlight"><c- n>value_type</c-></code> object.</p>
    <li data-md>
     <p>Find the correct insertion point for the new object.</p>
   </ul>
   <p><code class="highlight"><c- n>emplace</c-></code> receives a bag of constructor arguments, so it has no choice: it must do
"construct <code class="highlight"><c- n>t</c-></code>, find insertion point for <code class="highlight"><c- n>t</c-></code>, move-insert <code class="highlight"><c- n>t</c-></code> into the container" exactly as specified above.</p>
   <p>But <code class="highlight"><c- n>insert</c-></code> receives an already-constructed <code class="highlight"><c- n>value_type</c-></code>! It shouldn’t discard that valuable information;
it should use the given <code class="highlight"><c- n>value_type</c-></code> to find the appropriate insertion point, and then construct the new object
directly in place. There is no reason to construct <code class="highlight"><c- n>t</c-></code> on the stack first.</p>
   <p>The current definition of <code class="highlight"><c- n>emplace</c-></code> is not expressed in terms of <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- p>(...))</c-></code>. P2767R0 proposed
not to change it, simply to keep the diff small. But LWG in Varna asked to make that simplification.
libc++'s implementation already implements <code class="highlight"><c- n>emplace</c-></code> in terms of <code class="highlight"><c- n>insert</c-></code>, so there doesn’t seem to be
any sneaky subtlety in that area; we can just do it. So P2767R1 does it.</p>
   <h3 class="heading settled" data-level="7.1" id="heterogeneous-insert-multiset-redirect"><span class="secno">7.1. </span><span class="content">Heterogeneous <code class="highlight"><c- n>insert</c-></code> (to LEWG)</span><a class="self-link" href="#heterogeneous-insert-multiset-redirect"></a></h3>
   <p class="note" role="note"><span class="marker">Note:</span> LWG in Varna raised an objection to adding heterogeneous <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> without LEWG input. On the other hand, §7.2,3,4 were acceptable LWG business. Therefore,
the rationale and wording for P2767R0’s §7.1 have moved to <a href="#heterogeneous-insert-multiset">§ 13 Heterogeneous multiset::insert</a>,
and P2767R1’s <a href="#wording-insert-emplace">§ 7.6 Wording</a> no longer includes the <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> overload.</p>
   <h3 class="heading settled" data-level="7.2" id="emplace-phrasing"><span class="secno">7.2. </span><span class="content">"Initializes" phrasing</span><a class="self-link" href="#emplace-phrasing"></a></h3>
   <p>The proposed wording below brings <a href="https://eel.is/c++draft/flat.map.modifiers#2">[flat.map.modifiers]/2</a> into line with e.g. <a href="https://eel.is/c++draft/variant#ctor-21">[variant.ctor]/21</a> and <a href="https://eel.is/c++draft/forward.list#modifiers-23">[forward.list.modifiers]/23</a>:</p>
   <p><small></small></p>
   <blockquote><small> 2․ Effects: <del>Initializes</del> <ins>Direct-non-list-initializes</ins> an object <code class="highlight"><c- n>t</c-></code> of type <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>key_type</c-><c- p>,</c-> <c- n>mapped_type</c-><c- o>></c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...</c-></code>;
if the map already contains an element whose key is equivalent to <code class="highlight"><c- n>t</c-><c- p>.</c-><c- n>first</c-></code>, <code class="highlight"><c- o>*</c-><c- k>this</c-></code> is unchanged. [...]<p></p> </small></blockquote>
   <p>P2767R0 asked whether LWG had appetite to invent something less jargony. No, LWG did not.</p>
   <h3 class="heading settled" data-level="7.3" id="emplace-constraint"><span class="secno">7.3. </span><span class="content">Unusual constraints</span><a class="self-link" href="#emplace-constraint"></a></h3>
   <p>The usual pattern in [containers] is that <code class="highlight"><c- n>x</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>args</c-><c- p>...)</c-></code> has a precondition (<a href="https://eel.is/c++draft/containers#sequence.reqmts-21">[sequence.reqmts]</a>, <a href="https://eel.is/c++draft/containers#associative.reqmts.general-48">[associative.reqmts.general]</a>)
but no Constraints element. That is, <code class="highlight"><c- n>emplace</c-></code> is not SFINAE-friendly. And it has only the one overload,
so it doesn’t need a constraint for purposes of overload resolution.</p>
   <p>No Constraints on <code class="highlight"><c- n>emplace</c-></code>: <a href="https://eel.is/c++draft/deque.modifiers#lib:deque,emplace"><code class="highlight"><c- n>deque</c-></code></a>, <a href="https://eel.is/c++draft/list.modifiers"><code class="highlight"><c- n>list</c-></code></a>, <a href="https://eel.is/c++draft/vector.modifiers"><code class="highlight"><c- n>vector</c-></code></a>, <a href="https://eel.is/c++draft/sequence.reqmts#lib:emplace,containers">containers</a>, <a href="https://eel.is/c++draft/associative.reqmts.general#lib:emplace,ordered_associative_containers">associative containers</a>, <a href="https://eel.is/c++draft/unord.req.general#lib:emplace,unordered_associative_containers">unordered containers</a>, <a href="https://eel.is/c++draft/priqueue.members#lib:priority_queue,emplace"><code class="highlight"><c- n>priority_queue</c-></code></a>, <a href="https://eel.is/c++draft/optional.assign#lib:emplace,optional"><code class="highlight"><c- n>optional</c-></code></a>.</p>
   <p>Constraints on <code class="highlight"><c- n>emplace</c-></code>: <a href="https://eel.is/c++draft/flat.map.modifiers#lib:flat_map,emplace"><code class="highlight"><c- n>flat_map</c-></code></a>, <a href="https://eel.is/c++draft/flat.multiset.modifiers#lib:flat_multiset,emplace"><code class="highlight"><c- n>flat_multiset</c-></code></a>, <a href="https://eel.is/c++draft/any.modifiers#lib:emplace,any"><code class="highlight"><c- n>any</c-></code></a>, <a href="https://eel.is/c++draft/expected.object.assign#lib:emplace,expected"><code class="highlight"><c- n>expected</c-></code></a>, <a href="https://eel.is/c++draft/variant.mod#lib:emplace,variant"><code class="highlight"><c- n>variant</c-></code></a>.</p>
   <p>I believe a Constraints element was accidentally copy-pasted from the spec of <a href="https://eel.is/c++draft/flat.map.modifiers#4"><code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>P</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code></a> —<wbr>which <em>does</em> need the constraint because it’s part of <code class="highlight"><c- n>insert</c-></code>’s large overload set — to <code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>emplace</c-></code>,
and then from there to <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>emplace</c-></code>. The constraint is already (correctly) absent
from <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>emplace</c-></code>.</p>
   <p>Therefore, the proposed wording for this section simply deletes those Constraints elements.</p>
   <p>With the Constraints elements gone, and <code class="highlight"><c- n>emplace</c-><c- p>(</c-><c- n>x</c-><c- p>...)</c-></code> always implemented as <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- p>(</c-><c- n>x</c-><c- p>...))</c-></code>,
there is no longer any need for an English description of <code class="highlight"><c- n>emplace</c-></code>. It is now specified by code only.</p>
   <p>The rewrite of <code class="highlight"><c- n>emplace_hint</c-><c- p>(</c-><c- n>pos</c-><c- p>,</c-> <c- n>x</c-><c- p>...)</c-></code> into <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>pos</c-><c- p>,</c-> <c- n>value_type</c-><c- p>(</c-><c- n>x</c-><c- p>...))</c-></code> is frightening, because of
the very large overload set of <code class="highlight"><c- n>insert</c-></code>; but I think it’s safe: it should always be a perfect match for <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-><c- p>,</c-> <c- n>value_type</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> and never a viable match for any other overload at all.</p>
   <h3 class="heading settled" data-level="7.4" id="insert-ambiguity"><span class="secno">7.4. </span><span class="content">Ambiguity with <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code></span><a class="self-link" href="#insert-ambiguity"></a></h3>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>Address</c-> <c- p>{</c->
  <c- k>const</c-> <c- b>char</c-> <c- o>*</c-><c- n>p_</c-> <c- o>=</c-> <c- n>nullptr</c-><c- p>;</c->
  <c- n>Address</c-><c- p>(</c-><c- k>auto</c-> <c- n>p</c-><c- p>)</c-> <c- o>:</c-> <c- n>p_</c-><c- p>((</c-><c- k>const</c-> <c- b>char</c-><c- o>*</c-><c- p>)</c-><c- o>&amp;*</c-><c- n>p</c-><c- p>)</c-> <c- p>{}</c->
  <c- k>auto</c-> <c- n>operator</c-><c- o>&lt;=></c-><c- p>(</c-><c- k>const</c-> <c- n>Address</c-><c- o>&amp;</c-><c- p>)</c-> <c- k>const</c-> <c- o>=</c-> <c- k>default</c-><c- p>;</c->
<c- p>};</c->
<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>Address</c-><c- o>></c-> <c- n>m</c-><c- p>,</c-> <c- n>n</c-><c- p>;</c->
<c- n>m</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>n</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>n</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
  <c- c1>// Before: Ambiguous with insert(pos, K&amp;&amp;)</c->
  <c- c1>// After: Unambiguously insert(first, last)</c->
</pre>
   <p>We simply need to copy the usual wording "Constraints: For the second overload, <code class="highlight"><c- n>is_convertible_v</c-><c- o>&lt;</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>const_iterator</c-><c- o>></c-></code> and <code class="highlight"><c- n>is_convertible_v</c-><c- o>&lt;</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>iterator</c-><c- o>></c-></code> are both <code class="highlight">false</code>" from <a data-link-type="biblio" href="#biblio-p2363" title="Extending associative containers with the remaining heterogeneous overloads">[P2363]</a> or <a href="https://eel.is/c++draft/flat.map.modifiers#19.4"><code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>try_emplace</c-></code></a>.</p>
   <p>This is a problem only for the sets, where <code class="highlight"><c- n>const_iterator</c-></code> can be convertible to <code class="highlight"><c- n>value_type</c-></code>.
It’s not a problem for the maps, so they don’t need to change.</p>
   <h3 class="heading settled" data-level="7.5" id="multiset-emplace"><span class="secno">7.5. </span><span class="content"><code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>emplace</c-></code> by rotation</span><a class="self-link" href="#multiset-emplace"></a></h3>
<pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- n>class</c-> <c- n>C</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c->
<c- n>using</c-> <c- n>PmrFlatMultiset</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_multiset</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>C</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c-><c- p>;</c->
<c- k>auto</c-> <c- n>fms</c-> <c- o>=</c-> <c- n>PmrFlatMultiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- o>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>fms</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- s>"hello world"</c-><c- p>);</c->
</pre>
   <p>The C++23 status quo is that we "initialize an object <code class="highlight"><c- n>t</c-></code> of type <code class="highlight"><c- n>value_type</c-></code>" with <code class="highlight"><c- s>"hello world"</c-></code>,
and then insert it into <code class="highlight"><c- n>c</c-></code>. The initial construction of <code class="highlight"><c- n>t</c-></code> uses the wrong allocator.</p>
   <p>P2767R1 proposes to simplify the specification of <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>emplace</c-></code> in terms of <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>insert</c-></code>;
but does not propose to change this behavior. We’ll still be constructing a temporary with the wrong
allocator.</p>
   <p>Tim Song has observed that we could specify <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>emplace</c-></code> as follows, instead:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>iterator</c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>);</c->
</pre><p><del>1․ Constraints: <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Args</c-><c- p>...</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> </p><p>2․ Effects: <del>First, initializes an object <code class="highlight"><c- n>t</c-></code> of type <code class="highlight"><c- n>value_type</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...</c-></code>,
then inserts <code class="highlight"><c- n>t</c-></code></del> <ins>Adds an element to <i><code class="highlight"><c- n>c</c-></code></i></ins> as if by: </p><pre class="highlight"><del><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>t</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></del>
<del><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>t</c-><c- p>));</c-></del>
<ins><c- k>auto</c-> <c- n>n</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>t</c-><c- p>,</c-> <c- n>compare</c-><c- p>)</c-> <c- o>-</c-> <c- n>c</c-><c- p>.</c-><c- n>begin</c-><c- p>();</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>emplace_back</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><args><c- p>(</c-><c- n>args</c-><c- p>)...);</c-></args></ins>
<ins><c- n>ranges</c-><c- o>::</c-><c- n>rotate</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>n</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>end</c-><c- p>()</c-> <c- o>-</c-> <c- mi>1</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-></ins>
</pre><p>3․ Returns: An iterator that points to the inserted element. </p></small>
   </blockquote>
   <p>This would ensure that the new object never gets constructed with the wrong allocator.
However, this benefit comes with at least three downsides:</p>
   <ul>
    <li data-md>
     <p>A user-provided random-access container (e.g. one based on a <a href="https://en.wikipedia.org/wiki/Skip_list">skip list</a>) might have a way to
insert in the middle of the container without moving any other elements at all, or moving only O(1)
elements instead of O(n) elements.</p>
    <li data-md>
     <p>Even for <code class="highlight"><c- n>vector</c-></code> it seems more expensive to rotate the elements than to
do the right-shift that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>insert</c-></code> would do. Is the cost worth the benefit?</p>
    <li data-md>
     <p>The proposal applies to <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>emplace</c-></code> but not to <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>emplace</c-></code> (because we don’t want to insert a duplicate and then have to erase it again)
and not to <code class="highlight"><c- n>flat_multimap</c-><c- o>::</c-><c- n>emplace</c-></code> (because we don’t have a container of <code class="highlight"><c- n>pair</c-></code>s
to emplace into, in that case).</p>
   </ul>
   <p>We could mitigate the first two downsides by leaving <code class="highlight"><c- n>emplace</c-></code> alone, and doing the
rotate-based version only for <code class="highlight"><c- n>emplace_hint</c-></code>. There, if the caller gives us an accurate hint,
we won’t need to rotate anything at all; and when we do rotate, it can only be because
the caller gave us an inaccurate hint (i.e. it’s "their fault"). But this would still
suffer the third downside (i.e. inconsistency), and it would be more complicated to teach.
Arthur thinks that it is best <em>not</em> to use <code class="highlight"><c- n>rotate</c-></code> at all. The proposed wording below
does not use <code class="highlight"><c- n>rotate</c-></code>.</p>
   <h3 class="heading settled" data-level="7.6" id="wording-insert-emplace"><span class="secno">7.6. </span><span class="content">Wording</span><a class="self-link" href="#wording-insert-emplace"></a></h3>
   <p class="note" role="note"><span class="marker">Note:</span> This section was updated in R1 following LWG’s preferred direction; see rationale above.
We no longer add <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> to <code class="highlight"><c- n>flat_multiset</c-></code>; that wording has moved to <a href="#heterogeneous-insert-multiset">§ 13 Heterogeneous multiset::insert</a>.</p>
   <p>We don’t need to touch [flat.multimap.modifiers]; in fact it does not currently exist;
because of <a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview]/4</a>:</p>
   <p><small></small></p>
   <blockquote><small> 4․ Except as otherwise noted, operations on <code class="highlight"><c- n>flat_multimap</c-></code> are equivalent to those of <code class="highlight"><c- n>flat_map</c-></code>, 
except that <code class="highlight"><c- n>flat_multimap</c-></code> operations do not remove or replace elements with equal keys.<p></p> </small></blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.map.modifiers], modifiers</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
  <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><args><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></args></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
    <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><args><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></args></ins>

<c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>

<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>P</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>P</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>P</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>P</c-><c- o>&amp;&amp;</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.map.modifiers">[flat.map.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>);</c-></del>
</pre><del>1․ Constraints: <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>key_type</c-><c- p>,</c-> <c- n>mapped_type</c-><c- o>></c-><c- p>,</c-> <c- n>Args</c-><c- p>...</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> <p><del>2․ Effects: Initializes an object <code class="highlight"><c- n>t</c-></code> of type <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>key_type</c-><c- p>,</c-> <c- n>mapped_type</c-><c- o>></c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...</c-></code>;
if the map already contains an element whose key is equivalent to <code class="highlight"><c- n>t</c-><c- p>.</c-><c- n>first</c-></code>, <code class="highlight"><c- o>*</c-><c- k>this</c-></code> is unchanged. Otherwise, equivalent to:</del> </p><pre class="highlight"><del><c- k>auto</c-> <c- n>key_it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>t</c-><c- p>.</c-><c- n>first</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></del>
<del><c- k>auto</c-> <c- n>value_it</c-> <c- o>=</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>distance</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>key_it</c-><c- p>);</c-></del>
<del><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>key_it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>t</c-><c- p>.</c-><c- n>first</c-><c- p>));</c-></del>
<del><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>value_it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>t</c-><c- p>.</c-><c- n>second</c-><c- p>));</c-></del>
</pre> <del>3․ Returns: The <code class="highlight"><c- b>bool</c-></code> component of the returned pair is <code class="highlight">true</code> if and only if the insertion took place,
and the iterator component of the pair points to the element with key equivalent to <code class="highlight"><c- n>t</c-><c- p>.</c-><c- n>first</c-></code>.</del> <pre class="highlight"><ins><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
<ins><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><ins>x․ Effects: If the map already contains an element whose key is equivalent to <code class="highlight"><c- n>x</c-><c- p>.</c-><c- n>first</c-></code>, <code class="highlight"><c- o>*</c-><c- k>this</c-></code> and <code class="highlight"><c- n>x</c-></code> are unchanged. Otherwise, equivalent to:</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>key_it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>x</c-><c- p>.</c-><c- n>first</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- k>auto</c-> <c- n>value_it</c-> <c- o>=</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>distance</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>key_it</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>key_it</c-><c- p>,</c-> <c- n>x</c-><c- p>.</c-><c- n>first</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>value_it</c-><c- p>,</c-> <c- n>x</c-><c- p>.</c-><c- n>second</c-><c- p>);</c-></ins>
</pre><ins>for the first overload and</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>key_it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>x</c-><c- p>.</c-><c- n>first</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- k>auto</c-> <c- n>value_it</c-> <c- o>=</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>distance</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>key_it</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>key_it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>.</c-><c- n>first</c-><c- p>));</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>value_it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>.</c-><c- n>second</c-><c- p>));</c-></ins>
</pre><ins>for the second overload.</ins> <p><ins>3․ Returns: The <code class="highlight"><c- b>bool</c-></code> component of the returned pair is <code class="highlight">true</code> if and only if the insertion took place,
and the iterator component of the pair points to the element with key equivalent to <code class="highlight"><c- n>x</c-><c- p>.</c-><c- n>first</c-></code>.</ins> </p><pre class="highlight"><c- k>template</c-><class p> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>P</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- k>template</c-><class p> <c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>P</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
</class></class></pre><p>4․ Constraints: <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>key_type</c-><c- p>,</c-> <c- n>mapped_type</c-><c- o>></c-><c- p>,</c-> <c- n>P</c-><c- o>></c-></code> is <code class="highlight">true</code>. <ins>For
the second overload, <code class="highlight"><c- n>is_convertible_v</c-><c- o>&lt;</c-><c- n>P</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>const_iterator</c-><c- o>></c-></code> and <code class="highlight"><c- n>is_convertible_v</c-><c- o>&lt;</c-><c- n>P</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>iterator</c-><c- o>></c-></code> are both <code class="highlight">false</code>.</ins></p> <p>5․ Effects: The first form is equivalent to <code class="highlight"><c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>P</c-><c- o>></c-><c- p>(</c-><c- n>x</c-><c- p>));</c-></code>.
The second form is equivalent to <code class="highlight"><c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>P</c-><c- o>></c-><c- p>(</c-><c- n>x</c-><c- p>));</c-></code>.</p> </small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// modifiers</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>iterator</c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
  <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><args><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></args></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
    <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><args><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></args></ins>

<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>

<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>P</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>P</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>P</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>P</c-><c- o>&amp;&amp;</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.multiset.modifiers], modifiers</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>iterator</c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
  <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
    <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></ins>

<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>iterator</c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>);</c-></del>
</pre><p><del>1․ Constraints: <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Args</c-><c- p>...</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> </p><p><del>2․ Effects: First, initializes an object <code class="highlight"><c- n>t</c-></code> of type <code class="highlight"><c- n>value_type</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...</c-></code>,
then inserts <code class="highlight"><c- n>t</c-></code> as if by:</del> </p><pre class="highlight"><del><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>t</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></del>
<del><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>t</c-><c- p>));</c-></del>
</pre><p><del>3․ Returns: An iterator that points to the inserted element.</del> </p><pre class="highlight"><ins><c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
<ins><c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><ins>x․ Effects: Inserts a new element as if by:</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><ins>for the first overload or</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-></ins>
</pre><ins>for the second overload.</ins> <p><ins>x․ Returns: An iterator that points to the inserted element.</ins> </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.set.modifiers], modifiers</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
  <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
    <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></ins>

<c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>hint</c-><c- p>,</c-> <c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.modifiers">[flat.set.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><ins><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
<ins><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><ins>x․ Effects: If the set already contains an element equivalent to <code class="highlight"><c- n>x</c-></code>, <code class="highlight"><c- o>*</c-><c- k>this</c-></code> and <code class="highlight"><c- n>x</c-></code> are unchanged.
Otherwise, inserts a new element as if by:</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><ins>for the first overload or</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-></ins>
</pre><ins>for the second overload.</ins> <p><ins>x․ Returns: The <code class="highlight"><c- b>bool</c-></code> component of the returned pair is <code class="highlight">true</code> if and only if the insertion took place.
The returned iterator points to the element equivalent to <code class="highlight"><c- n>x</c-></code>.</ins> </p><pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>hint</c-><c- p>,</c-> <c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
</pre><p>1․ Constraints: The <em>qualified-id</em> <code class="highlight"><c- n>Compare</c-><c- o>::</c-><c- n>is_transparent</c-></code> is valid and denotes a type. <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>value_type</c-><c- p>,</c-> <c- n>K</c-><c- o>></c-></code> is <code class="highlight">true</code>. <ins>For
the second overload, <code class="highlight"><c- n>is_convertible_v</c-><c- o>&lt;</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>const_iterator</c-><c- o>></c-></code> and <code class="highlight"><c- n>is_convertible_v</c-><c- o>&lt;</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>iterator</c-><c- o>></c-></code> are both <code class="highlight">false</code>.</ins></p> <p>2․ Preconditions: The conversion from <code class="highlight"><c- n>x</c-></code> into <code class="highlight"><c- n>value_type</c-></code> constructs an object <code class="highlight"><c- n>u</c-></code><del>,</del> for which <code class="highlight"><c- n>find</c-><c- p>(</c-><c- n>x</c-><c- p>)</c-> <c- o>==</c-> <c- n>find</c-><c- p>(</c-><c- n>u</c-><c- p>)</c-></code> is <code class="highlight">true</code>.</p> <p>3․ Effects: If the set already contains an element equivalent to <code class="highlight"><c- n>x</c-></code>, <code class="highlight"><c- o>*</c-><c- k>this</c-></code> and <code class="highlight"><c- n>x</c-></code> are unchanged. Otherwise, inserts a new element as if
by <code class="highlight"><c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>K</c-><c- o>></c-><c- p>(</c-><c- n>x</c-><c- p>))</c-></code>.</p> <p>4․ Returns: In the first overload, the <code class="highlight"><c- b>bool</c-></code> component of the returned pair is <code class="highlight">true</code> if and only if the insertion took place.
The returned iterator points to the element <del>whose key is</del> equivalent to <code class="highlight"><c- n>x</c-></code>.</p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="8" id="insert-range-sorted-unique"><span class="secno">8. </span><span class="content"><code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code></span><a class="self-link" href="#insert-range-sorted-unique"></a></h2>
   <p>The multi-element insertion API consists of these overloads:</p>
<pre class="language-c++ highlight"><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c->
<c- n>insert</c-><c- p>(</c-><c- n>il</c-><c- p>);</c->
<c- n>insert_range</c-><c- p>(</c-><c- n>rg</c-><c- p>);</c->

<c- n>insert</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c->
<c- n>insert</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>il</c-><c- p>);</c->
</pre>
   <p>An overload of <code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code> is conspicuously missing.</p>
<pre class="language-c++ highlight"><c- k>auto</c-> <c- n>rg</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>iota</c-><c- p>(</c-><c- mi>0</c-><c- p>,</c-> <c- mi>100</c-><c- p>)</c-> <c- o>|</c-> <c- n>std</c-><c- o>::</c-><c- n>take_while</c-><c- p>(</c-><c- n>lessThan50</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- o>!</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>common_range</c-><c- o>&lt;</c-><c- n>decltype</c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-><c- o>></c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>is_sorted</c-><c- p>(</c-><c- n>rg</c-><c- p>));</c->

<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>fs</c-><c- p>;</c->

<c- n>fs</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>rg</c-><c- p>);</c->
  <c- c1>// OK, but unnecessarily re-sorts the input</c->

<c- k>if</c-> <c- p>(</c-><c- k>auto</c-> <c- n>cv</c-> <c- o>=</c-> <c- n>rg</c-> <c- o>|</c-> <c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>common</c-><c- p>;</c-> true<c- p>)</c-> <c- p>{</c->
  <c- n>fs</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>cv</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>cv</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
    <c- c1>// OK, doesn’t re-sort, but arcane</c->
<c- p>}</c->

<c- n>fs</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>rg</c-><c- p>);</c->
  <c- c1>// Before: Ill-formed</c->
  <c- c1>// After: OK</c->
</pre>
   <p>Now, we’re also conspicuously missing a constructor overload <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>from_range</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code>.
There we have a real API-design conflict: Which of <code class="highlight"><c- n>sorted_unique</c-></code> and <code class="highlight"><c- n>from_range</c-></code> should come first?
This is enough of a reason to simply give up on that constructor. But <code class="highlight"><c- n>insert_range</c-></code> has no such API-design
problem. We can easily add this overload.</p>
   <h3 class="heading settled" data-level="8.1" id="wording-insert-range-sorted-unique"><span class="secno">8.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-insert-range-sorted-unique"></a></h3>
   <p>Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p>Add a new entry to <a href="https://eel.is/c++draft/flat.map.modifiers">[flat.map.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
</pre><p>7․ Effects: Equivalent to <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>. </p><p>8․ Complexity: Linear. </p><p></p><pre class="highlight"><ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
</pre> <p><ins>x․ Effects: Equivalent to <code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>))</c-></code>.</ins> </p><p><ins>x․ Complexity: Linear in <i>N</i>, where <i>N</i> is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> after the operation.</ins> </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p>Add a new entry to <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
</pre><p>7․ Effects: Equivalent to <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>. </p><p>8․ Complexity: Linear. </p><pre class="highlight"><ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
</pre> <p><ins>x․ Effects: Equivalent to <code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>))</c-></code>.</ins> </p><p><ins>x․ Complexity: Linear in N, where N is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> after the operation.</ins> </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p>Add a new entry to <a href="https://eel.is/c++draft/flat.set.modifiers">[flat.set.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
</pre><p>8․ Effects: Equivalent to <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>. </p><p>9․ Complexity: Linear. </p><pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
</pre><p>10․ Effects: Adds elements to <i><code class="highlight"><c- n>c</c-></code></i> as if by: </p><pre class="highlight"><c- k>for</c-> <c- p>(</c-><c- k>const</c-> <c- k>auto</c-><c- o>&amp;</c-> <c- n>e</c-> <c- o>:</c-> <c- n>rg</c-><c- p>)</c-> <c- p>{</c->
  <c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>e</c-><c- p>);</c->
<c- p>}</c->
</pre><p>Then, sorts the range of newly inserted elements with respect to <i><code class="highlight"><c- n>compare</c-></code></i>;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases all but the first element from each group of consecutive equivalent elements.</p> <p>11․ Complexity: <i>N</i> + <i>M</i> log <i>M</i>, where <i>N</i> is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> before the operation and <i>M</i> is <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>distance</c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-></code>. </p><p>12․ Remarks: Since this operation performs an in-place merge, it may allocate memory. </p><pre class="highlight"><ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
</pre><p><ins>x․ Effects: Equivalent to <code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>))</c-></code>.</ins> </p><p><ins>x․ Complexity: Linear in <i>N</i>, where <i>N</i> is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> after the operation.</ins> </p><p><ins>x․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</ins> </p></small>
   </blockquote>
   <h2 class="heading settled" data-level="9" id="sorting-complexity"><span class="secno">9. </span><span class="content">Complexity clauses of container constructors</span><a class="self-link" href="#sorting-complexity"></a></h2>
   <p>(This whole section would be mooted by <a href="#deceptive-remove">§ 14.2 Remove the container constructors; make replace sort by default</a>.)</p>
   <p>Most operations that require sorting come in <code class="highlight"><c- n>sorted_unique</c-></code> and non-<code class="highlight"><c- n>sorted_unique</c-></code> flavors;
the <code class="highlight"><c- n>sorted_unique</c-></code> flavor is rightly specified not to sort, which means it can be O(N)
instead of O(N + M log M). That’s fine. But some non-<code class="highlight"><c- n>sorted_unique</c-></code> constructors have
Complexity clauses that mandate O(N) performance on input that <em>happens</em> to be sorted
at runtime. The vendor has three ways to deal with this:</p>
   <ul>
    <li data-md>
     <p>Guarantee that <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>sort</c-></code> (or <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>stable_sort</c-></code> if <a href="#stable-sorting">§ 12.1 Stable sorting in insert</a> is adopted) will
always run in O(N) time on sorted input. This is not currently mandated by <a href="https://eel.is/c++draft/alg.sort#sort-5">[alg.sort]</a>,
so no vendor is likely to know off the top of their heads that they really guarantee this
for all possible sorted inputs. libc++ certainly doesn’t know this for sure.</p>
    <li data-md>
     <p>Add a linear-time pass on the front, e.g. <code class="highlight"><c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>std</c-><c- o>::</c-><c- n>is_sorted</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>))</c-> <c- n>std</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>.
This wastes O(N) cycles in every case: it might improve the asymptotic performance in the
rare case that the input happens to be sorted at runtime, but only at the cost of slowing down
the expected case where the input is not sorted. libc++ doesn’t want to slow down the
average caller.</p>
    <li data-md>
     <p>Ignore the spec’s Complexity requirement. libc++ also doesn’t want to do this.</p>
   </ul>
   <p>Louis Dionne would be happy with a resolution that requires all vendors to implement this
optimization in <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>sort</c-></code> itself, for ranges that happen to be sorted. I.e., change <a href="https://eel.is/c++draft/alg.sort#sort-5">[sort]/5</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> 5․ Complexity: Let N be <code class="highlight"><c- n>last</c-> <c- o>-</c-> <c- n>first</c-></code>. <ins>If the input is already sorted with respect to <code class="highlight"><c- n>comp</c-></code> and <code class="highlight"><c- n>proj</c-></code>, O(N) comparisons and projections. Otherwise,</ins> O(N log N) comparisons and projections. <ins>In either case, twice as many projections as comparisons.</ins><p></p> </small></blockquote>
   <p>and change <a href="https://eel.is/c++draft/alg.sort#stable.sort-5">[stable.sort]/5</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> 5․ Complexity: Let N be <code class="highlight"><c- n>last</c-> <c- o>-</c-> <c- n>first</c-></code>. <ins>If the input is already sorted with respect to <code class="highlight"><c- n>comp</c-></code> and <code class="highlight"><c- n>proj</c-></code>, O(N) comparisons.</ins> If enough extra memory is available, <ins>O(</ins>N log(N)<ins>)</ins> comparisons.
Otherwise, <del>at most</del> <ins>O(</ins>N log<sup>2</sup>(N)<ins>)</ins> comparisons.
In <del>either</del> <ins>any</ins> case, twice as many projections as <del>the number of</del> comparisons.<p></p> </small></blockquote>
   <p>If we changed [alg.sort], then we’d get [flat.foo]'s unusual complexity guarantees for free, and
the following changes in [flat.foo] would be no-ops, just a bit of editorial cleanup.
However, Louis and Arthur would prefer to leave [alg.sort] alone for now,
making the following changes in [flat.foo] significant and non-editorial.</p>
   <h3 class="heading settled" data-level="9.1" id="wording-sorting-complexity"><span class="secno">9.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-sorting-complexity"></a></h3>
   <p>Change <a href="https://eel.is/c++draft/flat.map.cons">[flat.map.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
         <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre><p>1․ Effects: Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>,
and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>; sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>; and
finally erases the duplicate elements as if by:</p> <pre class="highlight"><c- k>auto</c-> <c- n>zv</c-> <c- o>=</c-> <c- n>views</c-><c- o>::</c-><c- n>zip</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>);</c->
<c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>unique</c-><c- p>(</c-><c- n>zv</c-><c- p>,</c-> <c- n>key_equiv</c-><c- p>(</c-><c- n>compare</c-><c- p>)).</c-><c- n>begin</c-><c- p>();</c->
<c- k>auto</c-> <c- n>dist</c-> <c- o>=</c-> <c- n>distance</c-><c- p>(</c-><c- n>zv</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>it</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
<c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
</pre> <p>2․ Complexity: <del>Linear in N if the container arguments are already sorted with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code> and otherwise N log N, where N is the value of <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> <ins>Same as <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>ranges</c-><c- o>::</c-><c- n>zip</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>),</c-> <c- n>value_comp</c-><c- p>())</c-></code>.</ins> </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.cons">[flat.multimap.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
              <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre><p>1․ Effects: Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>,
and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>; sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>.</p> <p>2․ Complexity: <del>Linear in N if the container arguments are already sorted with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code> and otherwise N log N, where N is the value of <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> <ins>Same as <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>ranges</c-><c- o>::</c-><c- n>zip</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>),</c-> <c- n>value_comp</c-><c- p>())</c-></code>.</ins> </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.cons">[flat.multiset.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre> <p>1․ Effects: Initializes <i><code class="highlight"><c- n>c</c-></code></i> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <i><code class="highlight"><c- n>compare</c-></code></i> with <code class="highlight"><c- n>comp</c-></code><del>, and</del> <ins>;</ins> sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <i><code class="highlight"><c- n>compare</c-></code></i>.</p> <p>2․ Complexity: <del>Linear in N if <code class="highlight"><c- n>cont</c-></code> is sorted with respect to <i><code class="highlight"><c- n>compare</c-></code></i> and otherwise N log N, where N is the value of <code class="highlight"><c- n>cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> <ins>Same as <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>compare</c-><c- p>)</c-></code>.</ins></p> </small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.cons">[flat.set.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre> <p>1․ Effects: Initializes <i><code class="highlight"><c- n>c</c-></code></i> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <i><code class="highlight"><c- n>compare</c-></code></i> with <code class="highlight"><c- n>comp</c-></code><del>,</del> <ins>;</ins> sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <i><code class="highlight"><c- n>compare</c-></code></i><del>,</del> <ins>;</ins> and finally erases all but the first element from each group of consecutive equivalent elements.</p> <p>2․ Complexity: <del>Linear in N if <code class="highlight"><c- n>cont</c-></code> is sorted with respect to <i><code class="highlight"><c- n>compare</c-></code></i> and otherwise N log N, where N is the value of <code class="highlight"><c- n>cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> <ins>Same as <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>compare</c-><c- p>)</c-></code>.</ins></p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="10" id="replace-by-value"><span class="secno">10. </span><span class="content"><code class="highlight"><c- n>replace</c-></code> should take by value</span><a class="self-link" href="#replace-by-value"></a></h2>
   <p>The current specification for <code class="highlight"><c- n>replace</c-></code> takes the new container(s) by rvalue reference,
which means you can’t just pass in a container the way you can with the <code class="highlight"><c- n>key_cont</c-></code> constructor;
instead, you have to manually <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-></code> the container.</p>
   <p>This might have been originally intended as a guard against accidental expensive copying of containers.
But C++ doesn’t use this (explicit-pass-by-rvalue-reference) pattern anywhere else; and it’s
inconsistent with the specification of the <code class="highlight"><c- n>key_cont</c-></code> constructors, which do take by value
and happily allow passing in lvalue containers by copy.</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>v</c-> <c- o>=</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>};</c->
<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>fs</c-><c- p>;</c->

<c- n>fs</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- p>(</c-><c- n>v</c-><c- p>);</c-> <c- c1>// OK</c->
<c- n>fs</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- p>(</c-><c- n>v</c-><c- p>));</c-> <c- c1>// OK</c->

<c- n>fs</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>v</c-><c- p>);</c->
  <c- c1>// Before: Ill-formed</c->
  <c- c1>// After: OK</c->
</pre>
   <p>Taking by value and move-constructing into place is almost always just as performant as
taking by rvalue-reference and move-constructing into place. Caveat: some containers
are expensive to move-construct. <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-></code> is <em>not</em> such a container.
Boost <code class="highlight"><c- n>static_vector</c-></code> is. But we shouldn’t cater for such types, especially not at
the cost of API consistency.</p>
<pre class="highlight"><c- n>boost</c-><c- o>::</c-><c- n>container</c-><c- o>::</c-><c- n>static_vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- mi>100</c-><c- o>></c-> <c- n>v</c-><c- p>;</c->
<c- k>auto</c-> <c- n>fs</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>v</c-><c- p>));</c-> <c- c1>// OK, does 2 expensive moves</c->
<c- n>fs</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>v</c-><c- p>));</c->
  <c- c1>// Before: OK, does 1 expensive move</c->
  <c- c1>// After: OK, does 2 expensive moves</c->
<c- n>fs</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>v</c-><c- p>);</c->
  <c- c1>// Before: Ill-formed</c->
  <c- c1>// After: OK, does 1 expensive copy and 1 expensive move</c->
</pre>
   <h3 class="heading settled" data-level="10.1" id="wording-replace-by-value"><span class="secno">10.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-replace-by-value"></a></h3>
   <p>Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>containers</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
<c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>key_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>mapped_cont</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.map.modifiers#lib:replace,flat_map">[flat.map.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>key_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>mapped_cont</c-><c- p>);</c->
</pre> <p>36․ Preconditions: <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-> <c- o>==</c-> <c- n>mapped_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> is <code class="highlight">true</code>, the elements of <code class="highlight"><c- n>key_cont</c-></code> are sorted with respect to <code class="highlight"><c- n>compare</c-></code>,
and <code class="highlight"><c- n>key_cont</c-></code> contains no equal elements.</p> <p>37․ Effects: Equivalent to:</p> <pre class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>values</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>containers</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
<c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>key_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>mapped_cont</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>container_type</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
<c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.modifiers#lib:replace,flat_multiset">[flat.multiset.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>cont</c-><c- p>);</c->
</pre> <p>12․ Preconditions: The elements of <code class="highlight"><c- n>cont</c-></code> are sorted with respect to <code class="highlight"><c- n>compare</c-></code>.</p> <p>13․ Effects: Equivalent to: <code class="highlight"><c- n>c</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>);</c-></code></p> </small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>container_type</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
<c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.modifiers#lib:replace,flat_set">[flat.set.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>cont</c-><c- p>);</c->
</pre> <p>12․ Preconditions: The elements of <code class="highlight"><c- n>cont</c-></code> are sorted with respect to <code class="highlight"><c- n>compare</c-></code>, and <code class="highlight"><c- n>cont</c-></code> contains no equal elements.</p> <p>13․ Effects: Equivalent to: <code class="highlight"><c- n>c</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>);</c-></code></p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="11" id="keys-method"><span class="secno">11. </span><span class="content">Add <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>keys</c-><c- p>()</c-></code></span><a class="self-link" href="#keys-method"></a></h2>
   <p><code class="highlight"><c- n>flat_map</c-></code> and <code class="highlight"><c- n>flat_multimap</c-></code> both provide <code class="highlight"><c- n>keys</c-><c- p>()</c-></code> and <code class="highlight"><c- n>values</c-><c- p>()</c-></code> getters:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><i><c- c1>// observers</c-></i>
<c- n>key_compare</c-> <c- nf>key_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->
<c- n>value_compare</c-> <c- nf>value_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->

<c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- nf>keys</c-><c- p>()</c-> <c- k>const</c-> <c- k>noexcept</c->      <c- p>{</c-> <c- k>return</c-> <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>;</c-> <c- p>}</c->
<c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- nf>values</c-><c- p>()</c-> <c- k>const</c-> <c- k>noexcept</c-> <c- p>{</c-> <c- k>return</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>;</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p><code class="highlight"><c- n>flat_set</c-></code> and <code class="highlight"><c- n>flat_multiset</c-></code> do not:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><i><c- c1>// observers</c-></i>
<c- n>key_compare</c-> <c- nf>key_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->
<c- n>value_compare</c-> <c- nf>value_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->
</pre></small>
   </blockquote>
   <p>libc++ has found that <code class="highlight"><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- p>.</c-><c- n>values</c-></code> are helpful in unit tests.
The <code class="highlight"><c- p>.</c-><c- n>extract</c-></code> method is a poor replacement.</p>
<pre class="language-c++ highlight"><c- k>auto</c-> <c- n>ks</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>A</c-><c- o>></c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>},</c-> <c- n>A</c-><c- p>(</c-><c- mi>1</c-><c- p>));</c->
<c- k>auto</c-> <c- n>vs</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>A</c-><c- o>></c-><c- p>({</c-><c- mi>4</c-><c- p>,</c-><c- mi>5</c-><c- p>,</c-><c- mi>6</c-><c- p>},</c-> <c- n>A</c-><c- p>(</c-><c- mi>2</c-><c- p>));</c->
<c- k>auto</c-> <c- n>m</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_map</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>ks</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>vs</c-><c- p>));</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>.</c-><c- n>keys</c-><c- p>().</c-><c- n>get_allocator</c-><c- p>()</c-> <c- o>==</c-> <c- n>A</c-><c- p>(</c-><c- mi>1</c-><c- p>));</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>.</c-><c- n>values</c-><c- p>().</c-><c- n>get_allocator</c-><c- p>()</c-> <c- o>==</c-> <c- n>A</c-><c- p>(</c-><c- mi>2</c-><c- p>));</c->
  <c- c1>// convenient</c->

<c- k>auto</c-> <c- n>ks</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>A</c-><c- o>></c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>},</c-> <c- n>A</c-><c- p>(</c-><c- mi>1</c-><c- p>));</c->
<c- k>auto</c-> <c- n>s</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>ks</c-><c- p>));</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>s</c-><c- p>).</c-><c- n>extract</c-><c- p>().</c-><c- n>get_allocator</c-><c- p>()</c-> <c- o>==</c-> <c- n>A</c-><c- p>(</c-><c- mi>1</c-><c- p>));</c->
  <c- c1>// awkward, and modifies the value of s</c->
</pre>
   <p>For a const <code class="highlight"><c- n>flat_set</c-></code>, there’s literally no way to get at the container
and query its properties, such as capacity, allocator, or even size
(which is important for unit tests, if not for real programming).</p>
<pre class="language-c++ highlight"><c- n>using</c-> <c- n>S</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;></c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>A</c-><c- o>>></c-><c- p>;</c->
<c- k>const</c-> <c- n>S</c-> <c- n>s</c-> <c- o>=</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>};</c->
<c- n>assert</c-><c- p>(</c-><c- n>s</c-><c- p>.</c-><c- n>keys</c-><c- p>().</c-><c- n>size</c-><c- p>()</c-> <c- o>==</c-> <c- mi>3</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>s</c-><c- p>.</c-><c- n>keys</c-><c- p>().</c-><c- n>capacity</c-><c- p>()</c-> <c- o>>=</c-> <c- mi>3</c-><c- p>);</c->
  <c- c1>// Before: Impossible to retrieve this information</c->
  <c- c1>// After: OK</c->
</pre>
   <p>Therefore we suggest adding a getter for the <code class="highlight"><c- p>.</c-><c- n>keys</c-></code> of a set, just
like we already have for the flat map types.</p>
   <p>Notice that <code class="highlight"><c- n>flat_map</c-></code>’s <code class="highlight"><c- p>.</c-><c- n>values</c-><c- p>()</c-></code> getter returns a container of <code class="highlight"><c- n>mapped_type</c-></code>,
not a container of <code class="highlight"><c- n>value_type</c-></code>. <code class="highlight"><c- n>flat_set</c-></code> doesn’t have a <code class="highlight"><c- n>mapped_type</c-></code>;
therefore it shouldn’t have <code class="highlight"><c- p>.</c-><c- n>values</c-><c- p>()</c-></code> either.</p>
   <h3 class="heading settled" data-level="11.1" id="wording-keys-method"><span class="secno">11.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-keys-method"></a></h3>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><i><c- c1>// observers</c-></i>
<c- n>key_compare</c-> <c- nf>key_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->
<c- n>value_compare</c-> <c- nf>value_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->

<ins><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- nf>keys</c-><c- p>()</c-> <c- k>const</c-> <c- k>noexcept</c-> <c- p>{</c-> <c- k>return</c-> <i><c- n>c</c-></i><c- p>;</c-> <c- p>}</c-></ins>
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><i><c- c1>// observers</c-></i>
<c- n>key_compare</c-> <c- nf>key_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->
<c- n>value_compare</c-> <c- nf>value_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->

<ins><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- nf>keys</c-><c- p>()</c-> <c- k>const</c-> <c- k>noexcept</c-> <c- p>{</c-> <c- k>return</c-> <i><c- n>c</c-></i><c- p>;</c-> <c- p>}</c-></ins>
</pre></small>
   </blockquote>
   <h2 class="heading settled" data-level="12" id="issues-for-discussion"><span class="secno">12. </span><span class="content">Issues for discussion</span><a class="self-link" href="#issues-for-discussion"></a></h2>
   <p>The following subsections describe known issues with the flat containers where we
don’t (yet) strongly propose a change. In some cases Louis Dionne asks for further
clarification and/or changes to the wording. In some cases we’re just reporting
implementation experience. In some cases it seems like a change is warranted, but
it’s confusing enough that we don’t have a good wording patch yet.</p>
   <h3 class="heading settled" data-level="12.1" id="stable-sorting"><span class="secno">12.1. </span><span class="content">Stable sorting in <code class="highlight"><c- n>insert</c-></code></span><a class="self-link" href="#stable-sorting"></a></h3>
   <p>For the tree-based associative containers, <a href="https://eel.is/c++draft/associative.reqmts#general-68.sentence-2">[associative.reqmts.general]</a> defines
the single-element <code class="highlight"><c- n>foo</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>val</c-><c- p>)</c-></code> to insert in a well-defined order; <a href="https://eel.is/c++draft/associative.reqmts.general#lib:insert,ordered_associative_containers___">[associative.reqmts.general]</a> defines
the multi-element <code class="highlight"><c- n>foo</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code> to insert in an unspecified order.
Nevertheless, in practice, all three vendors implement the latter as a simple
loop over the former, so we have this de-facto behavior portable everywhere:</p>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>Apathy</c-> <c- p>{</c-> <c- b>bool</c-> <c- nf>operator</c-><c- p>()(</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- p>)</c-> <c- k>const</c-> <c- p>{</c-> <c- k>return</c-> false<c- p>;</c-> <c- p>}</c-> <c- p>};</c->
<c- b>int</c-> <c- n>a</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>,</c-><c- mi>4</c-><c- p>,</c-><c- mi>5</c-><c- p>};</c->
<c- n>std</c-><c- o>::</c-><c- n>multiset</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>Apathy</c-><c- o>></c-> <c- n>s</c-><c- p>;</c->

<c- c1>// #1</c->
<c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>i</c-> <c- o>:</c-> <c- n>a</c-><c- p>)</c-> <c- n>s</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>i</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->

<c- c1>// #2</c->
<c- n>s</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>a</c-><c- p>,</c-> <c- n>a</c-><c- o>+</c-><c- mi>5</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>is_permutation</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de facto portable</c->

<c- c1>// #3</c->
<c- n>s</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>is_permutation</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de facto portable</c->
</pre>
   <p>Similarly with equivalent keys in a <code class="highlight"><c- n>map</c-></code> or <code class="highlight"><c- n>multimap</c-></code>:</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-> <c- n>a</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{{</c-><c- mi>1</c-><c- p>,</c-><c- mi>1</c-><c- p>},{</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>},{</c-><c- mi>1</c-><c- p>,</c-><c- mi>3</c-><c- p>}};</c->
<c- n>std</c-><c- o>::</c-><c- n>map</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- p>,</c-> <c- n>Apathy</c-><c- o>></c-> <c- n>m</c-><c- p>;</c->

<c- c1>// #1</c->
<c- k>for</c-> <c- p>(</c-><c- k>auto</c-> <c- n>kv</c-> <c- o>:</c-> <c- n>a</c-><c- p>)</c-> <c- n>m</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>kv</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>==</c-> <c- mi>1</c-><c- p>);</c-> <c- c1>// de jure</c->

<c- c1>// #2</c->
<c- n>m</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>a</c-><c- p>,</c-> <c- n>a</c-><c- o>+</c-><c- mi>5</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>></c-> <c- mi>0</c-><c- p>);</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>==</c-> <c- mi>1</c-><c- p>);</c-> <c- c1>// de facto portable</c->

<c- c1>// #3</c->
<c- n>m</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>></c-> <c- mi>0</c-><c- p>);</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>==</c-> <c- mi>1</c-><c- p>);</c-> <c- c1>// de facto portable</c->
</pre>
   <p>Arthur’s libc++ implementation leans into the idea that <code class="highlight"><c- n>flat_foo</c-></code> is a drop-in replacement for <code class="highlight"><c- n>foo</c-></code>,
and ensures that <code class="highlight"><c- n>flat_foo</c-><c- o>::</c-><c- n>insert</c-><c- p>{,</c-><c- n>_range</c-><c- p>}</c-></code> will behave exactly like <code class="highlight"><c- n>foo</c-><c- o>::</c-><c- n>insert</c-><c- p>{,</c-><c- n>_range</c-><c- p>}</c-></code>.</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>flat_multiset</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>Apathy</c-><c- o>></c-> <c- n>fs</c-><c- p>;</c->

<c- c1>// #1</c->
<c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>i</c-> <c- o>:</c-> <c- n>a</c-><c- p>)</c-> <c- n>fs</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>i</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->

<c- c1>// #2</c->
<c- n>fs</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>a</c-><c- p>,</c-> <c- n>a</c-><c- o>+</c-><c- mi>5</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>is_permutation</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// libc++</c->

<c- c1>// #3</c->
<c- n>fs</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>is_permutation</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// libc++</c->
</pre>
   <p><code class="highlight"><c- n>flat_foo</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code> is defined by <a href="https://eel.is/c++draft/flat.set.modifiers#lib:insert,flatset">[flat.set.modifiers]</a> to insert in order and then "sort the range." The vendor will be tempted to use <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>sort</c-></code>,
which in practice is not stable. Arthur’s implementation uses <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>stable_sort</c-></code> specifically
to ensure that <code class="highlight"><c- n>fs</c-></code> will give the same results as <code class="highlight"><c- n>s</c-></code> for all multi-element insertions.</p>
   <p>Louis Dionne worries that by providing this additional de-facto guarantee, libc++ might be creating
a "portability trap" — the programmer writes obvious code that works perfectly on libc++, and then when
the programmer migrates to libstdc++ or Microsoft STL, they suddenly find that their code no longer works.</p>
   <p>Therefore Louis asks whether LWG could <em>specifically require</em> that newly inserted elements be sorted stably, e.g.</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
</pre> <p>5․ Effects: Adds elements to <code class="highlight"><c- n>c</c-></code> as if by:</p> <pre class="highlight"><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c->
</pre><p>Then, <ins>stably</ins> sorts the range of newly inserted elements with respect to <code class="highlight"><c- n>compare</c-></code>;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases all but the first element from each group of consecutive equivalent elements.</p> <p>6․ Complexity: N + M log M, where N is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> before the operation and M is <code class="highlight"><c- n>distance</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>.</p> <p>7․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</p> </small>
   </blockquote>
   <p>This operation already requires an in-place merge, which allocates memory,
so requiring it to also do a stable sort — which allocates memory — might not be considered such a big deal.</p>
   <p>The alternative here would be for libc++ to lean into the idea that <code class="highlight"><c- n>multiset</c-><c- o>::</c-><c- n>insert_range</c-></code> is supposed to
leave the order of equivalent elements unspecified, and instrument it under libc++'s existing <code class="highlight"><c- n>_LIBCPP_DEBUG_RANDOMIZE_UNSPECIFIED_STABILITY</c-></code> flag (currently used only for <code class="highlight"><c- n>sort</c-></code>, <code class="highlight"><c- n>nth_element</c-></code>, and <code class="highlight"><c- n>partial_sort</c-></code>).
This would preserve the symmetry between <code class="highlight"><c- n>multiset</c-></code> and <code class="highlight"><c- n>flat_multiset</c-></code>, by making both of them de facto
randomized order (at least in debug mode).</p>
   <h3 class="heading settled" data-level="12.2" id="deceptive-redirect"><span class="secno">12.2. </span><span class="content">Non-explicit container constructor</span><a class="self-link" href="#deceptive-redirect"></a></h3>
   <p class="note" role="note"><span class="marker">Note:</span> This section of P2767R0 has moved in P2767R1 to <a href="#deceptive">§ 14 Non-explicit constructor from two containers</a>.</p>
   <h3 class="heading settled" data-level="12.3" id="complexity-equal-range"><span class="secno">12.3. </span><span class="content">Complexity of <code class="highlight"><c- n>equal_range</c-></code></span><a class="self-link" href="#complexity-equal-range"></a></h3>
   <p><a href="https://eel.is/c++draft/associative.reqmts.general#171">[associative.reqmts.general]/171 and /174</a> define the complexity of <code class="highlight"><c- n>b</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- n>k</c-><c- p>)</c-></code> and <code class="highlight"><c- n>a_tran</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- n>ke</c-><c- p>)</c-></code> as "Logarithmic."
This means that we have the following required complexities, for both <code class="highlight"><c- n>foo</c-></code> and <code class="highlight"><c- n>flat_foo</c-></code>:</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>s</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>multiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>ms</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>></c-> <c- n>st</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>multiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>></c-> <c- n>mst</c-><c- p>;</c->

<c- n>s</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- n>s</c-><c- p>);</c->
  <c- c1>// 171: lower_bound, lower_bound+1; (1 + lg N) operations total</c->
<c- n>ms</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- n>s</c-><c- p>);</c->
  <c- c1>// 171: lower_bound, upper_bound; (2 lg N) operations total</c->
<c- n>st</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- p>);</c->
  <c- c1>// 174: lower_bound, upper_bound; (2 lg N) operations total</c->
<c- n>mst</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- p>);</c->
  <c- c1>// 174: lower_bound, upper_bound; (2 lg N) operations total</c->
</pre>
   <p>For <code class="highlight"><c- n>st</c-><c- p>.</c-><c- n>equal_range</c-></code>, <a href="https://eel.is/c++draft/associative.reqmts.general#7.22">[associative.reqmts.general]/7.22</a> forces us to consider the possibility that <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>::</c-><c- k>operator</c-><c- p>()(</c-><c- n>key_type</c-><c- p>,</c-> <c- k>const</c-> <c- b>char</c-><c- o>*</c-><c- p>)</c-></code> is a less granular equivalence relation than <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>::</c-><c- k>operator</c-><c- p>()(</c-><c- n>key_type</c-><c- p>,</c-> <c- n>key_type</c-><c- p>)</c-></code>; i.e., even though
this is a <code class="highlight"><c- n>set</c-></code>, it might still contain "duplicates" from the point of view of the heterogeneous comparator.
It would be efficient in practice to find <code class="highlight"><c- n>lower_bound</c-><c- p>(</c-><c- s>"abc"</c-><c- p>)</c-></code> in lg N time and then step forward linearly
until we find an element not equal to <code class="highlight"><c- s>"abc"</c-></code> — the expected number of duplicates for the average real-world workload
is small. But the number of duplicates <em>theoretically</em> could be O(N); so we’re not allowed to do this
(at least not without an arbitrary cap, e.g. if we don’t find the end of the range in 10 probes then fall back
to <code class="highlight"><c- n>upper_bound</c-></code> — bookkeeping which would again unnecessarily slow down the average case).</p>
   <p>Consider a working programmer who writes</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>s</c-><c- p>;</c->
<c- n>s</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- p>);</c->
  <c- c1>// lower_bound, lower_bound+1; (1 + lg N) operations total</c->
</pre>
   <p>and then switches to a heterogeneous comparator in an effort to "speed up" the code
by avoiding the conversion to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>string</c-></code>:</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>></c-> <c- n>st</c-><c- p>;</c->
<c- n>st</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- p>);</c->
  <c- c1>// lower_bound, upper_bound; (2 lg N) operations total, cache-unfriendly</c->
</pre>
   <p>libc++ would like to see vendors given a little more freedom to experiment here.</p>
   <p>The proposed wording below doesn’t require any vendor to change their implementation,
since an existing implementation in O(log N) certainly also satisfies O(M + log N).</p>
   <h4 class="heading settled" data-level="12.3.1" id="wording-complexity-equal-range"><span class="secno">12.3.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-complexity-equal-range"></a></h4>
   <p>Change <a href="https://eel.is/c++draft/associative.reqmts.general#171">[associative.reqmts.general]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>a_tran</c-><c- p>.</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>ku</c-><c- p>)</c->
</pre> <p>166․ Result: <code class="highlight"><c- n>iterator</c-></code>; <code class="highlight"><c- n>const_iterator</c-></code> for constant <code class="highlight"><c- n>a_tran</c-></code>.</p> <p>167․ Returns: An iterator pointing to the first element with key <code class="highlight"><c- n>r</c-></code> such that <code class="highlight"><c- n>c</c-><c- p>(</c-><c- n>ku</c-><c- p>,</c-> <c- n>r</c-><c- p>)</c-></code>, or <code class="highlight"><c- n>a_tran</c-><c- p>.</c-><c- n>end</c-><c- p>()</c-></code> if such an element is not found.</p> <p>168․ Complexity: Logarithmic.</p> <pre class="highlight"><c- n>b</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- n>k</c-><c- p>)</c->
</pre> <p>169․ Result: <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- n>iterator</c-><c- o>></c-></code>; <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>const_iterator</c-><c- p>,</c-> <c- n>const_iterator</c-><c- o>></c-></code> for constant <code class="highlight"><c- n>b</c-></code>.</p> <p>170․ Effects: Equivalent to: <code class="highlight"><c- k>return</c-> <c- n>make_pair</c-><c- p>(</c-><c- n>b</c-><c- p>.</c-><c- n>lower_bound</c-><c- p>(</c-><c- n>k</c-><c- p>),</c-> <c- n>b</c-><c- p>.</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>k</c-><c- p>));</c-></code></p> <p>171․ Complexity: <del>Logarithmic.</del> <ins>O(M + log N), where N is <code class="highlight"><c- n>b</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> and M is <code class="highlight"><c- n>distance</c-><c- p>(</c-><c- n>b</c-><c- p>.</c-><c- n>lower_bound</c-><c- p>(</c-><c- n>k</c-><c- p>),</c-> <c- n>b</c-><c- p>.</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>k</c-><c- p>))</c-></code>.</ins></p> <pre class="highlight"><c- n>a_tran</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- n>ke</c-><c- p>)</c->
</pre> <p>172․ Result: <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- n>iterator</c-><c- o>></c-></code>; <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>const_iterator</c-><c- p>,</c-> <c- n>const_iterator</c-><c- o>></c-></code> for constant <code class="highlight"><c- n>a_tran</c-></code>.</p> <p>173․ Effects: Equivalent to: <code class="highlight"><c- k>return</c-> <c- n>make_pair</c-><c- p>(</c-><c- n>a_tran</c-><c- p>.</c-><c- n>lower_bound</c-><c- p>(</c-><c- n>ke</c-><c- p>),</c-> <c- n>a_tran</c-><c- p>.</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>ke</c-><c- p>));</c-></code></p> <p>174․ Complexity: <del>Logarithmic.</del> <ins>O(M + log N), where N is <code class="highlight"><c- n>a_tran</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> and M is <code class="highlight"><c- n>distance</c-><c- p>(</c-><c- n>a_tran</c-><c- p>.</c-><c- n>lower_bound</c-><c- p>(</c-><c- n>ke</c-><c- p>),</c-> <c- n>a_tran</c-><c- p>.</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>ke</c-><c- p>))</c-></code>.</ins></p> </small>
   </blockquote>
   <h3 class="heading settled" data-level="12.4" id="special-members"><span class="secno">12.4. </span><span class="content">Special member functions</span><a class="self-link" href="#special-members"></a></h3>
   <p><a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> currently does not declare
any special member functions. This implies that they are defaulted, which implicitly specifies
their constexprness, noexceptness, and triviality.</p>
   <p>All three C++20 container adaptors (e.g. <a href="https://eel.is/c++draft/priqueue.overview">[priqueue.overview]</a>)
follow that approach, too.</p>
   <p>All four associative and four unordered containers (e.g. <a href="https://eel.is/c++draft/set.overview">[set.overview]</a>)
explicitly provide signatures for all five special members, including the destructor, like
this:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight">    <c- n>set</c-><c- p>(</c-><c- k>const</c-> <c- n>set</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c->
    <c- n>set</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- p>[...]</c->
    <c- o>~</c-><c- n>set</c-><c- p>();</c->
    <c- n>set</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- k>const</c-> <c- n>set</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c->
    <c- n>set</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c->
      <c- k>noexcept</c-><c- p>(</c-><c- n>allocator_traits</c-><c- o>&lt;</c-><c- n>Allocator</c-><c- o>>::</c-><c- n>is_always_equal</c-><c- o>::</c-><c- n>value</c-> <c- o>&amp;&amp;</c->
               <c- n>is_nothrow_move_assignable_v</c-><c- o>&lt;</c-><c- n>Compare</c-><c- o>></c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Should <code class="highlight"><c- n>flat_set</c-></code>’s spec hew more closely to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>set</c-></code>’s or <code class="highlight"><c- n>priority_queue</c-></code>’s?
We tentatively think <code class="highlight"><c- n>set</c-></code>’s is the better model, so that the vendor would be free to
make the special members non-defaulted. Vendors are still permitted to strengthen the
noexceptness and/or triviality of declared functions; for example, both libc++ and libstdc++
make <code class="highlight"><c- n>set</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> conditionally noexcept.</p>
<pre class="language-c++ highlight"><c- n>using</c-> <c- n>V</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>experimental</c-><c- o>::</c-><c- n>fixed_capacity_vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- mi>100</c-><c- o>></c-><c- p>;</c->
<c- k>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_destructible_v</c-><c- o>&lt;</c-><c- n>V</c-><c- o>></c-><c- p>);</c->
<c- n>using</c-> <c- n>M</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-><c- p>,</c-> <c- n>V</c-><c- o>></c-><c- p>;</c->
<c- k>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_destructible_v</c-><c- o>&lt;</c-><c- n>M</c-><c- o>></c-><c- p>);</c->
  <c- c1>// Before: Mandatory.</c->
  <c- c1>// After: Permitted but not mandatory.</c->
</pre>
   <h3 class="heading settled" data-level="12.5" id="move-from-comparator"><span class="secno">12.5. </span><span class="content">Moving from the comparator</span><a class="self-link" href="#move-from-comparator"></a></h3>
   <p>As shown above, the associative and unordered containers give their move-assignment operator
a noexcept-spec that strongly implies it must move-from the comparator, never copy it.
This particularly affects libstdc++, where <code class="highlight"><c- n>set</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> will copy a stateful comparator
(e.g. <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-></code>) instead of moving-from it, but <code class="highlight"><c- n>set</c-><c- o>::</c-><c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> must move
the comparator, leaving the source object in a "radioactive" state.</p>
   <p>This whole area is the subject of <a data-link-type="biblio" href="#biblio-lwg2227" title="Stateful comparison objects in associative containers">[LWG2227]</a> "Stateful comparison objects in associative containers,"
and is certainly beyond the scope of this paper P2767.</p>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>TestLess</c-> <c- o>:</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;></c-> <c- p>{</c->
  <c- c1>// make this too big to fit in the small buffer</c->
  <c- b>char</c-> <c- n>pad_</c-><c- p>[</c-><c- mi>1000</c-><c- p>];</c->
<c- p>};</c->
<c- n>using</c-> <c- n>C</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>function</c-><c- o>&lt;</c-><c- b>bool</c-><c- p>(</c-><c- b>int</c-><c- p>,</c-><c- b>int</c-><c- p>)</c-><c- o>></c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>set</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>C</c-><c- o>></c-> <c- n>s</c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>},</c-> <c- n>C</c-><c- p>(</c-><c- n>TestLess</c-><c- p>()));</c->
<c- n>assert</c-><c- p>(</c-><c- n>s</c-><c- p>.</c-><c- n>key_comp</c-><c- p>()</c-> <c- o>!=</c-> <c- n>nullptr</c-><c- p>);</c->
<c- k>auto</c-> <c- n>t</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>s</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>s</c-><c- p>.</c-><c- n>key_comp</c-><c- p>()</c-> <c- o>!=</c-> <c- n>nullptr</c-><c- p>);</c->
  <c- c1>// libstdc++: Succeeds</c->
  <c- c1>// libc++: Fails</c->
<c- n>s</c-><c- p>.</c-><c- n>clear</c-><c- p>();</c->
<c- n>s</c-><c- p>.</c-><c- n>insert</c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>});</c->
  <c- c1>// libstdc++: OK</c->
  <c- c1>// libc++: Throws std::bad_function_call</c->
<c- n>t</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>s</c-><c- p>);</c->
<c- n>s</c-><c- p>.</c-><c- n>insert</c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>});</c->
  <c- c1>// Everyone: Throws std::bad_function_call</c->
</pre>
   <p>If we user-declare <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>flat_set</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code>,
we must decide whether to give it a similar noexcept-spec.</p>
   <h4 class="heading settled" data-level="12.5.1" id="wording-special-members"><span class="secno">12.5.1. </span><span class="content">Possible wording</span><a class="self-link" href="#wording-special-members"></a></h4>
   <p class="note" role="note"><span class="marker">Note:</span> This wording merge-conflicts with the resolution of <a data-link-type="biblio" href="#biblio-lwg3884" title="flat_foo is missing allocator-extended copy/move constructors">[LWG3884]</a>, which in turn merge-conflicts
with the editorial refactoring in §3. We can polish it later;
the first question is whether LWG wants to pursue this direction at all.</p>
   <p>For example, change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.map.cons], constructors</c->
<c- n>flat_map</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->

<ins><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>flat_map</c-><c- o>&amp;</c-><c- p>);</c-></ins>
<ins><c- n>flat_map</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;&amp;</c-><c- p>);</c-></ins>
<ins><c- n>flat_map</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- k>const</c-> <c- n>flat_multimap</c-><c- o>&amp;</c-><c- p>);</c-></ins>
<ins><c- n>flat_map</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>flat_multimap</c-><c- o>&amp;&amp;</c-><c- p>)</c-></ins>
  <ins><c- k>noexcept</c-><c- p>(</c-><c- n>is_nothrow_move_assignable_v</c-><c- o>&lt;</c-><c- n>KeyContainer</c-><c- o>></c-> <c- o>&amp;&amp;</c-></ins>
           <ins><c- n>is_nothrow_move_assignable_v</c-><c- o>&lt;</c-><c- n>MappedContainer</c-><c- o>></c-> <c- o>&amp;&amp;</c-></ins>
           <ins><c- n>is_nothrow_move_assignable_v</c-><c- o>&lt;</c-><c- n>Compare</c-><c- o>></c-><c- p>);)</c-></ins>
<ins><c- o>~</c-><c- n>flat_map</c-><c- p>();</c-></ins>

<c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
         <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre></small>
   </blockquote>
   <h3 class="heading settled" data-level="12.6" id="qualifies-container"><span class="secno">12.6. </span><span class="content">"Qualifies as a container"</span><a class="self-link" href="#qualifies-container"></a></h3>
   <p>Arthur’s libc++ implements an alternative resolution to <a data-link-type="biblio" href="#biblio-lwg3803" title="flat_foo constructors taking KeyContainer lack KeyCompare parameter">[LWG3803]</a>. This resolution applies
generally to all container adaptors, and has the advantage of not ad-hoc relying on a
complicated type trait (<code class="highlight"><c- n>is_invocable</c-></code>) but being a little more consistent with the
pre-existing spec.</p>
   <p>The choice of <code class="highlight"><c- n>C</c-><c- o>::</c-><c- n>const_iterator</c-></code> is simply because <code class="highlight"><c- n>T</c-><c- o>::</c-><c- n>value_type</c-></code> is already present
for allocators, and <code class="highlight"><c- n>T</c-><c- o>::</c-><c- n>iterator</c-></code> is already present for many iterators (those that inherit
from <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>iterator</c-></code>, for example). We could just as well choose a criterion like
"The expression <code class="highlight"><c- n>declval</c-><c- o>&lt;</c-><c- n>C</c-><c- o>&amp;></c-><c- p>().</c-><c- n>size</c-><c- p>()</c-></code> is well-formed when treated as an unevaluated operand."</p>
   <h4 class="heading settled" data-level="12.6.1" id="wording-qualifies-container"><span class="secno">12.6.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-qualifies-container"></a></h4>
   <p>
    Arthur’s preferred resolution is shown in 
    <ins>this color</ins>
    .
Parts of the current C++23 Working Draft that were introduced by the adopted
resolution of LWG3803, but would be removed by this change, are shown in 
    <src>this color</src>
    .
   </p>
   <p>Change <a href="https://eel.is/c++draft/container.requirements#container.reqmts-69">[container.reqmts]/69</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> 69․ The behavior of certain container member functions and deduction guides depends on whether types qualify as
input iterators<ins>, containers,</ins> or allocators.<p></p> <p><ins>x․</ins> The extent to which an implementation determines that a type cannot be an input iterator is unspecified,
except that as a minimum integral types shall not qualify as input iterators. </p><p><ins>x․</ins> <del>Likewise, the</del> <ins>The</ins> extent to which an implementation determines that a type cannot be an allocator is unspecified,
except that as a minimum a type <code class="highlight"><c- n>A</c-></code> shall not qualify as an allocator unless it meets both of the following conditions: </p><ul><li data-md><p>(69.1) The qualified-id <code class="highlight"><c- n>A</c-><c- o>::</c-><c- n>value_type</c-></code> is valid and denotes a type ([temp.deduct]).</p> </li><li data-md><p>(69.2) The expression <code class="highlight"><c- n>declval</c-><c- o>&lt;</c-><c- n>A</c-><c- o>&amp;></c-><c- p>().</c-><c- n>allocate</c-><c- p>(</c-><c- b>size_t</c-><c- p>{})</c-></code> is well-formed when treated as an unevaluated operand.</p> </li></ul> <p><ins>x․ The extent to which an implementation determines that a type cannot be a container
is unspecified, except that as a minimum a type C shall not qualify as a container
unless the qualified-id <code class="highlight"><c- n>C</c-><c- o>::</c-><c- n>const_iterator</c-></code> is valid and denotes a type.</ins> </p></small></blockquote>
   <p>Change <a href="https://eel.is/c++draft/container.adaptors.general">[container.adaptors.general]/6</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> 6․ A deduction guide for a container adaptor shall not participate in overload resolution if any of the following are true:<p></p> <ul><li data-md><p>(6.1) It has an <code class="highlight"><c- n>InputIterator</c-></code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p> </li><li data-md><p>(6.2) It has a <code class="highlight"><c- n>Compare</c-></code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p> </li><li data-md><p>(6.3) It has a <code class="highlight"><c- n>Container</c-></code>, <code class="highlight"><c- n>KeyContainer</c-></code>, or <code class="highlight"><c- n>MappedContainer</c-></code> template parameter
 and a type that <del>qualifies as an allocator</del> <ins>does not qualify as a container</ins> is deduced for that parameter.</p> </li><li data-md><p>(6.4) It has no <code class="highlight"><c- n>Container</c-></code>, <code class="highlight"><c- n>KeyContainer</c-></code>, or <code class="highlight"><c- n>MappedContainer</c-></code> template parameter,
 and it has an <code class="highlight"><c- n>Allocator</c-></code> template parameter, and a type that does not qualify as an allocator is deduced for that parameter.</p> </li><li data-md><p>(6.5) It has both <code class="highlight"><c- n>Container</c-></code> and <code class="highlight"><c- n>Allocator</c-></code> template parameters, and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>Container</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">false</code>.</p> </li><li data-md><p>(6.6) It has both <code class="highlight"><c- n>KeyContainer</c-></code> and <code class="highlight"><c- n>Allocator</c-></code> template parameters, and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">false</code>.</p> </li><li data-md><src>(6.7) It has both <code class="highlight"><c- n>KeyContainer</c-></code> and <code class="highlight"><c- n>Compare</c-></code> template parameters, and</src> <pre class="highlight"><src><c- n>is_invocable_v</c-><c- o>&lt;</c-><c- k>const</c-> <c- n>Compare</c-><c- o>&amp;</c-><c- p>,</c-></src>
              <src><c- k>const</c-> <c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>&amp;</c-><c- p>,</c-></src>
              <src><c- k>const</c-> <c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>&amp;></c-></src>
</pre><src>is not a valid expression or is <code class="highlight">false</code>.</src> </li><li data-md><p>(6.8) It has both <code class="highlight"><c- n>MappedContainer</c-></code> and <code class="highlight"><c- n>Allocator</c-></code> template parameters, and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>MappedContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">false</code>.</p> </li></ul> </small></blockquote>
   <h3 class="heading settled" data-level="12.7" id="iterator-types"><span class="secno">12.7. </span><span class="content"><code class="highlight"><c- n>iterator</c-></code> and <code class="highlight"><c- n>const_iterator</c-></code></span><a class="self-link" href="#iterator-types"></a></h3>
   <p><code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>iterator</c-></code> and <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>const_iterator</c-></code> are presented as if they could be
two different types. This is consistent with how we do it in <code class="highlight"><c- n>set</c-></code> and <code class="highlight"><c- n>unordered_set</c-></code>.
But in practice, all three vendors make <code class="highlight"><c- n>set</c-><c- o>::</c-><c- n>iterator</c-></code> and <code class="highlight"><c- n>set</c-><c- o>::</c-><c- n>const_iterator</c-></code> the
same type. We should consider refactoring the spec of <code class="highlight"><c- n>set</c-></code>, <code class="highlight"><c- n>unordered_set</c-></code>, and <code class="highlight"><c- n>flat_set</c-></code> all at once to <em>mandate</em> that these iterator types be the same type, the same way we
already do for <a href="https://eel.is/c++draft/string.view#footnote-207"><code class="highlight"><c- n>basic_string_view</c-></code></a> and (since C++23 introduced <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>const_iterator</c-></code>) <a href="https://eel.is/c++draft/span.overview"><code class="highlight"><c- n>span</c-><c- o>&lt;</c-><c- k>const</c-> <c- n>T</c-><c- o>></c-></code></a>.</p>
   <p>This would allow us to remove a lot of redundant overloads from the specification,
e.g. we don’t need both <code class="highlight"><c- n>iterator</c-> <c- n>find</c-><c- p>(</c-><c- n>value_type</c-><c- p>)</c-></code> and <code class="highlight"><c- n>const_iterator</c-> <c- n>find</c-><c- p>(</c-><c- n>value_type</c-><c- p>)</c-> <c- k>const</c-></code> if those are the same iterator type. Vendors can already do this removal in their implementations
if they choose to. This is merely a question of our getting to do it in the paper specification too,
under the banner of "standardizing existing practice."</p>
   <h3 class="heading settled" data-level="12.8" id="containers"><span class="secno">12.8. </span><span class="content">Support for non-standard containers</span><a class="self-link" href="#containers"></a></h3>
   <p>Vendors are required to support "random-access containers," which means <code class="highlight"><c- n>vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> (except for <code class="highlight"><c- n>vector</c-><c- o>&lt;</c-><c- b>bool</c-><c- o>></c-></code>)
and <code class="highlight"><c- n>deque</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>. It’s unclear if vendors are required to support non-standard containers such as <code class="highlight"><c- n>boost</c-><c- o>::</c-><c- n>container</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>; and if so, what public API those containers must provide in order
to interoperate with <code class="highlight"><c- n>flat_set</c-></code>.</p>
   <p>For example, suppose the underlying container supports <code class="highlight"><c- n>C</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code> but not <code class="highlight"><c- n>C</c-><c- p>(</c-><c- n>from_range</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code>. Then I would expect that I couldn’t initialize a <code class="highlight"><c- n>flat_set</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>C</c-><c- o>></c-></code> with <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>from_range</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code>; but I should still be able to initialize it with <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>,
right? It would be nice to see what’s required and what’s encouraged in this area.</p>
   <p>libc++ goes very slightly out of its way to support <code class="highlight"><c- n>vector</c-><c- o>&lt;</c-><c- b>bool</c-><c- o>></c-></code> as the underlying container,
even though we believe we’re not required to support it.</p>
   <h3 class="heading settled" data-level="12.9" id="redundancy"><span class="secno">12.9. </span><span class="content">Inconsistent handling of redundancy in [flat.multiset] and [flat.multimap]</span><a class="self-link" href="#redundancy"></a></h3>
   <p>See <a href="https://github.com/cplusplus/draft/pull/6246#issuecomment-1539789693">#6246</a>.</p>
   <p><a href="https://eel.is/c++draft/flat.multiset#overview-4">[flat.multiset.overview/4]</a> uses
the same boilerplate as <code class="highlight"><c- n>vector</c-></code>, <code class="highlight"><c- n>set</c-></code>, <code class="highlight"><c- n>flat_set</c-></code>, and <code class="highlight"><c- n>flat_map</c-></code>:</p>
   <p><small></small></p>
   <blockquote><small> Descriptions are provided here only for operations on <code class="highlight"><c- n>flat_multiset</c-></code> that are not described
in one of the general sections or for operations where there is additional semantic information.<p></p> </small></blockquote>
   <p><a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview/4]</a> uses
different boilerplate:</p>
   <p><small></small></p>
   <blockquote><small> Except as otherwise noted, operations on <code class="highlight"><c- n>flat_multimap</c-></code> are equivalent to those of <code class="highlight"><c- n>flat_map</c-></code>,
except that <code class="highlight"><c- n>flat_multimap</c-></code> operations do not remove or replace elements with equal keys.<p></p> <p>[Example 1: <code class="highlight"><c- n>flat_multimap</c-></code> constructors and emplace do not erase non-unique elements after sorting them. —end example]</p> </small></blockquote>
   <p>That’s a little handwavey: It doesn’t bother to explain that <code class="highlight"><c- n>flat_multimap</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- p>)</c-></code> is "equivalent to" <code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- p>)</c-></code>. It doesn’t bother to explain how
the <code class="highlight"><c- n>iterator</c-></code> return value of <code class="highlight"><c- n>flat_multimap</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> is derived from the <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-></code> return value of <code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code>.</p>
   <p>But it does make the spec a lot shorter! Should we apply the same technique to [flat.multiset]
that we already apply to [flat.multimap]? I haven’t written wording for this yet, but can do so
if LWG is interested.</p>
   <p>Vice versa, should we tweak [flat.multimap]'s wording to address the two "doesn’t bother" points above?
Should we tweak it to say "equivalent keys" or "duplicate keys" instead of "equal keys"?</p>
   <h3 class="heading settled" data-level="12.10" id="noexcept-swap"><span class="secno">12.10. </span><span class="content">Noexcept <code class="highlight"><c- n>swap</c-></code></span><a class="self-link" href="#noexcept-swap"></a></h3>
   <p>This area seems to have been tweaked quite a bit at Batavia 2018.
See <a href="https://wiki.edg.com/bin/view/LWGBatavia2018/WednesdayAMMinutes">the minutes</a>.</p>
   <p><code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>swap</c-></code> is currently specified as unconditionally noexcept, which is inconsistent both
with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>set</c-></code> and with the pre-existing adaptors.</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.set.defn]</c->
<c- b>void</c-> <c- nf>swap</c-><c- p>(</c-><c- n>flat_set</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->

<c- c1>// [priqueue.overview]</c->
<c- b>void</c-> <c- nf>swap</c-><c- p>(</c-><c- n>priority_queue</c-><c- o>&amp;</c-> <c- n>q</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>(</c-><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>Container</c-><c- o>></c-> <c- o>&amp;&amp;</c->
                                      <c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>Compare</c-><c- o>></c-><c- p>)</c->
  <c- p>{</c-> <c- k>using</c-> <c- n>std</c-><c- o>::</c-><c- n>swap</c-><c- p>;</c-> <c- n>swap</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>q</c-><c- p>.</c-><c- n>c</c-><c- p>);</c-> <c- n>swap</c-><c- p>(</c-><c- n>comp</c-><c- p>,</c-> <c- n>q</c-><c- p>.</c-><c- n>comp</c-><c- p>);</c-> <c- p>}</c->

<c- c1>// [set.overview]</c->
<c- b>void</c-> <c- nf>swap</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;</c-><c- p>)</c->
  <c- k>noexcept</c-><c- p>(</c-><c- n>allocator_traits</c-><c- o>&lt;</c-><c- n>Allocator</c-><c- o>>::</c-><c- n>is_always_equal</c-><c- o>::</c-><c- n>value</c-> <c- o>&amp;&amp;</c->
           <c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>Compare</c-><c- o>></c-><c- p>);</c->
</pre><p><a href="https://eel.is/c++draft/associative.reqmts#except-3">[associative.reqmts.except]/3</a>:
For associative containers, no <code class="highlight"><c- n>swap</c-></code> function throws an exception unless that exception
is thrown by the swap of the container’s <code class="highlight"><c- n>Compare</c-></code> object (if any).</p> </small>
   </blockquote>
   <p>Suppose the underlying container has a throwing move-constructor (like MSVC <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>list</c-></code>), and lacks a custom <code class="highlight"><c- n>swap</c-></code>;
then <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>swap</c-><c- o>&lt;</c-><c- n>Container</c-><c- o>></c-></code> can throw. Or, suppose the underlying container is <code class="highlight"><c- n>boost</c-><c- o>::</c-><c- n>container</c-><c- o>::</c-><c- n>static_vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>;
then its <code class="highlight"><c- n>swap</c-></code> must swap <code class="highlight"><c- n>T</c-></code> objects, which can throw.</p>
   <p>Now, what happens if swapping the containers actually does throw? Then both containers are in an unknown
state, so we must restore the invariant by clearing both containers. We do the same thing if <code class="highlight"><c- n>insert</c-></code> or <code class="highlight"><c- n>erase</c-></code> throws, so this is nothing new.</p>
   <p>What happens if swapping the comparators throws? Then we cannot recover. Louis suggests adding <code class="highlight"><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>Compare</c-><c- o>></c-></code> as a constraint. The intent is nicely ergonomic:
Almost all comparators are nothrow swappable (including <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-></code>, if we want to support that: <a data-link-type="biblio" href="#biblio-lwg2227" title="Stateful comparison objects in associative containers">[LWG2227]</a>).
And the resulting behavior seems better: In the pathological corner case where <code class="highlight"><c- n>flat_set</c-></code> cannot safely provide
swappability, it’s better for it not to be swappable at all, than for it to falsely advertise a
noexcept <code class="highlight"><c- n>swap</c-></code>. But, if we constrain away <code class="highlight"><c- n>flat_set</c-></code>’s hidden-friend <code class="highlight"><c- n>swap</c-></code>, <code class="highlight"><c- n>swap</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>fs</c-><c- p>)</c-></code> will still
compile; it’ll just fall back to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>swap</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-> <c- p>[</c-><c- n>with</c-> <c- n>T</c-><c- o>=</c-><c- n>flat_set</c-><c- p>]</c-></code>. We could actually <code class="highlight"><c- o>=</c-><c- k>delete</c-></code> the <code class="highlight"><c- n>swap</c-></code> function, like this:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight">    <del><c- b>void</c-> <c- nf>swap</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c-></del>
    <ins><c- b>void</c-> <c- nf>swap</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-></ins>
      <ins><c- k>noexcept</c-><c- p>(</c-><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- o>></c-> <c- o>&amp;&amp;</c-></ins>
               <ins><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- o>></c-><c- p>)</c-></ins>
      <ins><c- k>requires</c-> <c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>key_compare</c-><c- o>></c-></ins>
    <c- b>void</c-> <c- n>clear</c-><c- p>()</c-> <c- k>noexcept</c-><c- p>;</c->

<c- p>[...]</c->

    <del><c- k>friend</c-> <c- b>void</c-> <c- n>swap</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>,</c-> <c- n>flat_map</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-> <c- k>noexcept</c-> <c- p>{</c-> <c- n>x</c-><c- p>.</c-><c- n>swap</c-><c- p>(</c-><c- n>y</c-><c- p>);</c-> <c- p>}</c-></del>
    <ins><c- k>friend</c-> <c- b>void</c-> <c- n>swap</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>,</c-> <c- n>flat_map</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-></ins>
      <ins><c- k>noexcept</c-><c- p>(</c-><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- o>></c-> <c- o>&amp;&amp;</c-></ins>
               <ins><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- o>></c-><c- p>)</c-></ins>
      <ins><c- k>requires</c-> <c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>key_compare</c-><c- o>></c-></ins>
        <ins><c- p>{</c-> <c- n>x</c-><c- p>.</c-><c- n>swap</c-><c- p>(</c-><c- n>y</c-><c- p>);</c-> <c- p>}</c-></ins>
    <ins><c- k>friend</c-> <c- b>void</c-> <c- n>swap</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>,</c-> <c- n>flat_map</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-></ins>
      <ins><c- k>requires</c-> <c- p>(</c-><c- o>!</c-><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>key_compare</c-><c- o>></c-><c- p>)</c-> <c- o>=</c-> <c- k>delete</c-><c- p>;</c-></ins>
</pre></small>
   </blockquote>
   <p>but even then <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>fs</c-><c- p>)</c-></code> would still compile; it would fall back to the
three-step move-and-assign.</p>
   <p>It seems to be impossible to make <code class="highlight"><c- n>flat_set</c-></code> non-swappable. The only reasonable options are:</p>
   <ul>
    <li data-md>
     <p>Keep the status quo (unconditional <code class="highlight"><c- k>noexcept</c-></code>) and terminate the program if swapping containers throws</p>
    <li data-md>
     <p>Conditional <code class="highlight"><c- k>noexcept</c-></code> like in [priqueue.overview], and don’t care if swapping throws
(i.e. match <code class="highlight"><c- n>priority_queue</c-></code>’s status quo)</p>
    <li data-md>
     <p>Conditional <code class="highlight"><c- k>noexcept</c-></code> like in [priqueue.overview], and clear both containers if swapping throws
(but this won’t prevent radioactivity, if <code class="highlight"><c- n>swap</c-></code> left the comparator in a bad state)</p>
   </ul>
   <h4 class="heading settled" data-level="12.10.1" id="ranges-swap"><span class="secno">12.10.1. </span><span class="content">Specified in terms of <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-></code></span><a class="self-link" href="#ranges-swap"></a></h4>
   <p>Orthogonally: It surprises us that [flat.map.modifiers] specifies <code class="highlight"><c- n>swap</c-></code>’s
implementation in terms of <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>y</c-><c- p>.</c-><c- n>c</c-><c- p>)</c-></code> etc. This feels overspecified; <a href="https://eel.is/c++draft/container.reqmts#49">[container.reqmts]</a> adequately covers the semantics of swapping,
and vendors should be able to decide for themselves how to swap comparator objects, just like
we do in <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>set</c-></code>. Arguably the tight specification helps programmers providing their own
underlying containers: they know they just need to provide an ADL <code class="highlight"><c- n>swap</c-></code> or the requirements
of <a href="https://eel.is/c++draft/concept.swappable#2.3.sentence-1">[concept.swappable]/2.3</a>.
But one might point out to those programmers that their underlying container
must provide the API required in <a href="https://eel.is/c++draft/container.reqmts#49">[container.reqmts]/49–51</a>,
so the vendor can use ADL <code class="highlight"><c- n>swap</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>y</c-><c- p>.</c-><c- n>c</c-><c- p>)</c-></code> or <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>swap</c-><c- p>(</c-><c- n>y</c-><c- p>.</c-><c- n>c</c-><c- p>)</c-></code> if they want to.</p>
   <p>libc++'s implementation currently uses ADL <code class="highlight"><c- n>swap</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>y</c-><c- p>.</c-><c- n>c</c-><c- p>)</c-></code>, which is equivalent to <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-></code> for all containers satisfying <a href="https://eel.is/c++draft/container.reqmts#51">[container.reqmts]/51</a>;
but the difference between <code class="highlight"><c- n>swap</c-><c- p>(</c-><c- n>compare</c-><c- p>,</c-> <c- n>y</c-><c- p>.</c-><c- n>compare</c-><c- p>)</c-></code> and <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-><c- p>(</c-><c- n>compare</c-><c- p>,</c-> <c- n>y</c-><c- p>.</c-><c- n>compare</c-><c- p>)</c-></code> is probably observable.</p>
   <h3 class="heading settled" data-level="12.11" id="lwg-3802"><span class="secno">12.11. </span><span class="content">Allocator-extended container constructors lack move semantics</span><a class="self-link" href="#lwg-3802"></a></h3>
   <p>(This whole section would be mooted by <a href="#deceptive-remove">§ 14.2 Remove the container constructors; make replace sort by default</a>.)</p>
   <p>libc++ has implemented move-semantic allocator-extended constructors for all four flat containers
(<a href="https://godbolt.org/z/We7K1K6bE">Godbolt</a>). This is <a data-link-type="biblio" href="#biblio-lwg3802" title="flat_foo allocator-extended constructors lack move semantics">[LWG3802]</a>.</p>
<pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- n>class</c-> <c- n>C</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c->
<c- n>using</c-> <c- n>PmrFlatSet</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>C</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c-><c- p>;</c->

<c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>monotonic_buffer_resource</c-> <c- n>mr</c-><c- p>;</c->
<c- k>auto</c-> <c- n>sets</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>PmrFlatSet</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- k>auto</c-> <c- n>cont1</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>},</c-> <c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>sets</c-><c- p>.</c-><c- n>emplace_back</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont1</c-><c- p>));</c->
  <c- c1>// Before: Makes copies of all the data</c->
  <c- c1>// After: Takes ownership of the existing data</c->

<c- k>auto</c-> <c- n>cont2</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-><c- p>();</c->
<c- k>auto</c-> <c- n>fs</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont2</c-><c- p>));</c->
  <c- c1>// Before: Ill-formed</c->
  <c- c1>// After: OK</c->
</pre>
   <p>The wording patch for this (based on top of P2767’s editorial refactoring)
would look something like this. I haven’t written wording for this yet, but can do so,
if LWG is interested, after P2767’s editorial refactoring is merged.</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.map.cons.alloc], constructors with allocators</c->

<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
</pre></small>
   </blockquote>
   <h2 class="heading settled" data-level="13" id="heterogeneous-insert-multiset"><span class="secno">13. </span><span class="content">Heterogeneous <code class="highlight"><c- n>multiset</c-><c- o>::</c-><c- n>insert</c-></code></span><a class="self-link" href="#heterogeneous-insert-multiset"></a></h2>
   <p><a data-link-type="biblio" href="#biblio-p2363" title="Extending associative containers with the remaining heterogeneous overloads">[P2363]</a> <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html#ins">explains</a> why the node-based <code class="highlight"><c- n>multiset</c-></code> still lacks a heterogeneous <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code>:</p>
   <blockquote>
    <p>Adding heterogeneous <code class="highlight"><c- n>insert</c-></code> overload makes no sense for associative containers with non-unique keys (<code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>multimap</c-></code>, <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>multiset</c-></code>, <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>unordered_multimap</c-></code> and <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>unordered_multiset</c-></code>) because the insertion will be successful in any case and the key would be always
constructed. All additional overheads introduced by <code class="highlight"><c- n>insert</c-></code> can be mitigated by using <code class="highlight"><c- n>emplace</c-></code>.</p>
   </blockquote>
   <p>For <code class="highlight"><c- n>flat_multiset</c-></code>, the last sentence is false; generic <code class="highlight"><c- n>emplace</c-></code> is unusable for PMR allocators, because it
must first construct <code class="highlight"><c- n>t</c-></code> using the default allocator. Therefore we also propose to add a heterogeneous-comparison
overload of <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>insert</c-></code>.</p>
<pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- n>class</c-> <c- n>C</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c->
<c- n>using</c-> <c- n>PmrFlatMultiset</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_multiset</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>C</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c-><c- p>;</c->

<c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>monotonic_buffer_resource</c-> <c- nf>mr</c-><c- p>(</c-><c- mi>1</c->’<c- mo>000</c->’<c- mo>000</c-><c- p>);</c->
<c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>set_default_resource</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>null_memory_resource</c-><c- p>());</c->
<c- k>const</c-> <c- b>char</c-> <c- n>s</c-><c- p>[]</c-> <c- o>=</c-> <c- s>"too long to fit in the small string buffer"</c-><c- p>;</c->

<c- k>auto</c-> <c- n>m</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>multiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- o>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>m</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// OK</c->
<c- n>m</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// runtime abort, cannot default-allocate x</c->

<c- k>auto</c-> <c- n>fm</c-> <c- o>=</c-> <c- n>PmrFlatMultiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- o>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>fm</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// runtime abort, cannot default-allocate t</c->
<c- n>fm</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// runtime abort, cannot default-allocate x</c->

<c- k>auto</c-> <c- n>m2</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>multiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>m2</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// OK</c->
<c- n>m2</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// runtime abort, cannot default-allocate x</c->

<c- k>auto</c-> <c- n>fm2</c-> <c- o>=</c-> <c- n>PmrFlatMultiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>fm2</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// runtime abort, cannot default-allocate t</c->
<c- n>fm2</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>);</c->
  <c- c1>// Before: runtime abort, cannot default-allocate x</c->
  <c- c1>// After: OK</c->
</pre>
   <p>Notice the asymmetry between <code class="highlight"><c- n>fm2</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>)</c-></code> and <code class="highlight"><c- n>m2</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>)</c-></code>. Arthur thinks it would be
nice to support heterogeneous <code class="highlight"><c- n>insert</c-></code> for node-based <code class="highlight"><c- n>multiset</c-></code> and <code class="highlight"><c- n>unordered_multiset</c-></code> (<em>contra</em> P2363’s reasoning),
but that’s out of scope for this particular paper P2767. For P2767’s purposes, we’re satisfied
once there exists <em>some</em> way of inserting <code class="highlight"><c- n>s</c-></code> into <code class="highlight"><c- n>fm2</c-></code>. We don’t mind that the working approaches
use different spellings: <code class="highlight"><c- n>m2</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>s</c-><c- p>)</c-></code> versus <code class="highlight"><c- n>fm2</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>)</c-></code>.</p>
   <h3 class="heading settled" data-level="13.1" id="wording-heterogeneous-insert-multiset"><span class="secno">13.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-heterogeneous-insert-multiset"></a></h3>
   <p class="note" role="note"><span class="marker">Note:</span> This diff assumes <a href="#wording-insert-emplace">§ 7.6 Wording</a> as the starting point.</p>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.multiset.modifiers], modifiers</c->
<c- k>template</c-><class... args> <c- n>iterator</c-> <c- nf>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c->
  <c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><args><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c->
<c- k>template</c-><class... args>
  <c- n>iterator</c-> <c- nf>emplace_hint</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c->
    <c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><args><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c->

<c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
<c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>hint</c-><c- p>,</c-> <c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
</args></class...></args></class...></pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
</pre><p>x․ Effects: Inserts a new element as if by:</p> <pre class="highlight"><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c->
</pre><p>for the first overload or</p> <pre class="highlight"><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c->
</pre><p>for the second overload.</p> <p>x․ Returns: An iterator that points to the inserted element. </p><pre class="highlight"><ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre> <ins>x․ Constraints: The <em>qualified-id</em> <code class="highlight"><c- n>Compare</c-><c- o>::</c-><c- n>is_transparent</c-></code> is valid and denotes a type. <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>value_type</c-><c- p>,</c-> <c- n>K</c-><c- o>></c-></code> is <code class="highlight">true</code>.
For the second overload, <code class="highlight"><c- n>is_convertible_v</c-><c- o>&lt;</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>const_iterator</c-><c- o>></c-></code> and <code class="highlight"><c- n>is_convertible_v</c-><c- o>&lt;</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>iterator</c-><c- o>></c-></code> are both <code class="highlight">false</code>.</ins> <p><ins>x․ Preconditions: The conversion from <code class="highlight"><c- n>x</c-></code> into <code class="highlight"><c- n>value_type</c-></code> constructs an object <code class="highlight"><c- n>u</c-></code> for which <code class="highlight"><c- n>upper_bound</c-><c- p>(</c-><c- n>x</c-><c- p>)</c-> <c- o>==</c-> <c- n>upper_bound</c-><c- p>(</c-><c- n>u</c-><c- p>)</c-></code> is <code class="highlight">true</code>.</ins> </p><p><ins>x․ Effects: Inserts a new element as if by</ins> </p><pre class="highlight"><ins><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><i><c- n>c</c-></i><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <i><c- n>compare</c-></i><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>K</c-><c- o>></c-><c- p>(</c-><c- n>x</c-><c- p>));</c-></ins>
</pre> <p><ins>x․ Returns: An iterator that points to the inserted element.</ins> </p></small>
   </blockquote>
   <h2 class="heading settled" data-level="14" id="deceptive"><span class="secno">14. </span><span class="content">Non-explicit constructor from two containers</span><a class="self-link" href="#deceptive"></a></h2>
   <p>Arthur has observed <a href="https://quuxplusone.github.io/blog/2023/04/28/flat-map-constructors/">in a blog post</a> that <code class="highlight"><c- n>flat_map</c-></code>’s non-explicit constructor from two containers is deceptive when used with braced initializers.</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>print_map</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>flat_multimap</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-><c- p>);</c->

<c- c1>// Test the two-container constructor... or is it?</c->

<c- n>print_map</c-><c- p>({</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>3</c-><c- p>},</c-> <c- p>{</c-><c- mi>10</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>30</c-><c- p>}</c-> <c- p>});</c-> <c- c1>// {1,10}, {2,20}, {3,30}</c->
<c- n>print_map</c-><c- p>({</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-> <c- mi>2</c-><c- p>},</c->    <c- p>{</c-><c- mi>10</c-><c- p>,</c-> <c- mi>20</c-><c- p>}</c-> <c- p>});</c->     <c- c1>// {1,2}, {10,20}</c->
<c- n>print_map</c-><c- p>({</c-> <c- p>{</c-><c- mi>1</c-><c- p>},</c->       <c- p>{</c-><c- mi>10</c-><c- p>}</c-> <c- p>});</c->         <c- c1>// {1,10}</c->
<c- n>print_map</c-><c- p>({</c-> <c- p>{},</c->        <c- p>{}</c-> <c- p>});</c->           <c- c1>// {0,0}, {0,0}</c->
</pre>
   <h3 class="heading settled" data-level="14.1" id="deceptive-explicit"><span class="secno">14.1. </span><span class="content">Make the container constructors explicit?</span><a class="self-link" href="#deceptive-explicit"></a></h3>
   <p>To address this issue (if we wanted to), we could make one of the relevant constructors <code class="highlight"><c- k>explicit</c-></code>.
We obviously can’t prevent <code class="highlight"><c- n>vector</c-></code>’s construction from a braced list
of elements, nor <code class="highlight"><c- n>pair</c-></code>’s from a braced list of (exactly two) elements, nor (in practice) <code class="highlight"><c- n>pair</c-></code>’s construction from <code class="highlight"><c- p>{}</c-></code>; so the only constructor we could explicify to address this
would be <code class="highlight"><c- n>flat_multimap</c-></code>’s own constructor from a braced list of (exactly two) containers.</p>
   <p><code class="highlight"><c- n>flat_set</c-></code> and <code class="highlight"><c- n>flat_multiset</c-></code>’s container constructors don’t suffer from deceptiveness,
so they wouldn’t be changed by this modest patch.</p>
   <p>Arthur thinks this change would be appreciated by programmers in practice (or rather, if we <em>don’t</em> make this change, then programmers will only ever notice this overload set unfavorably, when it bites them,
and never favorably).</p>
   <p>We recently made some constructors <code class="highlight"><c- k>explicit</c-></code> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2711r1.html">P2711 "Making multi-param constructors of views explicit,"</a> but that paper’s goal was to <em>increase</em> uniformity and symmetry, not to decrease it.</p>
   <p>It would be surprisingly asymmetric to explicify only this one constructor. The small benefit
probably does not justify the asymmetry. Go on to the next section to see Arthur’s preferred
solution, which is much more ambitious.</p>
   <h4 class="heading settled" data-level="14.1.1" id="wording-deceptive-explicit"><span class="secno">14.1.1. </span><span class="content">Possible wording for explicit ctor</span><a class="self-link" href="#wording-deceptive-explicit"></a></h4>
   <p>Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight">    <ins><c- k>explicit</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>)</c-></ins>
      <ins><c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{}</c-></ins>
    <c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
             <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <del><c- o>=</c-> <c- n>key_compare</c-><c- p>()</c-></del><c- p>);</c->
    <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
             <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
<c- p>[...]</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
               <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
               <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
               <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
               <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
               <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.map.cons">[flat.map.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <p></p><pre class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
         <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <del><c- o>=</c-> <c- n>key_compare</c-><c- p>()</c-></del><c- p>);</c->
</pre> <p>1․ <i>Effects:</i> Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>, and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>;
sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>; and finally
erases the duplicate elements as if by: </p><pre class="highlight"><c- k>auto</c-> <c- n>zv</c-> <c- o>=</c-> <c- n>views</c-><c- o>::</c-><c- n>zip</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>);</c->
<c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>unique</c-><c- p>(</c-><c- n>zv</c-><c- p>,</c-> <c- n>key_equiv</c-><c- p>(</c-><c- n>compare</c-><c- p>)).</c-><c- n>begin</c-><c- p>();</c->
<c- k>auto</c-> <c- n>dist</c-> <c- o>=</c-> <c- n>distance</c-><c- p>(</c-><c- n>zv</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>it</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
<c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
</pre><p>2․ <i>Complexity:</i> Linear in <i>N</i> if the container arguments are already sorted with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code> and otherwise <i>N</i> log <i>N</i>, where <i>N</i> is the value of <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call. </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight">    <ins><c- k>explicit</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>)</c-></ins>
      <ins><c- o>:</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{}</c-></ins>
    <c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
                  <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <del><c- o>=</c-> <c- n>key_compare</c-><c- p>()</c-></del><c- p>);</c->
    <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c->
                  <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
                  <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
<c- p>[...]</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.cons">[flat.multimap.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <p></p><pre class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
              <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <del><c- o>=</c-> <c- n>key_compare</c-><c- p>()</c-></del><c- p>);</c->
</pre> <p>1․ <i>Effects:</i> Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>, and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>;
sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>. </p><p>2․<i>Complexity:</i> Linear in <i>N</i> if the container arguments are already sorted with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code> and otherwise <i>N</i> log <i>N</i>, where <i>N</i> is the value of <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call. </p></small>
   </blockquote>
   <h3 class="heading settled" data-level="14.2" id="deceptive-remove"><span class="secno">14.2. </span><span class="content">Remove the container constructors; make <code class="highlight"><c- n>replace</c-></code> sort by default</span><a class="self-link" href="#deceptive-remove"></a></h3>
   <p>A more ambitious alternative would be to eliminate the container constructors entirely,
and say that the only way to move containers into a flat container at all is via <code class="highlight"><c- p>.</c-><c- n>replace</c-></code>,
after the initial construction has already happened. This would be analogous to <code class="highlight"><c- n>vector</c-><c- o>::</c-><c- n>reserve</c-></code> or <code class="highlight"><c- n>unordered_map</c-><c- o>::</c-><c- n>max_load_factor</c-></code> — a feature with no associated constructor, just a setter
after the fact. This would be really bold. But eliminating these constructors would solve <a data-link-type="biblio" href="#biblio-lwg3802" title="flat_foo allocator-extended constructors lack move semantics">[LWG3802]</a> (<a href="#lwg-3802">§ 12.11 Allocator-extended container constructors lack move semantics</a>) in one fell swoop, and reduce <code class="highlight"><c- n>flat_map</c-></code>’s constructor overload
set from 38 constructors down to 20.</p>
   <p>But removing the container constructors introduces a new problem:
Today’s untagged (narrow-contract) <code class="highlight"><c- n>replace</c-></code> can easily replace today’s tagged (narrow-contract)
container constructor. But removing the untagged (wide-contract) container constructor is annoying
for the programmer because it’s tedious to reproduce the effect of the wide-contract container constructor
using only narrow-contract <code class="highlight"><c- n>replace</c-></code>!</p>
<pre class="language-c++ highlight"><c- c1>// Before:</c->
<c- n>FS</c-> <c- n>fs2</c-> <c- o>=</c-> <c- n>FS</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>ks</c-><c- p>));</c->

<c- c1>// After (hypothetically):</c->
<c- n>FS</c-> <c- n>fs2</c-> <c- o>=</c-> <c- n>FS</c-><c- p>(</c-><c- n>ks</c-><c- p>.</c-><c- n>get_allocator</c-><c- p>());</c->
<c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>ks</c-><c- p>);</c->
<c- n>ks</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>unique</c-><c- p>(</c-><c- n>ks</c-><c- p>).</c-><c- n>begin</c-><c- p>(),</c-> <c- n>ks</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
<c- n>fs2</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>ks</c-><c- p>));</c->

<c- c1>// After (hypothetically), if you can afford one extra allocation:</c->
<c- n>FS</c-> <c- n>fs2</c-> <c- o>=</c-> <c- n>FS</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>from_range</c-><c- p>,</c-> <c- n>ks</c-> <c- o>|</c-> <c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>as_rvalue</c-><c- p>,</c-> <c- n>ks</c-><c- p>.</c-><c- n>get_allocator</c-><c- p>());</c->
</pre>
   <p>We boldly address this by giving <code class="highlight"><c- n>replace</c-></code> two overloads. We change the meaning of untagged <code class="highlight"><c- n>fs</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>ks</c-><c- p>)</c-></code> to mean the wide contract, and we add a tagged <code class="highlight"><c- n>fs</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>ks</c-><c- p>)</c-></code> for the narrow contract.
This makes the interface more symmetric, too, because the semantic precondition will now be 100% always indicated
by the presence of the syntactic tag <code class="highlight"><c- n>sorted_unique</c-></code>.</p>
<pre class="language-c++ highlight"><c- k>auto</c-> <c- n>ks</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>},</c-> <c- o>&amp;</c-><c- n>mr1</c-><c- p>);</c->
<c- k>auto</c-> <c- n>vs</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>},</c-> <c- o>&amp;</c-><c- n>mr2</c-><c- p>);</c->

<c- n>using</c-> <c- n>FS</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;></c-><c- p>,</c-> <c- n>decltype</c-><c- p>(</c-><c- n>ks</c-><c- p>)</c-><c- o>></c-><c- p>;</c->
<c- c1>// Before:</c->
<c- n>FS</c-> <c- n>fs1</c-> <c- o>=</c-> <c- n>FS</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>ks</c-><c- p>));</c-> <c- c1>// wide contract, sorts</c->
<c- c1>// After the full patch:</c->
<c- n>FS</c-> <c- n>fs1</c-> <c- o>=</c-> <c- n>FS</c-><c- p>(</c-><c- n>ks</c-><c- p>.</c-><c- n>get_allocator</c-><c- p>());</c->
<c- n>fs1</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>ks</c-><c- p>));</c-> <c- c1>// wide contract, sorts</c->

<c- n>using</c-> <c- n>FM</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_map</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;></c-><c- p>,</c-> <c- n>decltype</c-><c- p>(</c-><c- n>ks</c-><c- p>),</c-> <c- n>decltype</c-><c- p>(</c-><c- n>vs</c-><c- p>)</c-><c- o>></c-><c- p>;</c->
<c- c1>// Before:</c->
<c- n>FM</c-> <c- n>fm1</c-> <c- o>=</c-> <c- n>FM</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>ks</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>vs</c-><c- p>));</c->
  <c- c1>// Two different allocators in the same adaptor.</c->
  <c- c1>// Almost certainly there is no valid reason to do this.</c->
<c- c1>// After:</c->
<c- n>FM</c-> <c- n>fm2</c-> <c- o>=</c-> <c- n>FM</c-><c- p>(</c-><c- n>ks</c-><c- p>.</c-><c- n>get_allocator</c-><c- p>());</c->
<c- n>fm2</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- p>{</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>ks</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>vs</c-><c- p>)</c-> <c- p>});</c->
  <c- c1>// The data from vs is copied into arena mr1.</c->
  <c- c1>// This is less performant, but more sane.</c->
  <c- c1>// It becomes physically impossible to create the equivalent of fm1 above.</c->
</pre>
   <p>It is very late in the game to be doing design work; but this particular redesign
does seem to have a lot of varied benefits for vendors and programmers, with only
the one procedural downside.</p>
   <ul>
    <li data-md>
     <p>Reduces <code class="highlight"><c- n>flat_map</c-></code>’s constructor overload set from 26 (pre-LWG3802) down to 20</p>
    <li data-md>
     <p>Reduces <code class="highlight"><c- n>flat_map</c-></code>’s deduction guide set from 12 down to 6</p>
    <li data-md>
     <p>Solves <a data-link-type="biblio" href="#biblio-lwg3802" title="flat_foo allocator-extended constructors lack move semantics">[LWG3802]</a>, which otherwise would require adding 12 <i>more</i> constructors to <code class="highlight"><c- n>flat_map</c-></code></p>
    <li data-md>
     <p>Solves <a href="#sorting-complexity">§ 9 Complexity clauses of container constructors</a></p>
    <li data-md>
     <p>Eliminates the cause of users' surprise at <code class="highlight"><c- n>flat_map</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-> <c- n>fm</c-> <c- o>=</c-> <c- p>{{},</c-> <c- p>{}}</c-></code></p>
    <li data-md>
     <p>Prevents accidentally constructing a <code class="highlight"><c- n>flat_map</c-></code> that straddles two different allocators</p>
    <li data-md>
     <p>Eliminates some questionable "<i>Complexity:</i> Linear" elements that would otherwise need to be revisited by LWG</p>
    <li data-md>
     <p>Makes all narrow-contract functions uniformly take the <code class="highlight"><c- n>sorted_unique</c-></code> tag</p>
    <li data-md>
     <p>With <a href="#insert-range-sorted-unique">§8 <code class="highlight"><c- n>insert_range</c-></code></a>, makes all mutators uniformly come in tagged (narrow-contract) and untagged (wide-contract) flavors</p>
    <li data-md>
     <p>Provides a wide-contract version of <code class="highlight"><c- n>replace</c-></code>, which didn’t exist before</p>
    <li data-md>
     <p>Since no vendor has shipped flat containers yet, this patch reduces rather than increases vendors' workload</p>
   </ul>
   <p>The procedural downside is:</p>
   <ul>
    <li data-md>
     <p>Technically, C++23 has already shipped. This is an unusually big change to make as a DR.
(But, as I said above, this is not a hardship for vendors because no vendor has yet
started to implement <code class="highlight"><c- n>flat_set</c-></code>, except for libc++, and libc++ wants this change.)</p>
   </ul>
   <h4 class="heading settled" data-level="14.2.1" id="wording-deceptive-remove"><span class="secno">14.2.1. </span><span class="content">Wording for tagged <code class="highlight"><c- n>replace</c-></code></span><a class="self-link" href="#wording-deceptive-remove"></a></h4>
   <p class="note" role="note"><span class="marker">Note:</span> This wording is based on top of the editorial refactoring from §3.</p>
   <p>Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- p>[...]</c->

    <c- c1>// [flat.map.cons], constructors</c->
    <c- n>flat_map</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->
    <c- k>explicit</c-> <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
      <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
    <del><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
             <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
    <del><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
             <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c-> <c- p>}</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
               <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c-> <c- p>}</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-> <c- n>fr</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>fr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>));</c-> <c- p>}</c->

<c- p>[...]</c->

    <c- c1>// [flat.map.cons.alloc], constructors with allocators</c->

    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- k>explicit</c-> <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
               <del><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
               <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></del>
               <del><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></del>
               <del><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
               <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
               <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
               <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->

<c- p>[...]</c->

    <c- n>containers</c-> <c- n>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
    <c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>key_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>mapped_cont</c-><c- p>);</c->
    <ins><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>);</c-></ins>

<c- p>[...]</c->

  <c- p>};</c->

  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-></del>
           <del><c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>>></c-></del>
    <del><c- n>flat_map</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c-></del>
      <del><c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                  <del><c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_map</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                  <del><c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>></c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_map</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                  <del><c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-></del>
           <del><c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>>></c-></del>
    <del><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c-></del>
      <del><c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                  <del><c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                  <del><c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>></c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                  <del><c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>>>></c->
    <c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <i><c- n>iter</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>>>></c->
    <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <i><c- n>iter</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>input_range</c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>></c-><c- p>,</c->
           <c- k>class</c-> <c- nc>Allocator</c-> <c- o>=</c-> <c- n>allocator</c-><c- o>&lt;</c-><c- n>byte</c-><c- o>>></c->
    <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>(),</c-> <c- n>Allocator</c-> <c- o>=</c-> <c- n>Allocator</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c->
                  <c- n>vector</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>>></c-><c- p>,</c->
                  <c- n>vector</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>>>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>input_range</c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
    <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c->
      <c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>></c-><c- p>,</c->
                  <c- n>vector</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>>></c-><c- p>,</c->
                  <c- n>vector</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>>>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Key</c-><c- p>,</c-> <c- k>class</c-> <c- nc>T</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>>></c->
    <c- n>flat_map</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>T</c-><c- o>>></c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>T</c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Key</c-><c- p>,</c-> <c- k>class</c-> <c- nc>T</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>>></c->
    <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>T</c-><c- o>>></c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
        <c- o>-></c-> <c- n>flat_map</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>T</c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
</pre></small>
   </blockquote>
   <p>Remove the whole of <a href="https://eel.is/c++draft/flat.map.cons">[flat.map.cons]</a>,
and change <a href="https://eel.is/c++draft/flat.map.cons.alloc">[flat.map.cons.alloc]</a>, as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <del><b>Constructors [flat.map.cons]</b></del> <p></p><pre class="highlight"><del><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
         <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
</pre> <p><del>1․ <i>Effects:</i> Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>, and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>;
sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>; and
finally erases the duplicate elements as if by:</del> </p><pre class="highlight"><del><c- k>auto</c-> <c- n>zv</c-> <c- o>=</c-> <c- n>views</c-><c- o>::</c-><c- n>zip</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>);</c-></del>
<del><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>unique</c-><c- p>(</c-><c- n>zv</c-><c- p>,</c-> <c- n>key_equiv</c-><c- p>(</c-><c- n>compare</c-><c- p>)).</c-><c- n>begin</c-><c- p>();</c-></del>
<del><c- k>auto</c-> <c- n>dist</c-> <c- o>=</c-> <c- n>distance</c-><c- p>(</c-><c- n>zv</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>it</c-><c- p>);</c-></del>
<del><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-></del>
<del><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-></del>
</pre><p><del>2․ <i>Complexity:</i> Linear in <i>N</i> if the container arguments are already sorted
with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code> and otherwise <i>N</i> log <i>N</i>,
where <i>N</i> is the value of <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> </p><p></p><pre class="highlight"><del><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
         <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
</pre> <p><del>3․ <i>Effects:</i> Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>, and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>.</del> </p><p><del>4․ <i>Complexity:</i> Constant.</del> </p><p><b>Constructors with allocators [flat.map.cons.alloc]</b> </p><p>1․ The constructors in this subclause shall not participate in overload resolution
unless <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- p>,</c-> <c- n>Alloc</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- p>,</c-> <c- n>Alloc</c-><c- o>></c-></code> is <code class="highlight">true</code>. </p><p></p><pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
           <del><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
<del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
           <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
</pre> <p><del>2․ <i>Effects:</i> Equivalent to <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]).</del> </p><p><del>3․ <i>Complexity:</i> Same as <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively.</del> </p><p></p><pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></del>
           <del><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
<del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></del>
           <del><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-></del>
           <del><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
</pre> <p><del>4․ <i>Effects:</i> Equivalent to <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]).</del> </p><p><del>5․ <i>Complexity:</i> Linear.</del> </p><p></p><pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- k>explicit</c-> <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
           <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c->
           <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre> <p>6․ <i>Effects:</i> Equivalent to the corresponding non-allocator constructors except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]). </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.map.modifiers">[flat.map.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> [...]<p></p> <p></p><pre class="highlight"><c- n>containers</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
</pre> <p>34․ <i>Postconditions:</i> <code class="highlight"><c- o>*</c-><c- k>this</c-></code> is emptied, even if the function exits via an exception. </p><p>35․ <i>Returns:</i> <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>c</c-><c- p>)</c-></code>. </p><p></p><pre class="highlight"><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>key_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>mapped_cont</c-><c- p>);</c->
</pre> <p><ins>x․ <i>Preconditions:</i> <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-> <c- o>==</c-> <c- n>mapped_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> is <code class="highlight">true</code>.</ins> </p><p><ins>x․ <i>Effects:</i> Replaces <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>key_cont</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>mapped_cont</c-></code>;
sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>; and
finally erases the duplicate elements as if by:</ins> </p><pre class="highlight"><ins><c- k>auto</c-> <c- n>zv</c-> <c- o>=</c-> <c- n>views</c-><c- o>::</c-><c- n>zip</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>);</c-></ins>
<ins><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>unique</c-><c- p>(</c-><c- n>zv</c-><c- p>,</c-> <c- n>key_equiv</c-><c- p>(</c-><c- n>compare</c-><c- p>)).</c-><c- n>begin</c-><c- p>();</c-></ins>
<ins><c- k>auto</c-> <c- n>dist</c-> <c- o>=</c-> <c- n>distance</c-><c- p>(</c-><c- n>zv</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>it</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-></ins>
</pre> <p></p><pre class="highlight"><ins><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>);</c-></ins>
</pre> <p>36․ <i>Preconditions:</i> <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-> <c- o>==</c-> <c- n>mapped_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> is <code class="highlight">true</code>, the elements of <code class="highlight"><c- n>key_cont</c-></code> are sorted with respect to <code class="highlight"><c- n>compare</c-></code>, and <code class="highlight"><c- n>key_cont</c-></code> contains no equal elements. </p><p>37․ <i>Effects:</i> Equivalent to: </p><pre class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>values</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>);</c->
</pre></small></blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- p>[...]</c->

    <c- c1>// [flat.multimap.cons], constructors</c->
    <c- n>flat_multimap</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->
    <c- k>explicit</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
      <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
    <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
                  <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
    <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
                  <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c-> <c- p>}</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c-> <c- p>}</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-> <c- n>fr</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>fr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>));</c-> <c- p>}</c->

<c- p>[...]</c->

    <c- c1>// [flat.multimap.cons.alloc], constructors with allocators</c->

    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- k>explicit</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
                    <del><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
                    <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></del>
                    <del><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></del>
                    <del><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
                    <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->

<c- p>[...]</c->

    <c- n>containers</c-> <c- n>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
    <c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>key_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>mapped_cont</c-><c- p>);</c->
    <ins><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>);</c-></ins>

<c- p>[...]</c->

  <c- p>};</c->

  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-></del>
           <del><c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>>></c-></del>
    <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c-></del>
      <del><c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                       <del><c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                       <del><c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>></c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                       <del><c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-></del>
           <del><c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>>></c-></del>
    <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c-></del>
      <del><c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                       <del><c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                       <del><c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>></c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>MappedContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- k>typename</c-> <c- nc>MappedContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                       <del><c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>MappedContainer</c-><c- o>></c-><c- p>;</c-></del>
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>>>></c->
    <c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <i><c- n>iter</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>>>></c->
    <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <i><c- n>iter</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>input_range</c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>></c-><c- p>,</c->
           <c- k>class</c-> <c- nc>Allocator</c-> <c- o>=</c-> <c- n>allocator</c-><c- o>&lt;</c-><c- n>byte</c-><c- o>>></c->
    <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>(),</c-> <c- n>Allocator</c-> <c- o>=</c-> <c- n>Allocator</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c->
                       <c- n>vector</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c->
                              <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>>></c-><c- p>,</c->
                       <c- n>vector</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c->
                              <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>>>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>input_range</c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
    <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c->
      <c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>></c-><c- p>,</c->
                       <c- n>vector</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c->
                              <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>key</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>>></c-><c- p>,</c->
                       <c- n>vector</c-><c- o>&lt;</c-><i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c->
                              <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <i><c- n>range</c-><c- o>-</c-><c- n>mapped</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>R</c-><c- o>>>>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Key</c-><c- p>,</c-> <c- k>class</c-> <c- nc>T</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>>></c->
    <c- n>flat_multimap</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>T</c-><c- o>>></c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>T</c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Key</c-><c- p>,</c-> <c- k>class</c-> <c- nc>T</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>>></c->
    <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>T</c-><c- o>>></c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
        <c- o>-></c-> <c- n>flat_multimap</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>T</c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
</pre></small>
   </blockquote>
   <p>Remove the whole of <a href="https://eel.is/c++draft/flat.multimap.cons">[flat.multimap.cons]</a>,
and change <a href="https://eel.is/c++draft/flat.multimap.cons.alloc">[flat.multimap.cons.alloc]</a>, as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <del><b>Constructors [flat.multimap.cons]</b></del> <p></p><pre class="highlight"><del><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
              <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
</pre> <p><del>1․ <i>Effects:</i> Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>, and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>;
sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>.</del> </p><p><del>2․ <i>Complexity:</i> Linear in <i>N</i> if the container arguments are already sorted
with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code> and otherwise <i>N</i> log <i>N</i>,
where <i>N</i> is the value of <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> </p><p></p><pre class="highlight"><del><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
              <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
</pre> <p><del>3․ <i>Effects:</i> Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>, and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>.</del> </p><p><del>4․ <i>Complexity:</i> Constant.</del> </p><p><b>Constructors with allocators [flat.multimap.cons.alloc]</b> </p><p>1․ The constructors in this subclause shall not participate in overload resolution
unless <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- p>,</c-> <c- n>Alloc</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- p>,</c-> <c- n>Alloc</c-><c- o>></c-></code> is <code class="highlight">true</code>. </p><p></p><pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
                <del><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
<del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></del>
                <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
</pre> <p><del>2․ <i>Effects:</i> Equivalent to <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]).</del> </p><p><del>3․ <i>Complexity:</i> Same as <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively.</del> </p><p></p><pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></del>
                <del><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
<del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></del>
                <del><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-></del>
                <del><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
</pre> <p><del>4․ <i>Effects:</i> Equivalent to <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]).</del> </p><p><del>5․ <i>Complexity:</i> Linear.</del> </p><p></p><pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- k>explicit</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c->
                <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c->
                <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre> <p>6․ <i>Effects:</i> Equivalent to the corresponding non-allocator constructors
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]). </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- p>[...]</c->

    <c- c1>// [flat.multiset.cons], constructors</c->
    <c- n>flat_multiset</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->
    <c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
      <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
    <del><c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
    <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-></del>
                  <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c-></del>
      <del><c- o>:</c-> <i><c- n>c</c-></i><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)),</c-> <i><c- n>compare</c-></i><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c-></del>
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
      <c- n>flat_multiset</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <i><c- n>c</c-></i><c- p>(),</c-> <i><c- n>compare</c-></i><c- p>(</c-><c- n>comp</c-><c- p>)</c->
        <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c-> <c- p>}</c->
    <c- k>template</c-><class inputiterator>
      <c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <i><c- n>c</c-></i><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>),</c-> <i><c- n>compare</c-></i><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_multiset</c-><c- p>(</c-><c- n>from_range_t</c-> <c- n>fr</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>fr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_multiset</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c->
        <c- p>{</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>));</c-> <c- p>}</c->

<c- p>[...]</c->

    <c- c1>// [flat.multiset.cons.alloc], constructors with allocators</c->

    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multiset</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_multiset</c-><c- p>(</c-><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_multiset</c-><c- p>(</c-><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-></del>
                    <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multiset</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multiset</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multiset</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_multiset</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->

<c- p>[...]</c->

    <c- n>container_type</c-> <c- n>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
    <c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del><c- p>);</c->
    <ins><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del><c- p>);</c-></ins>

<c- p>[...]</c->

  <c- p>};</c->

  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>>></c-></del>
    <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c-></del>
      <del><c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                       <del><c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>></c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>>></c-></del>
    <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c-></del>
      <del><c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                       <del><c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>></c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>value</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>>>></c->
    <c- n>flat_multiset</c-><c- p>(</c-><c- n>InputIterator</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>value</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <i><c- n>iter</c-><c- o>-</c-><c- n>value</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>value</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>>>></c->
    <c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>value</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <i><c- n>iter</c-><c- o>-</c-><c- n>value</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>input_range</c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>></c-><c- p>,</c->
           <c- k>class</c-> <c- nc>Allocator</c-> <c- o>=</c-> <c- n>allocator</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>>></c->
    <c- n>flat_multiset</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>(),</c-> <c- n>Allocator</c-> <c- o>=</c-> <c- n>Allocator</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c->
                       <c- n>vector</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c->
                              <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>>>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>input_range</c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
    <c- n>flat_multiset</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c->
      <c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>></c-><c- p>,</c->
                       <c- n>vector</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c->
                              <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>>>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Key</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>>></c->
    <c- n>flat_multiset</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Key</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_multiset</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
</class></pre></small>
   </blockquote>
   <p>Remove the whole of <a href="https://eel.is/c++draft/flat.multiset.cons">[flat.multiset.cons]</a>,
and change <a href="https://eel.is/c++draft/flat.multiset.cons.alloc">[flat.multiset.cons.alloc]</a>, as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <p><del><b>Constructors [flat.multiset.cons]</b></del> </p><p></p><pre class="highlight"><del><c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
</pre> <p><del>1․ <i>Effects:</i> Initializes <code class="highlight"><c- n>c</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>,
and sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>compare</c-></code>.</del> </p><p><del>2․ <i>Complexity:</i> Linear in <i>N</i> if <code class="highlight"><c- n>cont</c-></code> is already sorted with respect to <code class="highlight"><c- n>compare</c-></code> and otherwise <i>N</i> log <i>N</i>, where <i>N</i> is the value of <code class="highlight"><c- n>cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> </p><p><b>Constructors with allocators [flat.multiset.cons.alloc]</b> </p><p>1․ The constructors in this subclause shall not participate in overload resolution
unless <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>container_type</c-><c- p>,</c-> <c- n>Alloc</c-><c- o>></c-></code> is <code class="highlight">true</code>. </p><p></p><pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_multiset</c-><c- p>(</c-><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
<del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_multiset</c-><c- p>(</c-><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
</pre> <p><del>2․ <i>Effects:</i> Equivalent to <code class="highlight"><c- n>flat_multiset</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multiset</c-><c- p>(</c-><c- n>cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-></code> is constructed with uses-allocator construction ([allocator.uses.construction]).</del> </p><p><del>3․ <i>Complexity:</i> Same as <code class="highlight"><c- n>flat_multiset</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multiset</c-><c- p>(</c-><c- n>cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively.</del> </p><p></p><pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
<del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-></del>
                <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
</pre> <p><del>4․ <i>Effects:</i> Equivalent to <code class="highlight"><c- n>flat_multiset</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multiset</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-></code> is constructed with uses-allocator construction ([allocator.uses.construction]).</del> </p><p><del>5․ <i>Complexity:</i> Linear.</del> </p><p></p><pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_multiset</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c->
                <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre> <p>6․ <i>Effects:</i> Equivalent to the corresponding non-allocator constructors except that <code class="highlight"><c- n>c</c-></code> is
constructed with uses-allocator construction ([allocator.uses.construction]). </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> [...]<p></p> <p></p><pre class="highlight"><c- n>container_type</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
</pre> <p>10․ <i>Postconditions:</i> <code class="highlight"><c- o>*</c-><c- k>this</c-></code> is emptied, even if the function exits via an exception. </p><p>11․ <i>Returns:</i> <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>c</c-><c- p>)</c-></code>. </p><p></p><pre class="highlight"><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>cont</c-><c- p>);</c->
</pre> <p><ins>x․ <i>Effects:</i> Replaces <code class="highlight"><c- n>c</c-></code> with <code class="highlight"><c- n>cont</c-></code>, and sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>)
with respect to <code class="highlight"><c- n>compare</c-></code>.</ins> </p><p></p><pre class="highlight"><ins><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>container_type</c-> <c- n>cont</c-><c- p>);</c-></ins>
</pre> <p>12․ <i>Preconditions:</i> <del>The elements of <code class="highlight"><c- n>cont</c-></code> are</del> <ins><code class="highlight"><c- n>cont</c-></code> is</ins> sorted with respect to <code class="highlight"><c- n>compare</c-></code>. </p><p>13․ <i>Effects:</i> Equivalent to: <code class="highlight"><c- n>c</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>);</c-></code> </p></small></blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- p>[...]</c->

    <c- c1>// [flat.set.cons], constructors</c->
    <c- n>flat_set</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->

    <c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
      <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->

    <del><c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>

    <del><c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-></del>
                  <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c-></del>
      <del><c- o>:</c-> <i><c- n>c</c-></i><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)),</c-> <i><c- n>compare</c-></i><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c-></del>

    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
      <c- n>flat_set</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <i><c- n>c</c-></i><c- p>(),</c-> <i><c- n>compare</c-></i><c- p>(</c-><c- n>comp</c-><c- p>)</c->
        <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c-> <c- p>}</c->

    <c- k>template</c-><class inputiterator>
      <c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <i><c- n>c</c-></i><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>),</c-> <i><c- n>compare</c-></i><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->

    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_set</c-><c- p>(</c-><c- n>from_range_t</c-> <c- n>fr</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>fr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_set</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c->
        <c- p>{</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>));</c-> <c- p>}</c->

<c- p>[...]</c->

    <c- c1>// [flat.set.cons.alloc], constructors with allocators</c->

    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_set</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_set</c-><c- p>(</c-><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_set</c-><c- p>(</c-><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
      <del><c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-></del>
               <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_set</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_set</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
               <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
               <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
               <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_set</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
      <c- n>flat_set</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->

<c- p>[...]</c->

    <c- n>container_type</c-> <c- n>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
    <c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del><c- p>);</c->
    <ins><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del><c- p>);</c-></ins>

<c- p>[...]</c->

  <c- p>};</c->

  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>>></c-></del>
    <del><c- n>flat_set</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c-></del>
      <del><c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_set</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                  <del><c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>></c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_set</c-><c- p>(</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>>></c-></del>
    <del><c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c-></del>
      <del><c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-></del>
                  <del><c- n>less</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>></c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>KeyContainer</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></del>
    <del><c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c-></del>
      <del><c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>KeyContainer</c-><c- o>></c-><c- p>;</c-></del>
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>value</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>>>></c->
    <c- n>flat_set</c-><c- p>(</c-><c- n>InputIterator</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>value</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>value</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>>>></c->
    <c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>InputIterator</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><i><c- n>iter</c-><c- o>-</c-><c- n>value</c-><c- o>-</c-><c- n>type</c-></i><c- o>&lt;</c-><c- n>InputIterator</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>input_range</c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>></c-><c- p>,</c->
           <c- k>class</c-> <c- nc>Allocator</c-> <c- o>=</c-> <c- n>allocator</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>>></c->
    <c- n>flat_set</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>(),</c-> <c- n>Allocator</c-> <c- o>=</c-> <c- n>Allocator</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c->
                  <c- n>vector</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c->
                         <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>>>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>input_range</c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
    <c- n>flat_set</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-><c- p>,</c-> <c- n>Allocator</c-><c- p>)</c->
      <c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>></c-><c- p>,</c->
                  <c- n>vector</c-><c- o>&lt;</c-><c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c->
                         <i><c- n>alloc</c-><c- o>-</c-><c- n>rebind</c-></i><c- o>&lt;</c-><c- n>Allocator</c-><c- p>,</c-> <c- n>ranges</c-><c- o>::</c-><c- n>range_value_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>>>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Key</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>>></c->
    <c- n>flat_set</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
  <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Key</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Compare</c-> <c- o>=</c-> <c- n>less</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>>></c->
    <c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>Key</c-><c- o>></c-><c- p>,</c-> <c- n>Compare</c-> <c- o>=</c-> <c- n>Compare</c-><c- p>())</c->
      <c- o>-></c-> <c- n>flat_set</c-><c- o>&lt;</c-><c- n>Key</c-><c- p>,</c-> <c- n>Compare</c-><c- o>></c-><c- p>;</c->
</class></pre></small>
   </blockquote>
   <p>Remove the whole of <a href="https://eel.is/c++draft/flat.set.cons">[flat.set.cons]</a>,
and change <a href="https://eel.is/c++draft/flat.set.cons.alloc">[flat.set.cons.alloc]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <del><b>Constructors [flat.set.cons]</b></del> <p></p><pre class="highlight"><del><c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
</pre> <p><del>1․ <i>Effects:</i> Initializes <code class="highlight"><c- n>c</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>,
sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>compare</c-></code>, and finally erases all but the first element
from each group of consecutive equivalent elements.</del> </p><p><del>2․ <i>Complexity:</i> Linear in <i>N</i> if <code class="highlight"><c- n>cont</c-></code> is already sorted with respect to <code class="highlight"><c- n>compare</c-></code> and otherwise <i>N</i> log <i>N</i>, where <i>N</i> is the value of <code class="highlight"><c- n>cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> </p><p><b>Constructors with allocators [flat.set.cons.alloc]</b> </p><p>1․ The constructors in this subclause shall not participate in overload resolution
unless <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>container_type</c-><c- p>,</c-> <c- n>Alloc</c-><c- o>></c-></code> is <code class="highlight">true</code>. </p><p></p><pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_set</c-><c- p>(</c-><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
<del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_set</c-><c- p>(</c-><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
</pre> <p><del>2․ <i>Effects:</i> Equivalent to <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-></code> is constructed with uses-allocator construction ([allocator.uses.construction]).</del> </p><p><del>3․ <i>Complexity:</i> Same as <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively.</del> </p><p></p><pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
<del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></del>
  <del><c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- n>cont</c-><c- p>,</c-></del>
           <del><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></del>
</pre> <p><del>4․ <i>Effects:</i> Equivalent to <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-></code> is constructed with uses-allocator construction ([allocator.uses.construction]).</del> </p><p><del>5․ <i>Complexity:</i> Linear.</del> </p><p></p><pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
           <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c->
           <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre> <p>6․ <i>Effects:</i> Equivalent to the corresponding non-allocator constructors
except that <code class="highlight"><c- n>c</c-></code> is constructed with uses-allocator construction ([allocator.uses.construction]). </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.modifiers">[flat.set.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> [...]<p></p> <p></p><pre class="highlight"><c- n>container_type</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
</pre> <p>14․ <i>Postconditions:</i> <code class="highlight"><c- o>*</c-><c- k>this</c-></code> is emptied, even if the function exits via an exception. </p><p>15․ <i>Returns:</i> <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>c</c-><c- p>)</c-></code>. </p><p></p><pre class="highlight"><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>cont</c-><c- p>);</c->
</pre> <p><ins>x․ <i>Effects:</i> Replaces <code class="highlight"><c- n>c</c-></code> with <code class="highlight"><c- n>cont</c-></code>; sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>)
with respect to <code class="highlight"><c- n>compare</c-></code>; and finally erases all but the first element from each group of
consecutive equivalent elements.</ins> </p><p></p><pre class="highlight"><ins><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>container_type</c-> <c- n>cont</c-><c- p>);</c-></ins>
</pre> <p>16․ <i>Preconditions:</i> <del>The elements of <code class="highlight"><c- n>cont</c-></code> are</del> <ins><code class="highlight"><c- n>cont</c-></code> is</ins> sorted with respect to <code class="highlight"><c- n>compare</c-></code>, and <code class="highlight"><c- n>cont</c-></code> contains no <del>equal</del> <ins>equivalent</ins> elements. </p><p>17․ <i>Effects:</i> Equivalent to: <code class="highlight"><c- n>c</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>);</c-></code> </p></small></blockquote>
   <h2 class="heading settled" data-level="15" id="experience"><span class="secno">15. </span><span class="content">Implementation experience</span><a class="self-link" href="#experience"></a></h2>
   <p>I have implemented all of <a data-link-type="biblio" href="#biblio-p0429" title="A standard flat_map">[P0429]</a>/<a data-link-type="biblio" href="#biblio-p1222" title="A standard flat_set">[P1222]</a> and all of this proposal
as a series of patches against libc++ trunk; see <a data-link-type="biblio" href="#biblio-patch" title="[libc++] trivially_relocatable branch">[Patch]</a>.
You can experiment with it <a href="https://godbolt.org/z/Trneaj4Mo">on Godbolt Compiler Explorer</a>;
just use the P1144 branch of Clang, which uses this patched libc++ by default.</p>
   <h2 class="heading settled" data-level="16" id="acknowledgments"><span class="secno">16. </span><span class="content">Acknowledgments</span><a class="self-link" href="#acknowledgments"></a></h2>
   <ul>
    <li data-md>
     <p>Thanks to Tomasz Kamiński for recommending Arthur write this paper.</p>
    <li data-md>
     <p>Thanks to Louis Dionne for his code review of libc++'s <code class="highlight"><c- n>flat_set</c-></code> implementation.</p>
   </ul>
  </main>
<script>
(function() {
  "use strict";
  var collapseSidebarText = '<span aria-hidden="true">←</span> '
                          + '<span>Collapse Sidebar</span>';
  var expandSidebarText   = '<span aria-hidden="true">→</span> '
                          + '<span>Pop Out Sidebar</span>';
  var tocJumpText         = '<span aria-hidden="true">↑</span> '
                          + '<span>Jump to Table of Contents</span>';

  var sidebarMedia = window.matchMedia('screen and (min-width: 78em)');
  var autoToggle   = function(e){ toggleSidebar(e.matches) };
  if(sidebarMedia.addListener) {
    sidebarMedia.addListener(autoToggle);
  }

  function toggleSidebar(on) {
    if (on == undefined) {
      on = !document.body.classList.contains('toc-sidebar');
    }

    /* Don’t scroll to compensate for the ToC if we’re above it already. */
    var headY = 0;
    var head = document.querySelector('.head');
    if (head) {
      // terrible approx of "top of ToC"
      headY += head.offsetTop + head.offsetHeight;
    }
    var skipScroll = window.scrollY < headY;

    var toggle = document.getElementById('toc-toggle');
    var tocNav = document.getElementById('toc');
    if (on) {
      var tocHeight = tocNav.offsetHeight;
      document.body.classList.add('toc-sidebar');
      document.body.classList.remove('toc-inline');
      toggle.innerHTML = collapseSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, 0 - tocHeight);
      }
      tocNav.focus();
      sidebarMedia.addListener(autoToggle); // auto-collapse when out of room
    }
    else {
      document.body.classList.add('toc-inline');
      document.body.classList.remove('toc-sidebar');
      toggle.innerHTML = expandSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, tocNav.offsetHeight);
      }
      if (toggle.matches(':hover')) {
        /* Unfocus button when not using keyboard navigation,
           because I don’t know where else to send the focus. */
        toggle.blur();
      }
    }
  }

  function createSidebarToggle() {
    /* Create the sidebar toggle in JS; it shouldn’t exist when JS is off. */
    var toggle = document.createElement('a');
      /* This should probably be a button, but appearance isn’t standards-track.*/
    toggle.id = 'toc-toggle';
    toggle.class = 'toc-toggle';
    toggle.href = '#toc';
    toggle.innerHTML = collapseSidebarText;

    sidebarMedia.addListener(autoToggle);
    var toggler = function(e) {
      e.preventDefault();
      sidebarMedia.removeListener(autoToggle); // persist explicit off states
      toggleSidebar();
      return false;
    }
    toggle.addEventListener('click', toggler, false);


    /* Get <nav id=toc-nav>, or make it if we don’t have one. */
    var tocNav = document.getElementById('toc-nav');
    if (!tocNav) {
      tocNav = document.createElement('p');
      tocNav.id = 'toc-nav';
      /* Prepend for better keyboard navigation */
      document.body.insertBefore(tocNav, document.body.firstChild);
    }
    /* While we’re at it, make sure we have a Jump to Toc link. */
    var tocJump = document.getElementById('toc-jump');
    if (!tocJump) {
      tocJump = document.createElement('a');
      tocJump.id = 'toc-jump';
      tocJump.href = '#toc';
      tocJump.innerHTML = tocJumpText;
      tocNav.appendChild(tocJump);
    }

    tocNav.appendChild(toggle);
  }

  var toc = document.getElementById('toc');
  if (toc) {
    createSidebarToggle();
    toggleSidebar(sidebarMedia.matches);

    /* If the sidebar has been manually opened and is currently overlaying the text
       (window too small for the MQ to add the margin to body),
       then auto-close the sidebar once you click on something in there. */
    toc.addEventListener('click', function(e) {
      if(e.target.tagName.toLowerCase() == "a" && document.body.classList.contains('toc-sidebar') && !sidebarMedia.matches) {
        toggleSidebar(false);
      }
    }, false);
  }
  else {
    console.warn("Can’t find Table of Contents. Please use <nav id='toc'> around the ToC.");
  }

  /* Wrap tables in case they overflow */
  var tables = document.querySelectorAll(':not(.overlarge) > table.data, :not(.overlarge) > table.index');
  var numTables = tables.length;
  for (var i = 0; i < numTables; i++) {
    var table = tables[i];
    var wrapper = document.createElement('div');
    wrapper.className = 'overlarge';
    table.parentNode.insertBefore(wrapper, table);
    wrapper.appendChild(table);
  }

})();
</script>
  <h2 class="no-num no-ref heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>
  <h3 class="no-num no-ref heading settled" id="informative"><span class="content">Informative References</span><a class="self-link" href="#informative"></a></h3>
  <dl>
   <dt id="biblio-lwg2227">[LWG2227]
   <dd>Juan Soulie. <a href="https://cplusplus.github.io/LWG/issue2227"><cite>Stateful comparison objects in associative containers</cite></a>. December 2012. URL: <a href="https://cplusplus.github.io/LWG/issue2227">https://cplusplus.github.io/LWG/issue2227</a>
   <dt id="biblio-lwg3802">[LWG3802]
   <dd>Arthur O'Dwyer. <a href="https://cplusplus.github.io/LWG/issue3802"><cite>flat_foo allocator-extended constructors lack move semantics</cite></a>. October 2022. URL: <a href="https://cplusplus.github.io/LWG/issue3802">https://cplusplus.github.io/LWG/issue3802</a>
   <dt id="biblio-lwg3803">[LWG3803]
   <dd>Arthur O'Dwyer. <a href="https://cplusplus.github.io/LWG/issue3803"><cite>flat_foo constructors taking KeyContainer lack KeyCompare parameter</cite></a>. October 2022. URL: <a href="https://cplusplus.github.io/LWG/issue3803">https://cplusplus.github.io/LWG/issue3803</a>
   <dt id="biblio-lwg3884">[LWG3884]
   <dd>Arthur O'Dwyer. <a href="https://cplusplus.github.io/LWG/issue3884"><cite>flat_foo is missing allocator-extended copy/move constructors</cite></a>. February 2023. URL: <a href="https://cplusplus.github.io/LWG/issue3884">https://cplusplus.github.io/LWG/issue3884</a>
   <dt id="biblio-p0429">[P0429]
   <dd>Zach Laine. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf"><cite>A standard flat_map</cite></a>. June 2022. URL: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf</a>
   <dt id="biblio-p1163">[P1163]
   <dd>Nevin Liber. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1163r0.pdf"><cite>Explicitly implicifying explicit constructors</cite></a>. August 2018. URL: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1163r0.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1163r0.pdf</a>
   <dt id="biblio-p1222">[P1222]
   <dd>Zach Laine. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf"><cite>A standard flat_set</cite></a>. June 2022. URL: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf</a>
   <dt id="biblio-p2363">[P2363]
   <dd>Konstantin Boyarinov; Sergey Vinogradov; Ruslan Arutyunyan. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html"><cite>Extending associative containers with the remaining heterogeneous overloads</cite></a>. February 2023. URL: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html</a>
   <dt id="biblio-patch">[Patch]
   <dd>Arthur O'Dwyer. <a href="https://github.com/Quuxplusone/llvm-project/compare/main...trivially-relocatable"><cite>[libc++] trivially_relocatable branch</cite></a>. May 2023. URL: <a href="https://github.com/Quuxplusone/llvm-project/compare/main...trivially-relocatable">https://github.com/Quuxplusone/llvm-project/compare/main...trivially-relocatable</a>
  </dl>