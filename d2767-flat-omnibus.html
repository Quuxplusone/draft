<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>D2767R0: flat_map/flat_set omnibus</title>
<style data-fill-with="stylesheet">/******************************************************************************
 *                   Style sheet for the W3C specifications                   *
 *
 * Special classes handled by this style sheet include:
 *
 * Indices
 *   - .toc for the Table of Contents (<ol class="toc">)
 *     + <span class="secno"> for the section numbers
 *   - #toc for the Table of Contents (<nav id="toc">)
 *   - ul.index for Indices (<a href="#ref">term</a><span>, in § N.M</span>)
 *   - table.index for Index Tables (e.g. for properties or elements)
 *
 * Structural Markup
 *   - table.data for general data tables
 *     -> use 'scope' attribute, <colgroup>, <thead>, and <tbody> for best results !
 *     -> use <table class='complex data'> for extra-complex tables
 *     -> use <td class='long'> for paragraph-length cell content
 *     -> use <td class='pre'> when manual line breaks/indentation would help readability
 *   - dl.switch for switch statements
 *   - ol.algorithm for algorithms (helps to visualize nesting)
 *   - .figure and .caption (HTML4) and figure and figcaption (HTML5)
 *     -> .sidefigure for right-floated figures
 *   - ins/del
 *     -> ins/del.c### for candidate and proposed changes (amendments)
 *
 * Code
 *   - pre and code
 *
 * Special Sections
 *   - .note       for informative notes             (div, p, span, aside, details)
 *   - .example    for informative examples          (div, p, pre, span)
 *   - .issue      for issues                        (div, p, span)
 *   - .advisement for loud normative statements     (div, p, strong)
 *   - .annoying-warning for spec obsoletion notices (div, aside, details)
 *   - .correction for "candidate corrections"       (div, aside, details, section)
 *   - .addition   for "candidate additions"         (div, aside, details, section)
 *   - .correction.proposed for "proposed corrections" (div, aside, details, section)
 *   - .addition.proposed   for "proposed additions"   (div, aside, details, section)
 *
 * Definition Boxes
 *   - pre.def   for WebIDL definitions
 *   - table.def for tables that define other entities (e.g. CSS properties)
 *   - dl.def    for definition lists that define other entitles (e.g. HTML elements)
 *
 * Numbering
 *   - .secno for section numbers in .toc and headings (<span class='secno'>3.2</span>)
 *   - .marker for source-inserted example/figure/issue numbers (<span class='marker'>Issue 4</span>)
 *   - ::before styled for CSS-generated issue/example/figure numbers:
 *     -> Documents wishing to use this only need to add
 *        figcaption::before,
 *        .caption::before { content: "Figure "  counter(figure) " ";  }
 *        .example::before { content: "Example " counter(example) " "; }
 *        .issue::before   { content: "Issue "   counter(issue) " ";   }
 *
 * Header Stuff (ignore, just don't conflict with these classes)
 *   - .head for the header
 *   - .copyright for the copyright
 *
 * Outdated warning for old specs
 *
 * Miscellaneous
 *   - .overlarge for things that should be as wide as possible, even if
 *     that overflows the body text area. This can be used on an item or
 *     on its container, depending on the effect desired.
 *     Note that this styling basically doesn't help at all when printing,
 *     since A4 paper isn't much wider than the max-width here.
 *     It's better to design things to fit into a narrower measure if possible.
 *
 *   - js-added ToC jump links (see fixup.js)
 *
 ******************************************************************************/

/* color variables included separately for reliability */

/******************************************************************************/
/*                                    Body                                    */
/******************************************************************************/

	html {
	}

	body {
		counter-reset: example figure issue;

		/* Layout */
		max-width: 50em;			  /* limit line length to 50em for readability   */
		margin: 0 auto;				/* center text within page                    */
		padding: 1.6em 1.5em 2em 50px; /* assume 16px font size for downlevel clients */
		padding: 1.6em 1.5em 2em calc(26px + 1.5em); /* leave space for status flag    */

		/* Typography */
		line-height: 1.5;
		font-family: sans-serif;
		widows: 2;
		orphans: 2;
		word-wrap: break-word;
		overflow-wrap: break-word;
		hyphens: auto;

		color: black;
		color: var(--text);
		background: white top left fixed no-repeat;
		background: var(--bg) top left fixed no-repeat;
		background-size: 25px auto;
	}


/******************************************************************************/
/*                         Front Matter & Navigation                          */
/******************************************************************************/

/** Header ********************************************************************/

	div.head { margin-bottom: 1em; }
	div.head hr { border-style: solid; }

	div.head h1 {
		font-weight: bold;
		margin: 0 0 .1em;
		font-size: 220%;
	}

	div.head h2 { margin-bottom: 1.5em;}

/** W3C Logo ******************************************************************/

	.head .logo {
		float: right;
		margin: 0.4rem 0 0.2rem .4rem;
	}

	.head img[src*="logos/W3C"] {
		display: block;
		border: solid #1a5e9a;
		border: solid var(--logo-bg);
		border-width: .65rem .7rem .6rem;
		border-radius: .4rem;
		background: #1a5e9a;
		background: var(--logo-bg);
		color: white;
		color: var(--logo-text);
		font-weight: bold;
	}

	.head a:hover > img[src*="logos/W3C"],
	.head a:focus > img[src*="logos/W3C"] {
		opacity: .8;
	}

	.head a:active > img[src*="logos/W3C"] {
		background: #c00;
		background: var(--logo-active-bg);
		border-color: #c00;
		border-color: var(--logo-active-bg);
	}

	/* see also additional rules in Link Styling section */

/** Copyright *****************************************************************/

	p.copyright,
	p.copyright small { font-size: small; }

/** Back to Top / ToC Toggle **************************************************/

	@media print {
		#toc-nav {
			display: none;
		}
	}
	@media not print {
		#toc-nav {
			position: fixed;
			z-index: 3;
			bottom: 0; left: 0;
			margin: 0;
			min-width: 1.33em;
			border-top-right-radius: 2rem;
			box-shadow: 0 0 2px;
			font-size: 1.5em;
		}
		#toc-nav > a {
			display: block;
			white-space: nowrap;

			height: 1.33em;
			padding: .1em 0.3em;
			margin: 0;

			box-shadow: 0 0 2px;
			border: none;
			border-top-right-radius: 1.33em;

			color: #707070;
			color: var(--tocnav-normal-text);
			background: white;
			background: var(--tocnav-normal-bg);
		}
		#toc-nav > a:hover,
		#toc-nav > a:focus {
			color: black;
			color: var(--tocnav-hover-text);
			background: #f8f8f8;
			background: var(--tocnav-hover-bg);
		}
		#toc-nav > a:active {
			color: #c00;
			color: var(--tocnav-active-text);
			background: white;
			background: var(--tocnav-active-bg);
		}

		#toc-nav > #toc-jump {
			padding-bottom: 2em;
			margin-bottom: -1.9em;
		}

		/* statusbar gets in the way on keyboard focus; remove once browsers fix */
		#toc-nav > a[href="#toc"]:not(:hover):focus:last-child {
			padding-bottom: 1.5rem;
		}

		#toc-nav:not(:hover) > a:not(:focus) > span + span {
			/* Ideally this uses :focus-within on #toc-nav */
			display: none;
		}
		#toc-nav > a > span + span {
			padding-right: 0.2em;
		}
	}

/** ToC Sidebar ***************************************************************/

	/* Floating sidebar */
	@media screen {
		body.toc-sidebar #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			max-width: 80%;
			max-width: calc(100% - 2em - 26px);
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			color: black;
			color: var(--tocsidebar-text);
			background: inherit;
			background-color: #f7f8f9;
			background-color: var(--tocsidebar-bg);
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
			box-shadow: -.1em 0 .25em var(--tocsidebar-shadow) inset;
		}
		body.toc-sidebar #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
			color: var(--tocsidebar-heading-text);
		}
		body.toc-sidebar #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	/* Hide main scroller when only the ToC is visible anyway */
	@media screen and (max-width: 28em) {
		body.toc-sidebar {
			overflow: hidden;
		}
	}

	/* Sidebar with its own space */
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			color: black;
			color: var(--tocsidebar-text);
			background: inherit;
			background-color: #f7f8f9;
			background-color: var(--tocsidebar-bg);
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
			box-shadow: -.1em 0 .25em var(--tocsidebar-shadow) inset;
		}
		body:not(.toc-inline) #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
			color: var(--tocsidebar-heading-text);
		}

		body:not(.toc-inline) {
			padding-left: 29em;
		}
		/* See also Overflow section at the bottom */

		body:not(.toc-inline) #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) {
			margin: 0 4em;
		}
	}

/******************************************************************************/
/*                                Sectioning                                  */
/******************************************************************************/

/** Headings ******************************************************************/

	h1, h2, h3, h4, h5, h6, dt {
		page-break-after: avoid;
		page-break-inside: avoid;
		font: 100% sans-serif;   /* Reset all font styling to clear out UA styles */
		font-family: inherit;	/* Inherit the font family. */
		line-height: 1.2;		/* Keep wrapped headings compact */
		hyphens: manual;		/* Hyphenated headings look weird */
	}

	h2, h3, h4, h5, h6 {
		margin-top: 3rem;
	}

	h1, h2, h3 {
		color: #005A9C;
		color: var(--heading-text);
	}

	h1 { font-size: 170%; }
	h2 { font-size: 140%; }
	h3 { font-size: 120%; }
	h4 { font-weight: bold; }
	h5 { font-style: italic; }
	h6 { font-variant: small-caps; }
	dt { font-weight: bold; }

/** Subheadings ***************************************************************/

	h1 + h2,
	#profile-and-date {
		/* #profile-and-date is a subtitle in an H2 under the H1 */
		margin-top: 0;
	}
	h2 + h3,
	h3 + h4,
	h4 + h5,
	h5 + h6 {
		margin-top: 1.2em; /* = 1 x line-height */
	}

/** Section divider ***********************************************************/

	:not(.head) > :not(.head) + hr {
		font-size: 1.5em;
		text-align: center;
		margin: 1em auto;
		height: auto;
		color: black;
		color: var(--hr-text);
		border: transparent solid 0;
		background: transparent;
	}
	:not(.head) > hr::before {
		content: "\2727\2003\2003\2727\2003\2003\2727";
	}

/******************************************************************************/
/*                            Paragraphs and Lists                            */
/******************************************************************************/

	p {
		margin: 1em 0;
	}

	dd > p:first-child,
	li > p:first-child {
		margin-top: 0;
	}

	ul, ol {
		margin-left: 0;
		padding-left: 2em;
	}

	li {
		margin: 0.25em 0 0.5em;
		padding: 0;
	}

	dl dd {
		margin: 0 0 .5em 2em;
	}

	.head dd + dd { /* compact for header */
		margin-top: -.5em;
	}

	/* Style for algorithms */
	ol.algorithm ol:not(.algorithm),
	.algorithm > ol ol:not(.algorithm) {
	border-left: 0.5em solid #DEF;
	border-left: 0.5em solid var(--algo-border);
	}

	/* Put nice boxes around each algorithm. */
	[data-algorithm]:not(.heading) {
	 padding: .5em;
	 border: thin solid #ddd;
	 border: thin solid var(--algo-border);
	 border-radius: .5em;
	 margin: .5em calc(-0.5em - 1px);
	}
	[data-algorithm]:not(.heading) > :first-child {
	 margin-top: 0;
	}
	[data-algorithm]:not(.heading) > :last-child {
	 margin-bottom: 0;
	}

	/* Style for switch/case <dl>s */
	dl.switch > dd > ol.only,
	dl.switch > dd > .only > ol {
	margin-left: 0;
	}
	dl.switch > dd > ol.algorithm,
	dl.switch > dd > .algorithm > ol {
	margin-left: -2em;
	}
	dl.switch {
	padding-left: 2em;
	}
	dl.switch > dt {
	text-indent: -1.5em;
	margin-top: 1em;
	}
	dl.switch > dt + dt {
	margin-top: 0;
	}
	dl.switch > dt::before {
	content: '\21AA';
	padding: 0 0.5em 0 0;
	display: inline-block;
	width: 1em;
	text-align: right;
	line-height: 0.5em;
	}

/** Terminology Markup ********************************************************/


/******************************************************************************/
/*                                 Inline Markup                              */
/******************************************************************************/

/** Terminology Markup ********************************************************/
	dfn   { /* Defining instance */
		font-weight: bolder;
	}
	a > i { /* Instance of term */
		font-style: normal;
	}
	dt dfn code, code.idl {
		font-size: inherit;
	}
	dfn var {
		font-style: normal;
	}

/** Change Marking ************************************************************/

	del {
		color: #aa0000;
		color: var(--del-text);
		background: transparent;
		background: var(--del-bg);
		text-decoration: line-through;
	}
	ins {
		color: #006100;
		color: var(--ins-text);
		background: transparent;
		background: var(--ins-bg);
		text-decoration: underline;
	}

	/* for amendments (candidate/proposed changes) */

	.amendment ins, .correction ins, .addition ins,
	ins[class^=c] {
		text-decoration-style: dotted;
	}
	.amendment del, .correction del, .addition del,
	del[class^=c] {
		text-decoration-style: dotted;
	}
	.amendment.proposed ins, .correction.proposed ins, .addition.proposed ins,
	ins[class^=c].proposed {
		text-decoration-style: double;
	}
	.amendment.proposed del, .correction.proposed del, .addition.proposed del,
	del[class^=c].proposed {
		text-decoration-style: double;
	}

/** Miscellaneous improvements to inline formatting ***************************/

	sup {
		vertical-align: super;
		font-size: 80%
	}

/******************************************************************************/
/*                                    Code                                    */
/******************************************************************************/

/** General monospace/pre rules ***********************************************/

	pre, code, samp {
		font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
		font-size: .9em;
		hyphens: none;
		text-transform: none;
		text-align: left;
		text-align: start;
		font-variant: normal;
		orphans: 3;
		widows: 3;
		page-break-before: avoid;
	}
	pre code,
	code code {
		font-size: 100%;
	}

	pre {
		margin-top: 1em;
		margin-bottom: 1em;
		overflow: auto;
	}

/** Inline Code fragments *****************************************************/

	/* Do something nice. */

/******************************************************************************/
/*                                    Links                                   */
/******************************************************************************/

/** General Hyperlinks ********************************************************/

	/* We hyperlink a lot, so make it less intrusive */
	a[href] {
		color: #034575;
		color: var(--a-normal-text);
		text-decoration: underline #707070;
		text-decoration: underline var(--a-normal-underline);
		text-decoration-skip-ink: none;
	}
	a:visited {
		color: #034575;
		color: var(--a-visited-text);
		text-decoration-color: #bbb;
		text-decoration-color: var(--a-visited-underline);
	}

	/* Indicate interaction with the link */
	a[href]:focus,
	a[href]:hover {
		text-decoration-thickness: 2px;
	}
	a[href]:active {
		color: #c00;
		color: var(--a-active-text);
		text-decoration-color: #c00;
		text-decoration-color: var(--a-active-underline);
	}

	/* Backout above styling for W3C logo */
	.head .logo,
	.head .logo a {
		border: none;
		text-decoration: none;
		background: transparent;
	}

/******************************************************************************/
/*                                    Images                                  */
/******************************************************************************/

	img {
		border-style: none;
	}

	img, svg {
		/* Intentionally not color-scheme aware. */
		background: white;
	}

	/* For autogen numbers, add
	  .caption::before, figcaption::before { content: "Figure " counter(figure) ". "; }
	*/

	figure, .figure, .sidefigure {
		page-break-inside: avoid;
		text-align: center;
		margin: 2.5em 0;
	}
	.figure img,	.sidefigure img,	figure img,
	.figure object, .sidefigure object, figure object {
		max-width: 100%;
		margin: auto;
		height: auto;
	}
	.figure pre, .sidefigure pre, figure pre {
		text-align: left;
		display: table;
		margin: 1em auto;
	}
	.figure table, figure table {
		margin: auto;
	}
	@media screen and (min-width: 20em) {
		.sidefigure {
			float: right;
			width: 50%;
			margin: 0 0 0.5em 0.5em;
		}
	}
	.caption, figcaption, caption {
		font-style: italic;
		font-size: 90%;
	}
	.caption::before, figcaption::before, figcaption > .marker {
		font-weight: bold;
	}
	.caption, figcaption {
		counter-increment: figure;
	}

	/* DL list is indented 2em, but figure inside it is not */
	dd > .figure, dd > figure { margin-left: -2em; }

/******************************************************************************/
/*                             Colored Boxes                                  */
/******************************************************************************/

	.issue, .note, .example, .assertion, .advisement, blockquote,
	.amendment, .correction, .addition {
		margin: 1em auto;
		padding: .5em;
		border: .5em;
		border-left-style: solid;
		page-break-inside: avoid;
	}
	span.issue, span.note {
		padding: .1em .5em .15em;
		border-right-style: solid;
	}

	blockquote > :first-child,
	.note  > p:first-child,
	.issue > p:first-child,
	.amendment > p:first-child,
	.correction > p:first-child,
	.addition > p:first-child {
		margin-top: 0;
	}
	blockquote > :last-child,
	.note  > p:last-child,
	.issue > p:last-child,
	.amendment > p:last-child,
	.correction > p:last-child,
	.addition > p:last-child {
		margin-bottom: 0;
	}


	.issue::before, .issue > .marker,
	.example::before, .example > .marker,
	.note::before, .note > .marker,
	details.note > summary > .marker,
	.amendment::before, .amendment > .marker,
	details.amendment > summary > .marker,
	.addition::before, .addition > .marker,
	addition.amendment > summary > .marker,
	.correction::before, .correction > .marker,
	correction.amendment > summary > .marker
	{
		text-transform: uppercase;
		padding-right: 1em;
	}

	.example::before, .example > .marker {
		display: block;
		padding-right: 0em;
	}

/** Blockquotes ***************************************************************/

	blockquote {
		border-color: silver;
		border-color: var(--blockquote-border);
		background: transparent;
		background: var(--blockquote-bg);
		color: currentcolor;
		color: var(--blockquote-text);
	}

/** Open issue ****************************************************************/

	.issue {
		border-color: #e05252;
		border-color: var(--issue-border);
		background: #fbe9e9;
		background: var(--issue-bg);
		color: black;
		color: var(--issue-text);
		counter-increment: issue;
		overflow: auto;
	}
	.issue::before, .issue > .marker {
		color: #831616;
		color: var(--issueheading-text);
	}
	/* Add .issue::before { content: "Issue " counter(issue) " "; } for autogen numbers,
	  or use class="marker" to mark up the issue number in source. */

/** Example *******************************************************************/

	.example {
		border-color: #e0cb52;
		border-color: var(--example-border);
		background: #fcfaee;
		background: var(--example-bg);
		color: black;
		color: var(--example-text);
		counter-increment: example;
		overflow: auto;
		clear: both;
	}
	.example::before, .example > .marker {
		color: #574b0f;
		color: var(--exampleheading-text);
	}
	/* Add .example::before { content: "Example " counter(example) " "; } for autogen numbers,
	  or use class="marker" to mark up the example number in source. */

/** Non-normative Note ********************************************************/

	.note {
		border-color: #52e052;
		border-color: var(--note-border);
		background: #e9fbe9;
		background: var(--note-bg);
		color: black;
		color: var(--note-text);
		overflow: auto;
	}

	.note::before, .note > .marker,
	details.note > summary {
		color: hsl(120, 70%, 30%);
		color: var(--noteheading-text);
	}
	/* Add .note::before { content: "Note "; } for autogen label,
	  or use class="marker" to mark up the label in source. */

	details.note[open] > summary {
		border-bottom: 1px silver solid;
		border-bottom: 1px var(--notesummary-underline) solid;
	}

/** Assertion Box *************************************************************/
	/*  for assertions in algorithms */

	.assertion {
		border-color: #AAA;
		border-color: var(--assertion-border);
		background: #EEE;
		background: var(--assertion-bg);
		color: black;
		color: var(--assertion-text);
	}

/** Advisement Box ************************************************************/
	/*  for attention-grabbing normative statements */

	.advisement {
		border-color: orange;
		border-color: var(--advisement-border);
		border-style: none solid;
		background: #fec;
		background: var(--advisement-bg);
		color: black;
		color: var(--advisement-text);
	}
	strong.advisement {
		display: block;
		text-align: center;
	}
	.advisement::before, .advisement > .marker {
		color: #b35f00;
		color: var(--advisementheading-text);
	}

/** Amendment Box *************************************************************/

	.amendment, .correction, .addition {
		border-color: #330099;
		border-color: var(--amendment-border);
		background: #F5F0FF;
		background: var(--amendment-bg);
		color: black;
		color: var(--amendment-text);
	}
	.amendment.proposed, .correction.proposed, .addition.proposed {
		border-style: solid;
		border-block-width: 0.25em;
	}
	.amendment::before, .amendment > .marker,
	details.amendment > summary::before, details.amendment > summary > .marker,
	.correction::before, .correction > .marker,
	details.correction > summary::before, details.correction > summary > .marker,
	.addition::before, .addition > .marker,
	details.addition > summary::before, details.addition > summary > .marker {
		color: #220066;
		color: var(--amendmentheading-text);
	}
	.amendment.proposed::before, .amendment.proposed > .marker,
	details.amendment.proposed > summary::before, details.amendment.proposed > summary > .marker,
	.correction.proposed::before, .correction.proposed > .marker,
	details.correction.proposed > summary::before, details.correction.proposed > summary > .marker,
	.addition.proposed::before, .addition.proposed > .marker,
	details.addition.proposed > summary::before, details.addition.proposed > summary > .marker {
		font-weight: bold;
	}

/** Spec Obsoletion Notice ****************************************************/
	/* obnoxious obsoletion notice for older/abandoned specs. */

	details {
		display: block;
	}
	summary {
		font-weight: bolder;
	}

	.annoying-warning:not(details),
	details.annoying-warning:not([open]) > summary,
	details.annoying-warning[open] {
		background: hsla(40,100%,50%,0.95);
		background: var(--warning-bg);
		color: black;
		color: var(--warning-text);
		padding: .75em 1em;
		border: red;
		border: var(--warning-border);
		border-style: solid none;
		box-shadow: 0 2px 8px black;
		text-align: center;
	}
	.annoying-warning :last-child {
		margin-bottom: 0;
	}

@media not print {
	details.annoying-warning[open] {
		position: fixed;
		left: 0;
		right: 0;
		bottom: 2em;
		z-index: 1000;
	}
}

	details.annoying-warning:not([open]) > summary {
		text-align: center;
	}

/** Entity Definition Boxes ***************************************************/

	.def {
		padding: .5em 1em;
		background: #def;
		background: var(--def-bg);
		margin: 1.2em 0;
		border-left: 0.5em solid #8ccbf2;
		border-left: 0.5em solid var(--def-border);
		color: black;
		color: var(--def-text);
	}

/******************************************************************************/
/*                                    Tables                                  */
/******************************************************************************/

	th, td {
		text-align: left;
		text-align: start;
	}

/** Property/Descriptor Definition Tables *************************************/

	table.def {
		/* inherits .def box styling, see above */
		width: 100%;
		border-spacing: 0;
	}

	table.def td,
	table.def th {
		padding: 0.5em;
		vertical-align: baseline;
		border-bottom: 1px solid #bbd7e9;
		border-bottom: 1px solid var(--defrow-border);
	}

	table.def > tbody > tr:last-child th,
	table.def > tbody > tr:last-child td {
		border-bottom: 0;
	}

	table.def th {
		font-style: italic;
		font-weight: normal;
		padding-left: 1em;
		width: 3em;
	}

	/* For when values are extra-complex and need formatting for readability */
	table td.pre {
		white-space: pre-wrap;
	}

	/* A footnote at the bottom of a def table */
	table.def td.footnote {
		padding-top: 0.6em;
	}
	table.def td.footnote::before {
		content: " ";
		display: block;
		height: 0.6em;
		width: 4em;
		border-top: thin solid;
	}

/** Data tables (and properly marked-up index tables) *************************/
	/*
		<table class="data"> highlights structural relationships in a table
		when correct markup is used (e.g. thead/tbody, th vs. td, scope attribute)

		Use class="complex data" for particularly complicated tables --
		(This will draw more lines: busier, but clearer.)

		Use class="long" on table cells with paragraph-like contents
		(This will adjust text alignment accordingly.)
		Alternately use class="longlastcol" on tables, to have the last column assume "long".
	*/

	table {
		word-wrap: normal;
		overflow-wrap: normal;
		hyphens: manual;
	}

	table.data,
	table.index {
		margin: 1em auto;
		border-collapse: collapse;
		border: hidden;
		width: 100%;
	}
	table.data caption,
	table.index caption {
		max-width: 50em;
		margin: 0 auto 1em;
	}

	table.data td,  table.data th,
	table.index td, table.index th {
		padding: 0.5em 1em;
		border-width: 1px;
		border-color: silver;
		border-color: var(--datacell-border);
		border-top-style: solid;
	}

	table.data thead td:empty {
		padding: 0;
		border: 0;
	}

	table.data  thead,
	table.index thead,
	table.data  tbody,
	table.index tbody {
		border-bottom: 2px solid;
	}

	table.data colgroup,
	table.index colgroup {
		border-left: 2px solid;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		border-right: 2px solid;
		border-top: 1px solid silver;
		border-top: 1px solid var(--datacell-border);
		padding-right: 1em;
	}

	table.data th[colspan],
	table.data td[colspan] {
		text-align: center;
	}

	table.complex.data th,
	table.complex.data td {
		border: 1px solid silver;
		border: 1px solid var(--datacell-border);
		text-align: center;
	}

	table.data.longlastcol td:last-child,
	table.data td.long {
		vertical-align: baseline;
		text-align: left;
	}

	table.data img {
		vertical-align: middle;
	}


/*
Alternate table alignment rules

	table.data,
	table.index {
		text-align: center;
	}

	table.data  thead th[scope="row"],
	table.index thead th[scope="row"] {
		text-align: right;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		text-align: right;
	}

Possible extra rowspan handling

	table.data  tbody th[rowspan]:not([rowspan='1']),
	table.index tbody th[rowspan]:not([rowspan='1']),
	table.data  tbody td[rowspan]:not([rowspan='1']),
	table.index tbody td[rowspan]:not([rowspan='1']) {
		border-left: 1px solid silver;
	}

	table.data  tbody th[rowspan]:first-child,
	table.index tbody th[rowspan]:first-child,
	table.data  tbody td[rowspan]:first-child,
	table.index tbody td[rowspan]:first-child{
		border-left: 0;
		border-right: 1px solid silver;
	}
*/

/******************************************************************************/
/*                                  Indices                                   */
/******************************************************************************/


/** Table of Contents *********************************************************/

	.toc a {
		/* More spacing; use padding to make it part of the click target. */
		padding: 0.1rem 1px 0;
		/* Larger, more consistently-sized click target */
		display: block;
		/* Switch to using border-bottom for underlines */
		text-decoration: none;
		border-bottom: 1px solid;
		/* Reverse color scheme */
		color: black;
		color: var(--toclink-text);
		border-color: #3980b5;
		border-color: var(--toclink-underline);
	}
	.toc a:visited {
		color: black;
		color: var(--toclink-visited-text);
		border-color: #054572;
		border-color: var(--toclink-visited-underline);
	}
	.toc a:focus,
	.toc a:hover {
		background: rgba(75%, 75%, 75%, .25);
		background: var(--a-hover-bg);
		border-bottom-width: 3px;
		margin-bottom: -2px;
	}
	.toc a:not(:focus):not(:hover) {
		/* Allow colors to cascade through from link styling */
		border-bottom-color: transparent;
	}

	.toc, .toc ol, .toc ul, .toc li {
		list-style: none; /* Numbers must be inlined into source */
		/* because generated content isn't search/selectable and markers can't do multilevel yet */
		margin:  0;
		padding: 0;
	}
	.toc {
		line-height: 1.1em;
	}

	/* ToC not indented until third level, but font style & margins show hierarchy */
	.toc > li			{ font-weight: bold;   }
	.toc > li li		 { font-weight: normal; }
	.toc > li li li	  { font-size:   95%;	}
	.toc > li li li li	{ font-size:   90%;	}
	.toc > li li li li li { font-size:   85%;	}

	/* @supports not (display:grid) { */
		.toc > li			{ margin: 1.5rem 0;	}
		.toc > li li		 { margin: 0.3rem 0;	}
		.toc > li li li	  { margin-left: 2rem;   }

		/* Section numbers in a column of their own */
		.toc .secno {
			float: left;
			width: 4rem;
			white-space: nowrap;
		}
		.toc > li li li li .secno { font-size: 85%; }
		.toc > li li li li li .secno { font-size: 100%; }

		.toc li {
			clear: both;
		}

		:not(li) > .toc			 { margin-left:  5rem; }
		.toc .secno				 { margin-left: -5rem; }
		.toc > li li li .secno	  { margin-left: -7rem; }
		.toc > li li li li .secno	{ margin-left: -9rem; }
		.toc > li li li li li .secno { margin-left: -11rem; }

		/* Tighten up indentation in narrow ToCs */
		@media (max-width: 30em) {
			:not(li) > .toc			 { margin-left:  4rem; }
			.toc .secno				 { margin-left: -4rem; }
			.toc > li li li			 { margin-left:  1rem; }
			.toc > li li li .secno	  { margin-left: -5rem; }
			.toc > li li li li .secno	{ margin-left: -6rem; }
			.toc > li li li li li .secno { margin-left: -7rem; }
		}
		/* Loosen it on wide screens */
		@media screen and (min-width: 78em) {
			body:not(.toc-inline) :not(li) > .toc			 { margin-left:  4rem; }
			body:not(.toc-inline) .toc .secno				 { margin-left: -4rem; }
			body:not(.toc-inline) .toc > li li li			 { margin-left:  1rem; }
			body:not(.toc-inline) .toc > li li li .secno	  { margin-left: -5rem; }
			body:not(.toc-inline) .toc > li li li li .secno	{ margin-left: -6rem; }
			body:not(.toc-inline) .toc > li li li li li .secno { margin-left: -7rem; }
	}
	/* } */

	@supports (display:grid) and (display:contents) {
		/* Use #toc over .toc to override non-@supports rules. */
		#toc {
			display: grid;
			align-content: start;
			grid-template-columns: auto 1fr;
			grid-column-gap: 1rem;
			column-gap: 1rem;
			grid-row-gap: .6rem;
			row-gap: .6rem;
		}
		#toc h2 {
			grid-column: 1 / -1;
			margin-bottom: 0;
		}
		#toc ol,
		#toc li,
		#toc a {
			display: contents;
			/* Switch <a> to subgrid when supported */
		}
		#toc span {
			margin: 0;
		}
		#toc > .toc > li > a > span {
			/* The spans of the top-level list,
			  comprising the first items of each top-level section. */
			margin-top: 1.1rem;
		}
		#toc#toc .secno { /* Ugh, need more specificity to override base.css */
			grid-column: 1;
			width: auto;
			margin-left: 0;
		}
		#toc .content {
			grid-column: 2;
			width: auto;
			margin-right: 1rem;
		}
		#toc .content:hover,
		#toc .content:focus {
			background: rgba(75%, 75%, 75%, .25);
			background: var(--a-hover-bg);
			border-bottom: 3px solid #054572;
			border-bottom: 3px solid var(--toclink-underline);
			margin-bottom: -3px;
		}
		#toc li li li .content {
			margin-left: 1rem;
		}
		#toc li li li li .content {
			margin-left: 2rem;
		}
	}


/** Index *********************************************************************/

	/* Index Lists: Layout */
	ul.index	  { margin-left: 0; columns: 15em; text-indent: 1em hanging; }
	ul.index li	{ margin-left: 0; list-style: none; break-inside: avoid; }
	ul.index li li { margin-left: 1em; }
	ul.index dl	{ margin-top: 0; }
	ul.index dt	{ margin: .2em 0 .2em 20px;}
	ul.index dd	{ margin: .2em 0 .2em 40px;}
	/* Index Lists: Typography */
	ul.index ul,
	ul.index dl { font-size: smaller; }
	@media not print {
		ul.index li a + span {
			white-space: nowrap;
			color: transparent; }
		ul.index li a:hover + span,
		ul.index li a:focus + span {
			color: #707070;
			color: var(--indexinfo-text);
		}
	}

/** Index Tables *****************************************************/
	/* See also the data table styling section, which this effectively subclasses */

	table.index {
		font-size: small;
		border-collapse: collapse;
		border-spacing: 0;
		text-align: left;
		margin: 1em 0;
	}

	table.index td,
	table.index th {
		padding: 0.4em;
	}

	table.index tr:hover td:not([rowspan]),
	table.index tr:hover th:not([rowspan]) {
		color: black;
		color: var(--indextable-hover-text);
		background: #f7f8f9;
		background: var(--indextable-hover-bg);
	}

	/* The link in the first column in the property table (formerly a TD) */
	table.index th:first-child a {
		font-weight: bold;
	}

/** Outdated warning **********************************************************/

.outdated-spec {
	color: black;
	color: var(--outdatedspec-text);
	background-color: rgba(0,0,0,0.5);
	background-color: var(--outdatedspec-bg);
}

.outdated-warning {
	position: fixed;
	bottom: 50%;
	left: 0;
	right: 0;
	margin: 0 auto;
	width: 50%;
	background: maroon;
	background: var(--outdated-bg);
	color: white;
	color: var(--outdated-text);
	border-radius: 1em;
	box-shadow: 0 0 1em red;
	box-shadow: 0 0 1em var(--outdated-shadow);
	padding: 2em;
	text-align: center;
	z-index: 2;
}

.outdated-warning a {
	color: currentcolor;
	background: transparent;
}

.edited-rec-warning {
	background: darkorange;
	background: var(--editedrec-bg);
	box-shadow: 0 0 1em;
}

.outdated-warning button {
	color: var(--outdated-text);
	border-radius: 1em;
	box-shadow: 0 0 1em red;
	box-shadow: 0 0 1em var(--outdated-shadow);
	padding: 2em;
	text-align: center;
	z-index: 2;
}

.outdated-warning a {
	color: currentcolor;
	background: transparent;
}

.edited-rec-warning {
	background: darkorange;
	background: var(--editedrec-bg);
	box-shadow: 0 0 1em;
}

.outdated-warning button {
	position: absolute;
	top: 0;
	right:0;
	margin: 0;
	border: 0;
	padding: 0.25em 0.5em;
	background: transparent;
	color: white;
	color: var(--outdated-text);
	font:1em sans-serif;
	text-align:center;
}

.outdated-warning span {
	display: block;
}

.outdated-collapsed {
	bottom: 0;
	border-radius: 0;
	width: 100%;
	padding: 0;
}

/******************************************************************************/
/*                                    Print                                   */
/******************************************************************************/

	@media print {
		/* Pages have their own margins. */
		html {
			margin: 0;
		}
		/* Serif for print. */
		body {
			font-family: serif;
		}

		.outdated-warning {
			position: absolute;
			border-style: solid;
			border-color: red;
		}

		.outdated-warning input {
			display: none;
		}
	}
	@page {
		margin: 1.5cm 1.1cm;
	}



/******************************************************************************/
/*                             Overflow Control                               */
/******************************************************************************/

	.figure .caption, .sidefigure .caption, figcaption {
		/* in case figure is overlarge, limit caption to 50em */
		max-width: 50rem;
		margin-left: auto;
		margin-right: auto;
	}
	.overlarge {
		/* Magic to create good item positioning:
		  "content column" is 50ems wide at max; less on smaller screens.
		  Extra space (after ToC + content) is empty on the right.

		  1. When item < content column, centers item in column.
		  2. When content < item < available, left-aligns.
		  3. When item > available, fills available + scroll bar.
		*/
		display: grid;
		grid-template-columns: minmax(0, 50em);
	}
	.overlarge > table {
		/* limit preferred width of table */
		max-width: 50em;
		margin-left: auto;
		margin-right: auto;
	}

	@media (min-width: 55em) {
		.overlarge {
			margin-right: calc(13px + 26.5rem - 50vw);
			max-width: none;
		}
	}
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) .overlarge {
			/* 30.5em body padding 50em content area */
			margin-right: calc(40em - 50vw) !important;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) .overlarge {
			/* 4em html margin 30.5em body padding 50em content area */
			margin-right: calc(84.5em - 100vw) !important;
		}
	}

	@media not print {
		.overlarge {
			overflow-x: auto;
			/* See Lea Verou's explanation background-attachment:
			* http://lea.verou.me/2012/04/background-attachment-local/
			*
			background: top left  / 4em 100% linear-gradient(to right,  #ffffff, rgba(255, 255, 255, 0)) local,
						top right / 4em 100% linear-gradient(to left, #ffffff, rgba(255, 255, 255, 0)) local,
						top left  / 1em 100% linear-gradient(to right,  #c3c3c5, rgba(195, 195, 197, 0)) scroll,
						top right / 1em 100% linear-gradient(to left, #c3c3c5, rgba(195, 195, 197, 0)) scroll,
						white;
			background-repeat: no-repeat;
			*/
		}
	}
</style>
<style>
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      vertical-align: top;
    }
    th, td {
      border-left: none;
      border-right: none;
      padding: 0px 10px;
    }
    th {
      text-align: center;
    }

    del { background: #fcc; color: #000; text-decoration: line-through; }
    ins { background: #cfc; color: #000; }
    blockquote .highlight:not(.idl) { background: initial; margin: initial; padding: 0.5em }
    blockquote ul { background: inherit; }
    blockquote code.highlight:not(.idl) { padding: initial; }
    blockquote c-[a] { color: inherit; } /* Keyword.Declaration */
    blockquote c-[b] { color: inherit; } /* Keyword.Type */
    blockquote c-[c] { color: inherit; } /* Comment */
    blockquote c-[d] { color: inherit; } /* Comment.Multiline */
    blockquote c-[e] { color: inherit; } /* Name.Attribute */
    blockquote c-[f] { color: inherit; } /* Name.Tag */
    blockquote c-[g] { color: inherit; } /* Name.Variable */
    blockquote c-[k] { color: inherit; } /* Keyword */
    blockquote c-[l] { color: inherit; } /* Literal */
    blockquote c-[m] { color: inherit; } /* Literal.Number */
    blockquote c-[n] { color: inherit; } /* Name */
    blockquote c-[o] { color: inherit; } /* Operator */
    blockquote c-[p] { color: inherit; } /* Punctuation */
    blockquote c-[s] { color: inherit; } /* Literal.String */
    blockquote c-[t] { color: inherit; } /* Literal.String.Single */
    blockquote c-[u] { color: inherit; } /* Literal.String.Double */
    blockquote c-[cp] { color: inherit; } /* Comment.Preproc */
    blockquote c-[c1] { color: inherit; } /* Comment.Single */
    blockquote c-[cs] { color: inherit; } /* Comment.Special */
    blockquote c-[kc] { color: inherit; } /* Keyword.Constant */
    blockquote c-[kn] { color: inherit; } /* Keyword.Namespace */
    blockquote c-[kp] { color: inherit; } /* Keyword.Pseudo */
    blockquote c-[kr] { color: inherit; } /* Keyword.Reserved */
    blockquote c-[ld] { color: inherit; } /* Literal.Date */
    blockquote c-[nc] { color: inherit; } /* Name.Class */
    blockquote c-[no] { color: inherit; } /* Name.Constant */
    blockquote c-[nd] { color: inherit; } /* Name.Decorator */
    blockquote c-[ni] { color: inherit; } /* Name.Entity */
    blockquote c-[ne] { color: inherit; } /* Name.Exception */
    blockquote c-[nf] { color: inherit; } /* Name.Function */
    blockquote c-[nl] { color: inherit; } /* Name.Label */
    blockquote c-[nn] { color: inherit; } /* Name.Namespace */
    blockquote c-[py] { color: inherit; } /* Name.Property */
    blockquote c-[ow] { color: inherit; } /* Operator.Word */
    blockquote c-[mb] { color: inherit; } /* Literal.Number.Bin */
    blockquote c-[mf] { color: inherit; } /* Literal.Number.Float */
    blockquote c-[mh] { color: inherit; } /* Literal.Number.Hex */
    blockquote c-[mi] { color: inherit; } /* Literal.Number.Integer */
    blockquote c-[mo] { color: inherit; } /* Literal.Number.Oct */
    blockquote c-[sb] { color: inherit; } /* Literal.String.Backtick */
    blockquote c-[sc] { color: inherit; } /* Literal.String.Char */
    blockquote c-[sd] { color: inherit; } /* Literal.String.Doc */
    blockquote c-[se] { color: inherit; } /* Literal.String.Escape */
    blockquote c-[sh] { color: inherit; } /* Literal.String.Heredoc */
    blockquote c-[si] { color: inherit; } /* Literal.String.Interpol */
    blockquote c-[sx] { color: inherit; } /* Literal.String.Other */
    blockquote c-[sr] { color: inherit; } /* Literal.String.Regex */
    blockquote c-[ss] { color: inherit; } /* Literal.String.Symbol */
    blockquote c-[vc] { color: inherit; } /* Name.Variable.Class */
    blockquote c-[vg] { color: inherit; } /* Name.Variable.Global */
    blockquote c-[vi] { color: inherit; } /* Name.Variable.Instance */
    blockquote c-[il] { color: inherit; } /* Literal.Number.Integer.Long */
  </style>
  <meta content="Bikeshed version 3383f409d, updated Fri Apr 28 15:49:22 2023 -0700" name="generator">
  <link href="https://isocpp.org/favicon.ico" rel="icon">
<style>
hilite  {background-color: #FFFF00; font-weight: bold;}
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
src  {background-color: #FFDDFF; text-decoration: line-through;}
dst  {background-color: #CCFFEE; text-decoration: underline;}
</style>
<style>/* style-autolinks */
.css.css, .property.property, .descriptor.descriptor {
    color: var(--a-normal-text);
    font-size: inherit;
    font-family: inherit;
}
.css::before, .property::before, .descriptor::before {
    content: "‘";
}
.css::after, .property::after, .descriptor::after {
    content: "’";
}
.property, .descriptor {
    /* Don't wrap property and descriptor names */
    white-space: nowrap;
}
.type { /* CSS value <type> */
    font-style: italic;
}
pre .property::before, pre .property::after {
    content: "";
}
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {
    content: "‘";
}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {
    content: "’";
}

[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after {
    content: "";
}

[data-link-type=element],
[data-link-type=element-attr] {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
    font-size: .9em;
}
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after  { content: ">" }

[data-link-type=biblio] {
    white-space: pre;
}
</style>
<style>/* style-colors */

/* Any --*-text not paired with a --*-bg is assumed to have a transparent bg */
:root {
    color-scheme: light dark;

    --text: black;
    --bg: white;

    --unofficial-watermark: url(https://www.w3.org/StyleSheets/TR/2016/logos/UD-watermark);

    --logo-bg: #1a5e9a;
    --logo-active-bg: #c00;
    --logo-text: white;

    --tocnav-normal-text: #707070;
    --tocnav-normal-bg: var(--bg);
    --tocnav-hover-text: var(--tocnav-normal-text);
    --tocnav-hover-bg: #f8f8f8;
    --tocnav-active-text: #c00;
    --tocnav-active-bg: var(--tocnav-normal-bg);

    --tocsidebar-text: var(--text);
    --tocsidebar-bg: #f7f8f9;
    --tocsidebar-shadow: rgba(0,0,0,.1);
    --tocsidebar-heading-text: hsla(203,20%,40%,.7);

    --toclink-text: var(--text);
    --toclink-underline: #3980b5;
    --toclink-visited-text: var(--toclink-text);
    --toclink-visited-underline: #054572;

    --heading-text: #005a9c;

    --hr-text: var(--text);

    --algo-border: #def;

    --del-text: red;
    --del-bg: transparent;
    --ins-text: #080;
    --ins-bg: transparent;

    --a-normal-text: #034575;
    --a-normal-underline: #bbb;
    --a-visited-text: var(--a-normal-text);
    --a-visited-underline: #707070;
    --a-hover-bg: rgba(75%, 75%, 75%, .25);
    --a-active-text: #c00;
    --a-active-underline: #c00;

    --blockquote-border: silver;
    --blockquote-bg: transparent;
    --blockquote-text: currentcolor;

    --issue-border: #e05252;
    --issue-bg: #fbe9e9;
    --issue-text: var(--text);
    --issueheading-text: #831616;

    --example-border: #e0cb52;
    --example-bg: #fcfaee;
    --example-text: var(--text);
    --exampleheading-text: #574b0f;

    --note-border: #52e052;
    --note-bg: #e9fbe9;
    --note-text: var(--text);
    --noteheading-text: hsl(120, 70%, 30%);
    --notesummary-underline: silver;

    --assertion-border: #aaa;
    --assertion-bg: #eee;
    --assertion-text: black;

    --advisement-border: orange;
    --advisement-bg: #fec;
    --advisement-text: var(--text);
    --advisementheading-text: #b35f00;

    --warning-border: red;
    --warning-bg: hsla(40,100%,50%,0.95);
    --warning-text: var(--text);

    --amendment-border: #330099;
    --amendment-bg: #F5F0FF;
    --amendment-text: var(--text);
    --amendmentheading-text: #220066;

    --def-border: #8ccbf2;
    --def-bg: #def;
    --def-text: var(--text);
    --defrow-border: #bbd7e9;

    --datacell-border: silver;

    --indexinfo-text: #707070;

    --indextable-hover-text: black;
    --indextable-hover-bg: #f7f8f9;

    --outdatedspec-bg: rgba(0, 0, 0, .5);
    --outdatedspec-text: black;
    --outdated-bg: maroon;
    --outdated-text: white;
    --outdated-shadow: red;

    --editedrec-bg: darkorange;
}
</style>
<style>/* style-counters */
body {
    counter-reset: example figure issue;
}
.issue {
    counter-increment: issue;
}
.issue:not(.no-marker)::before {
    content: "Issue " counter(issue);
}

.example {
    counter-increment: example;
}
.example:not(.no-marker)::before {
    content: "Example " counter(example);
}
.invalid.example:not(.no-marker)::before,
.illegal.example:not(.no-marker)::before {
    content: "Invalid Example" counter(example);
}

figcaption {
    counter-increment: figure;
}
figcaption:not(.no-marker)::before {
    content: "Figure " counter(figure) " ";
}
</style>
<style>/* style-issues */
a[href].issue-return {
    float: right;
    float: inline-end;
    color: var(--issueheading-text);
    font-weight: bold;
    text-decoration: none;
}
</style>
<style>/* style-md-lists */
/* This is a weird hack for me not yet following the commonmark spec
   regarding paragraph and lists. */
[data-md] > :first-child {
    margin-top: 0;
}
[data-md] > :last-child {
    margin-bottom: 0;
}
</style>
<style>/* style-selflinks */

:root {
    --selflink-text: white;
    --selflink-bg: gray;
    --selflink-hover-text: black;
}
.heading, .issue, .note, .example, li, dt {
    position: relative;
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
}
a.self-link:hover {
    opacity: 1;
}
.heading > a.self-link {
    font-size: 83%;
}
.example > a.self-link,
.note > a.self-link,
.issue > a.self-link {
    /* These blocks are overflow:auto, so positioning outside
       doesn't work. */
    left: auto;
    right: 0;
}
li > a.self-link {
    left: calc(-1 * (3.5rem - 26px) - 2em);
}
dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: var(--selflink-bg);
    color: var(--selflink-text);
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
    opacity: 1;
}
dfn > a.self-link:hover {
    color: var(--selflink-hover-text);
}

a.self-link::before            { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before      { content: "#"; }
</style>
<style>/* style-syntax-highlighting */

code.highlight { padding: .1em; border-radius: .3em; }
pre.highlight, pre > code.highlight { display: block; padding: 1em; margin: .5em 0; overflow: auto; border-radius: 0; }

.highlight:not(.idl) { background: rgba(0, 0, 0, .03); }
c-[a] { color: #990055 } /* Keyword.Declaration */
c-[b] { color: #990055 } /* Keyword.Type */
c-[c] { color: #708090 } /* Comment */
c-[d] { color: #708090 } /* Comment.Multiline */
c-[e] { color: #0077aa } /* Name.Attribute */
c-[f] { color: #669900 } /* Name.Tag */
c-[g] { color: #222222 } /* Name.Variable */
c-[k] { color: #990055 } /* Keyword */
c-[l] { color: #000000 } /* Literal */
c-[m] { color: #000000 } /* Literal.Number */
c-[n] { color: #0077aa } /* Name */
c-[o] { color: #999999 } /* Operator */
c-[p] { color: #999999 } /* Punctuation */
c-[s] { color: #a67f59 } /* Literal.String */
c-[t] { color: #a67f59 } /* Literal.String.Single */
c-[u] { color: #a67f59 } /* Literal.String.Double */
c-[cp] { color: #708090 } /* Comment.Preproc */
c-[c1] { color: #708090 } /* Comment.Single */
c-[cs] { color: #708090 } /* Comment.Special */
c-[kc] { color: #990055 } /* Keyword.Constant */
c-[kn] { color: #990055 } /* Keyword.Namespace */
c-[kp] { color: #990055 } /* Keyword.Pseudo */
c-[kr] { color: #990055 } /* Keyword.Reserved */
c-[ld] { color: #000000 } /* Literal.Date */
c-[nc] { color: #0077aa } /* Name.Class */
c-[no] { color: #0077aa } /* Name.Constant */
c-[nd] { color: #0077aa } /* Name.Decorator */
c-[ni] { color: #0077aa } /* Name.Entity */
c-[ne] { color: #0077aa } /* Name.Exception */
c-[nf] { color: #0077aa } /* Name.Function */
c-[nl] { color: #0077aa } /* Name.Label */
c-[nn] { color: #0077aa } /* Name.Namespace */
c-[py] { color: #0077aa } /* Name.Property */
c-[ow] { color: #999999 } /* Operator.Word */
c-[mb] { color: #000000 } /* Literal.Number.Bin */
c-[mf] { color: #000000 } /* Literal.Number.Float */
c-[mh] { color: #000000 } /* Literal.Number.Hex */
c-[mi] { color: #000000 } /* Literal.Number.Integer */
c-[mo] { color: #000000 } /* Literal.Number.Oct */
c-[sb] { color: #a67f59 } /* Literal.String.Backtick */
c-[sc] { color: #a67f59 } /* Literal.String.Char */
c-[sd] { color: #a67f59 } /* Literal.String.Doc */
c-[se] { color: #a67f59 } /* Literal.String.Escape */
c-[sh] { color: #a67f59 } /* Literal.String.Heredoc */
c-[si] { color: #a67f59 } /* Literal.String.Interpol */
c-[sx] { color: #a67f59 } /* Literal.String.Other */
c-[sr] { color: #a67f59 } /* Literal.String.Regex */
c-[ss] { color: #a67f59 } /* Literal.String.Symbol */
c-[vc] { color: #0077aa } /* Name.Variable.Class */
c-[vg] { color: #0077aa } /* Name.Variable.Global */
c-[vi] { color: #0077aa } /* Name.Variable.Instance */
c-[il] { color: #000000 } /* Literal.Number.Integer.Long */
</style>
<style>/* style-darkmode */

@media (prefers-color-scheme: dark) {
    :root {
        --text: #ddd;
        --bg: black;

        --unofficial-watermark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Cg fill='%23100808' transform='translate(200 200) rotate(-45) translate(-200 -200)' stroke='%23100808' stroke-width='3'%3E%3Ctext x='50%25' y='220' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EUNOFFICIAL%3C/text%3E%3Ctext x='50%25' y='305' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EDRAFT%3C/text%3E%3C/g%3E%3C/svg%3E");

        --logo-bg: #1a5e9a;
        --logo-active-bg: #c00;
        --logo-text: white;

        --tocnav-normal-text: #999;
        --tocnav-normal-bg: var(--bg);
        --tocnav-hover-text: var(--tocnav-normal-text);
        --tocnav-hover-bg: #080808;
        --tocnav-active-text: #f44;
        --tocnav-active-bg: var(--tocnav-normal-bg);

        --tocsidebar-text: var(--text);
        --tocsidebar-bg: #080808;
        --tocsidebar-shadow: rgba(255,255,255,.1);
        --tocsidebar-heading-text: hsla(203,20%,40%,.7);

        --toclink-text: var(--text);
        --toclink-underline: #6af;
        --toclink-visited-text: var(--toclink-text);
        --toclink-visited-underline: #054572;

        --heading-text: #8af;

        --hr-text: var(--text);

        --algo-border: #456;

        --del-text: #f44;
        --del-bg: transparent;
        --ins-text: #4a4;
        --ins-bg: transparent;

        --a-normal-text: #6af;
        --a-normal-underline: #555;
        --a-visited-text: var(--a-normal-text);
        --a-visited-underline: var(--a-normal-underline);
        --a-hover-bg: rgba(25%, 25%, 25%, .2);
        --a-active-text: #f44;
        --a-active-underline: var(--a-active-text);

        --borderedblock-bg: rgba(255, 255, 255, .05);

        --blockquote-border: silver;
        --blockquote-bg: var(--borderedblock-bg);
        --blockquote-text: currentcolor;

        --issue-border: #e05252;
        --issue-bg: var(--borderedblock-bg);
        --issue-text: var(--text);
        --issueheading-text: hsl(0deg, 70%, 70%);

        --example-border: hsl(50deg, 90%, 60%);
        --example-bg: var(--borderedblock-bg);
        --example-text: var(--text);
        --exampleheading-text: hsl(50deg, 70%, 70%);

        --note-border: hsl(120deg, 100%, 35%);
        --note-bg: var(--borderedblock-bg);
        --note-text: var(--text);
        --noteheading-text: hsl(120, 70%, 70%);
        --notesummary-underline: silver;

        --assertion-border: #444;
        --assertion-bg: var(--borderedblock-bg);
        --assertion-text: var(--text);

        --advisement-border: orange;
        --advisement-bg: #222218;
        --advisement-text: var(--text);
        --advisementheading-text: #f84;

        --warning-border: red;
        --warning-bg: hsla(40,100%,20%,0.95);
        --warning-text: var(--text);

        --amendment-border: #330099;
        --amendment-bg: #080010;
        --amendment-text: var(--text);
        --amendmentheading-text: #cc00ff;

        --def-border: #8ccbf2;
        --def-bg: #080818;
        --def-text: var(--text);
        --defrow-border: #136;

        --datacell-border: silver;

        --indexinfo-text: #aaa;

        --indextable-hover-text: var(--text);
        --indextable-hover-bg: #181818;

        --outdatedspec-bg: rgba(255, 255, 255, .5);
        --outdatedspec-text: black;
        --outdated-bg: maroon;
        --outdated-text: white;
        --outdated-shadow: red;

        --editedrec-bg: darkorange;
    }
    /* In case a transparent-bg image doesn't expect to be on a dark bg,
       which is quite common in practice... */
    img { background: white; }
}

@media (prefers-color-scheme: dark) {
    :root {
        --selflink-text: black;
        --selflink-bg: silver;
        --selflink-hover-text: white;
    }
}

@media (prefers-color-scheme: dark) {
    .highlight:not(.idl) { background: rgba(255, 255, 255, .05); }

    c-[a] { color: #d33682 } /* Keyword.Declaration */
    c-[b] { color: #d33682 } /* Keyword.Type */
    c-[c] { color: #2aa198 } /* Comment */
    c-[d] { color: #2aa198 } /* Comment.Multiline */
    c-[e] { color: #268bd2 } /* Name.Attribute */
    c-[f] { color: #b58900 } /* Name.Tag */
    c-[g] { color: #cb4b16 } /* Name.Variable */
    c-[k] { color: #d33682 } /* Keyword */
    c-[l] { color: #657b83 } /* Literal */
    c-[m] { color: #657b83 } /* Literal.Number */
    c-[n] { color: #268bd2 } /* Name */
    c-[o] { color: #657b83 } /* Operator */
    c-[p] { color: #657b83 } /* Punctuation */
    c-[s] { color: #6c71c4 } /* Literal.String */
    c-[t] { color: #6c71c4 } /* Literal.String.Single */
    c-[u] { color: #6c71c4 } /* Literal.String.Double */
    c-[ch] { color: #2aa198 } /* Comment.Hashbang */
    c-[cp] { color: #2aa198 } /* Comment.Preproc */
    c-[cpf] { color: #2aa198 } /* Comment.PreprocFile */
    c-[c1] { color: #2aa198 } /* Comment.Single */
    c-[cs] { color: #2aa198 } /* Comment.Special */
    c-[kc] { color: #d33682 } /* Keyword.Constant */
    c-[kn] { color: #d33682 } /* Keyword.Namespace */
    c-[kp] { color: #d33682 } /* Keyword.Pseudo */
    c-[kr] { color: #d33682 } /* Keyword.Reserved */
    c-[ld] { color: #657b83 } /* Literal.Date */
    c-[nc] { color: #268bd2 } /* Name.Class */
    c-[no] { color: #268bd2 } /* Name.Constant */
    c-[nd] { color: #268bd2 } /* Name.Decorator */
    c-[ni] { color: #268bd2 } /* Name.Entity */
    c-[ne] { color: #268bd2 } /* Name.Exception */
    c-[nf] { color: #268bd2 } /* Name.Function */
    c-[nl] { color: #268bd2 } /* Name.Label */
    c-[nn] { color: #268bd2 } /* Name.Namespace */
    c-[py] { color: #268bd2 } /* Name.Property */
    c-[ow] { color: #657b83 } /* Operator.Word */
    c-[mb] { color: #657b83 } /* Literal.Number.Bin */
    c-[mf] { color: #657b83 } /* Literal.Number.Float */
    c-[mh] { color: #657b83 } /* Literal.Number.Hex */
    c-[mi] { color: #657b83 } /* Literal.Number.Integer */
    c-[mo] { color: #657b83 } /* Literal.Number.Oct */
    c-[sa] { color: #6c71c4 } /* Literal.String.Affix */
    c-[sb] { color: #6c71c4 } /* Literal.String.Backtick */
    c-[sc] { color: #6c71c4 } /* Literal.String.Char */
    c-[dl] { color: #6c71c4 } /* Literal.String.Delimiter */
    c-[sd] { color: #6c71c4 } /* Literal.String.Doc */
    c-[se] { color: #6c71c4 } /* Literal.String.Escape */
    c-[sh] { color: #6c71c4 } /* Literal.String.Heredoc */
    c-[si] { color: #6c71c4 } /* Literal.String.Interpol */
    c-[sx] { color: #6c71c4 } /* Literal.String.Other */
    c-[sr] { color: #6c71c4 } /* Literal.String.Regex */
    c-[ss] { color: #6c71c4 } /* Literal.String.Symbol */
    c-[fm] { color: #268bd2 } /* Name.Function.Magic */
    c-[vc] { color: #cb4b16 } /* Name.Variable.Class */
    c-[vg] { color: #cb4b16 } /* Name.Variable.Global */
    c-[vi] { color: #cb4b16 } /* Name.Variable.Instance */
    c-[vm] { color: #cb4b16 } /* Name.Variable.Magic */
    c-[il] { color: #657b83 } /* Literal.Number.Integer.Long */
}
</style>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"></p>
   <h1 class="p-name no-ref" id="title">D2767R0<br>flat_map/flat_set omnibus</h1>
   <h2 class="no-num no-toc no-ref heading settled" id="profile-and-date"><span class="content">Draft Proposal, <time class="dt-updated" datetime="2023-05-11">2023-05-11</time></span></h2>
   <div data-fill-with="spec-metadata">
    <dl>
     <dt class="editor">Author:
     <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:arthur.j.odwyer@gmail.com">Arthur O'Dwyer</a>
     <dt>Audience:
     <dd>LWG
     <dt>Project:
     <dd>ISO/IEC JTC1/SC22/WG21 14882: Programming Language — C++
     <dt>Draft Revision:
     <dd>8
     <dt>Current Source:
     <dd><a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d2767-flat-omnibus.bs">github.com/Quuxplusone/draft/blob/gh-pages/d2767-flat-omnibus.bs</a>
     <dt>Current:
     <dd><a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d2767-flat-omnibus.html">rawgit.com/Quuxplusone/draft/gh-pages/d2767-flat-omnibus.html</a>
    </dl>
   </div>
   <div data-fill-with="warning"></div>
   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract">
   <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
   <p>Dummy text</p>
  </div>
  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref" id="contents">Table of Contents</h2>
   <ol class="toc" role="directory">
    <li><a href="#changelog"><span class="secno">1</span> <span class="content">Changelog</span></a>
    <li><a href="#intro"><span class="secno">2</span> <span class="content">Introduction</span></a>
    <li>
     <a href="#editorial-cons-alloc"><span class="secno">3</span> <span class="content">Editorial introduction of [flat.foo.cons.alloc]</span></a>
     <ol class="toc">
      <li><a href="#editorial-flat-map-cons-alloc"><span class="secno">3.1</span> <span class="content">[flat.map]</span></a>
      <li><a href="#editorial-flat-multimap-cons-alloc"><span class="secno">3.2</span> <span class="content">[flat.multimap]</span></a>
      <li><a href="#editorial-flat-multiset-cons-alloc"><span class="secno">3.3</span> <span class="content">[flat.multiset]</span></a>
      <li><a href="#editorial-flat-set-cons-alloc"><span class="secno">3.4</span> <span class="content">[flat.set]</span></a>
     </ol>
    <li>
     <a href="#explicit-oops"><span class="secno">4</span> <span class="content">Accidentally explicit constructor</span></a>
     <ol class="toc">
      <li><a href="#wording-explicit-oops"><span class="secno">4.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#set-insert-range"><span class="secno">5</span> <span class="content">Add move semantics to <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>insert_range</c-></code></span></a>
     <ol class="toc">
      <li><a href="#wording-set-insert-range"><span class="secno">5.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#map-insert-range"><span class="secno">6</span> <span class="content">Add move semantics to <code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>insert_range</c-></code></span></a>
     <ol class="toc">
      <li><a href="#wording-map-insert-range"><span class="secno">6.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#insert-emplace"><span class="secno">7</span> <span class="content"><code class="highlight"><c- n>insert</c-></code> is more primitive than <code class="highlight"><c- n>emplace</c-></code></span></a>
     <ol class="toc">
      <li><a href="#heterogeneous-insert-multiset"><span class="secno">7.1</span> <span class="content">Heterogeneous <code class="highlight"><c- n>multiset</c-><c- o>::</c-><c- n>insert</c-></code></span></a>
      <li><a href="#emplace-constraint"><span class="secno">7.2</span> <span class="content">Unusual constraints</span></a>
      <li><a href="#wording-insert-emplace"><span class="secno">7.3</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#insert-range-sorted-unique"><span class="secno">8</span> <span class="content"><code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code></span></a>
     <ol class="toc">
      <li><a href="#wording-insert-range-sorted-unique"><span class="secno">8.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#sorting-complexity"><span class="secno">9</span> <span class="content">Sorting complexity</span></a>
     <ol class="toc">
      <li><a href="#wording-sorting-complexity"><span class="secno">9.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#replace-by-value"><span class="secno">10</span> <span class="content"><code class="highlight"><c- n>replace</c-></code> should take by value</span></a>
     <ol class="toc">
      <li><a href="#wording-replace-by-value"><span class="secno">10.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#keys-method"><span class="secno">11</span> <span class="content">Add <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>keys</c-><c- p>()</c-></code></span></a>
     <ol class="toc">
      <li><a href="#wording-keys-method"><span class="secno">11.1</span> <span class="content">Wording</span></a>
     </ol>
    <li>
     <a href="#issues-for-discussion"><span class="secno">12</span> <span class="content">Issues for discussion</span></a>
     <ol class="toc">
      <li><a href="#stable-sorting"><span class="secno">12.1</span> <span class="content">Stable sorting in <code class="highlight"><c- n>insert</c-></code></span></a>
      <li><a href="#deceptive"><span class="secno">12.2</span> <span class="content">Non-explicit constructor from two containers</span></a>
      <li>
       <a href="#complexity-equal-range"><span class="secno">12.3</span> <span class="content">Complexity of <code class="highlight"><c- n>equal_range</c-></code></span></a>
       <ol class="toc">
        <li><a href="#wording-complexity-equal-range"><span class="secno">12.3.1</span> <span class="content">Wording</span></a>
       </ol>
      <li><a href="#special-members"><span class="secno">12.4</span> <span class="content">Special member functions</span></a>
      <li>
       <a href="#move-from-comparator"><span class="secno">12.5</span> <span class="content">Moving from the comparator</span></a>
       <ol class="toc">
        <li><a href="#wording-special-members"><span class="secno">12.5.1</span> <span class="content">Possible wording</span></a>
       </ol>
      <li>
       <a href="#qualifies-container"><span class="secno">12.6</span> <span class="content">"Qualifies as a container"</span></a>
       <ol class="toc">
        <li><a href="#wording-qualifies-container"><span class="secno">12.6.1</span> <span class="content">Wording</span></a>
       </ol>
      <li><a href="#iterator-types"><span class="secno">12.7</span> <span class="content"><code class="highlight"><c- n>iterator</c-></code> and <code class="highlight"><c- n>const_iterator</c-></code></span></a>
      <li><a href="#containers"><span class="secno">12.8</span> <span class="content">Support for non-standard containers</span></a>
      <li><a href="#redundancy"><span class="secno">12.9</span> <span class="content">Inconsistent handling of redundancy in [flat.multiset] and [flat.multimap]</span></a>
      <li>
       <a href="#noexcept-swap"><span class="secno">12.10</span> <span class="content">Noexcept <code class="highlight"><c- n>swap</c-></code></span></a>
       <ol class="toc">
        <li><a href="#ranges-swap"><span class="secno">12.10.1</span> <span class="content">Specified in terms of <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-></code></span></a>
       </ol>
      <li><a href="#lwg-3802"><span class="secno">12.11</span> <span class="content">Allocator-extended constructors lack move semantics</span></a>
     </ol>
    <li><a href="#experience"><span class="secno">13</span> <span class="content">Implementation experience</span></a>
    <li><a href="#acknowledgments"><span class="secno">14</span> <span class="content">Acknowledgments</span></a>
    <li>
     <a href="#references"><span class="secno"></span> <span class="content">References</span></a>
     <ol class="toc">
      <li><a href="#informative"><span class="secno"></span> <span class="content">Informative References</span></a>
     </ol>
   </ol>
  </nav>
  <main>
   <h2 class="heading settled" data-level="1" id="changelog"><span class="secno">1. </span><span class="content">Changelog</span><a class="self-link" href="#changelog"></a></h2>
   <ul>
    <li data-md>
     <p>R0:</p>
     <ul>
      <li data-md>
       <p>Initial draft.</p>
     </ul>
   </ul>
   <h2 class="heading settled" data-level="2" id="intro"><span class="secno">2. </span><span class="content">Introduction</span><a class="self-link" href="#intro"></a></h2>
   <p>Arthur has implemented all of <a data-link-type="biblio" href="#biblio-p0429" title="A standard flat_map">[P0429]</a> <code class="highlight"><c- n>flat_map</c-></code> and <a data-link-type="biblio" href="#biblio-p1222" title="A standard flat_set">[P1222]</a> <code class="highlight"><c- n>flat_set</c-></code> for libc++.
As he implemented them, he and Louis Dionne collected issues that libc++ would like to see resolved
by LWG. This paper presents all of these issues together in one place, along with Arthur’s proposed
solutions for each one.</p>
   <p>Some of the proposed solutions are LEWG-level design changes. Contrariwise, some of the issues collected
here don’t have "solutions" at all, but are recorded merely For Your Information (for other vendors/implementors)
to document the design choices libc++ has made.</p>
   <p>Arthur also proposes a major editorial change to the presentation order of [flat.foo.cons], to collect
the allocator-extended constructors in one place, consistent with <a href="https://eel.is/c++draft/priority.queue#priqueue.cons.alloc">[priqueue.cons.alloc]</a>, <a href="https://eel.is/c++draft/queue#cons.alloc">[queue.cons.alloc]</a>, and <a href="https://eel.is/c++draft/stack#cons.alloc">[stack.cons.alloc]</a>.</p>
   <h2 class="heading settled" data-level="3" id="editorial-cons-alloc"><span class="secno">3. </span><span class="content">Editorial introduction of [flat.foo.cons.alloc]</span><a class="self-link" href="#editorial-cons-alloc"></a></h2>
   <p>This editorial change was originally submitted as <a href="https://github.com/cplusplus/draft/pull/5923">#5923</a> (October 2022). It bit-rotted after the resolutions of LWG 3802/3803. Here is a clean rebased copy, with easier-to-review
formatting.</p>
   <p>This wording trivially merge-conflicts with the resolution of <a data-link-type="biblio" href="#biblio-lwg3884" title="flat_foo is missing allocator-extended copy/move constructors">[LWG3884]</a> (which adds new
allocator-extended constructors). I’m happy to rebase LWG3884 on top of this, or vice versa.</p>
   <p>The only changes happening in this part, and their rationales, are:</p>
   <ul>
    <li data-md>
     <p>Move all of the allocator-extended constructors down to the end of [flat.foo.cons].</p>
     <ul>
      <li data-md>
       <p>Ease of reading.</p>
      <li data-md>
       <p>Consistency with <code class="highlight"><c- n>priority_queue</c-></code>, <code class="highlight"><c- n>queue</c-></code>, <code class="highlight"><c- n>stack</c-></code>.</p>
     </ul>
    <li data-md>
     <p>Introduce a new subsection, [flat.foo.cons.alloc], to hold just those constructors.</p>
     <ul>
      <li data-md>
       <p>Consistency with [priqueue.cons.alloc], [queue.cons.alloc], [stack.cons.alloc].</p>
     </ul>
    <li data-md>
     <p>Rename the template parameter <code class="highlight"><c- n>Allocator</c-></code> to <code class="highlight"><c- n>Alloc</c-></code>, in every case.</p>
     <ul>
      <li data-md>
       <p>Consistency with <code class="highlight"><c- n>priority_queue</c-></code>, <code class="highlight"><c- n>queue</c-></code>, <code class="highlight"><c- n>stack</c-></code>; all of which use the name <code class="highlight"><c- n>Alloc</c-></code>.</p>
      <li data-md>
       <p>This parameter could be an allocator (e.g. <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>polymorphic_allocator</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-></code>,
or it could be a non-allocator (e.g. <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>memory_resource</c-><c- o>*</c-></code>) which is nevertheless
convertible to an allocator type. The <code class="highlight"><c- n>uses_allocator_v</c-></code> constraint makes this work.</p>
      <li data-md>
       <p>No blanket wording is activated nor deactivated by this name change.</p>
     </ul>
   </ul>
   <p>
    Text is marked as 
    <del>deleted</del>
    , 
    <ins>inserted</ins>
    , or 
    <src>moved</src>
    <dst>moved</dst>
    .
   </p>
   <h3 class="heading settled" data-level="3.1" id="editorial-flat-map-cons-alloc"><span class="secno">3.1. </span><span class="content">[flat.map]</span><a class="self-link" href="#editorial-flat-map-cons-alloc"></a></h3>
   <p><small></small></p>
   <blockquote><small> <b>24.6.9.2 Definition [flat.map.defn]</b><p></p> <pre class="highlight"><c- p>[...]</c->
    <c- k>struct</c-> <c- nc>containers</c-> <c- p>{</c->
      <c- n>key_container_type</c-> <c- n>keys</c-><c- p>;</c->
      <c- n>mapped_container_type</c-> <c- n>values</c-><c- p>;</c->
    <c- p>};</c->

    <c- c1>// [flat.map.cons], </c-><del><c- c1>construct/copy/destroy</c-></del><c- c1> </c-><ins><c- c1>constructors</c-></ins>
    <c- n>flat_map</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->

    <c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
             <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></src>
               <mov><c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></src>
               <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
             <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></src>
               <src><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></src>
               <src><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></src>
               <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- k>explicit</c-> <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
      <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- k>explicit</c-> <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-></src>
               <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-> <c- n>fr</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>fr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>));</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
      <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
               <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-></src>
               <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- n>flat_map</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c->
             <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-></src>
               <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <ins><c- c1>// [flat.map.cons.alloc], constructors with allocators</c-></ins>

    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></dst>
               <dst><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>  
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></dst>
               <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></dst>
               <dst><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></dst>
               <dst><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></dst>
               <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- k>explicit</c-> <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-></dst>
               <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-></dst>
               <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-></dst>
               <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>

    <c- n>flat_map</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>);</c->

    <c- c1>// iterators</c->
<c- p>[...]</c->
</mov></pre> <p><b>24.6.9.3 Constructors [flat.map.cons]</b></p> <pre class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
         <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre> <p>1․ Effects: Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>, and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>;
sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>; and finally erases the duplicate elements as if by:</p> <pre class="highlight"><c- k>auto</c-> <c- n>zv</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>zip_view</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>);</c->
<c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>unique</c-><c- p>(</c-><c- n>zv</c-><c- p>,</c-> <c- n>key_equiv</c-><c- p>(</c-><c- n>compare</c-><c- p>)).</c-><c- n>begin</c-><c- p>();</c->
<c- k>auto</c-> <c- n>dist</c-> <c- o>=</c-> <c- n>distance</c-><c- p>(</c-><c- n>zv</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>it</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
<c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
</pre> <p>2․ Complexity: Linear in N if the container arguments are already sorted with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code> and otherwise N log N,
where N is the value of <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</p> <pre class="highlight"><src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
  <src><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></src>
           <src><c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
<src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
  <src><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></src>
           <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
</pre> <del>3․ Constraints: <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> <p><src>4․ Effects: Equivalent to <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]).</src> </p><p><src>5․ Complexity: Same as <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively.</src> </p><pre class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
         <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre> <p>6․ Effects: Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>, and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>.</p> <p>7․ Complexity: Constant.</p> <ins><b>24.6.9.x Constructors with allocators [flat.map.cons.alloc]</b></ins> <p><ins>x․ The constructors in this subclause shall not participate in overload resolution unless <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- p>,</c-> <c- n>Alloc</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- p>,</c-> <c- n>Alloc</c-><c- o>></c-></code> is <code class="highlight">true</code>.</ins> </p><pre class="highlight"><dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
  <dst><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></dst>
           <dst><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
<dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
  <dst><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></dst>
           <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
</pre> <p><dst>4․ Effects: Equivalent to <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]).</dst> </p><p><dst>5․ Complexity: Same as <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively.</dst> </p><pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c->
           <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre> <del>8․ Constraints: <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> <p>9․ Effects: Equivalent to <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]).</p> <p>10․ Complexity: Linear.</p> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- k>explicit</c-> <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
           <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c->
           <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre> <del>11․ Constraints: <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> <p>12․ Effects: Equivalent to the corresponding non-allocator constructors except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed
with uses-allocator construction ([allocator.uses.construction]).</p> </small></blockquote>
   <h3 class="heading settled" data-level="3.2" id="editorial-flat-multimap-cons-alloc"><span class="secno">3.2. </span><span class="content">[flat.multimap]</span><a class="self-link" href="#editorial-flat-multimap-cons-alloc"></a></h3>
   <p><small></small></p>
   <blockquote><small> <b>24.6.10.2 Definition [flat.multimap.defn]</b><p></p> <pre class="highlight"><c- p>[...]</c->
    <c- k>struct</c-> <c- nc>containers</c-> <c- p>{</c->
      <c- n>key_container_type</c-> <c- n>keys</c-><c- p>;</c->
      <c- n>mapped_container_type</c-> <c- n>values</c-><c- p>;</c->
    <c- p>};</c->

    <c- c1>// [flat.multimap.cons], </c-><del><c- c1>construct/copy/destroy</c-></del><c- c1> </c-><ins><c- c1>constructors</c-></ins>
    <c- n>flat_multimap</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->

    <c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
                  <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></src>
                    <src><c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></src>
                    <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c->
                  <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
                  <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></src>
                    <src><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></src>
                    <src><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></src>
                    <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- k>explicit</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
      <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- k>explicit</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c->
        <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-></src>
                    <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- k>template</c-><c- o>&lt;</c-><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-> <c- n>fr</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>fr</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <c- k>template</c-><c- o>&lt;</c-><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>)</c->
        <c- o>:</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>));</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
      <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                    <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>c</c-><c- p>(),</c-> <c- n>compare</c-><c- p>(</c-><c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-></src>
                    <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-></src>
                    <src><c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- n>flat_multimap</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-></src>
                    <src><c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c->
                  <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>())</c->
        <c- o>:</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>comp</c-><c- p>)</c-> <c- p>{</c-> <c- p>}</c->
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-></src>
                    <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
    <src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
      <src><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>

    <ins><c- c1>// [flat.multimap.cons.alloc], constructors with allocators</c-></ins>

    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></dst>
                    <dst><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></dst>
                    <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></dst>
                    <dst><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></dst>
                    <dst><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></dst>
                    <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- k>explicit</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-></dst>
                    <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-></dst>
                    <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-></dst>
                    <dst><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-></dst>
                    <dst><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-></dst>
                    <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
    <dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
      <dst><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>

    <c- n>flat_multimap</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>);</c->

    <c- c1>// iterators</c->
<c- p>[...]</c->
</pre> <p><b>24.6.10.3 Constructors [flat.multimap.cons]</b></p> <pre class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
              <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre> <p>1․ Effects: Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>,
and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>; sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>.</p> <p>2․ Complexity: Linear in N if the container arguments are already sorted with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code> and otherwise N log N,
where N is the value of <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</p> <pre class="highlight"><src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
  <src><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></src>
                <src><c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
<src><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c-></src>
  <src><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></src>
                <src><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></src>
</pre> <del>3․ Constraints: <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> <p><src>4․ Effects: Equivalent to <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]).</src> </p><p><src>5․ Complexity: Same as <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively.</src> </p><pre class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
              <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre> <p>6․ Effects: Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>, and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>.</p> <p>7․ Complexity: Constant.</p> <ins><b>24.6.10.x Constructors with allocators [flat.map.cons.alloc]</b></ins> <p><ins>x․ The constructors in this subclause shall not participate in overload resolution unless <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- p>,</c-> <c- n>Alloc</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- p>,</c-> <c- n>Alloc</c-><c- o>></c-></code> is <code class="highlight">true</code>.</ins> </p><pre class="highlight"><dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
  <dst><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></dst>
           <dst><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
<dst><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></dst>
  <dst><c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></dst>
           <dst><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></dst>
</pre> <p><dst>4․ Effects: Equivalent to <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]).</dst> </p><p><dst>5․ Complexity: Same as <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively.</dst> </p><pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
                <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
                <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c->
                <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre> <del>8․ Constraints: <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> <p>9․ Effects: Equivalent to <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>)</c-></code> and <code class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- n>comp</c-><c- p>)</c-></code>, respectively,
except that <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> are constructed with uses-allocator construction ([allocator.uses.construction]). </p><p>10․ Complexity: Linear. </p><pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- k>explicit</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c->
                <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>from_range_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- p>,</c-> <c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>,</c->
                <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c->
                <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><del><c- nc>ator</c-></del><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><del><c- n>ator</c-></del><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre> <del>11․ Constraints: <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code> and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> <p>12․ Effects: Equivalent to the corresponding non-allocator constructors except that c.keys and c.values are constructed with uses-allocator
construction ([allocator.uses.construction]). </p></small></blockquote>
   <h3 class="heading settled" data-level="3.3" id="editorial-flat-multiset-cons-alloc"><span class="secno">3.3. </span><span class="content">[flat.multiset]</span><a class="self-link" href="#editorial-flat-multiset-cons-alloc"></a></h3>
   <p>TODO FIXME BUG HACK</p>
   <h3 class="heading settled" data-level="3.4" id="editorial-flat-set-cons-alloc"><span class="secno">3.4. </span><span class="content">[flat.set]</span><a class="self-link" href="#editorial-flat-set-cons-alloc"></a></h3>
   <p>TODO FIXME BUG HACK</p>
   <h2 class="heading settled" data-level="4" id="explicit-oops"><span class="secno">4. </span><span class="content">Accidentally explicit constructor</span><a class="self-link" href="#explicit-oops"></a></h2>
   <p>STL style is that multi-argument constructors should be non-<code class="highlight"><c- k>explicit</c-></code>; see <a data-link-type="biblio" href="#biblio-p1163" title="Explicitly implicifying explicit constructors">[P1163]</a>.
This change is non-editorial, but should be non-controversial, unless anyone objects
to the delegating constructor’s doing an extra move of <code class="highlight"><c- n>cont</c-></code>. In practice, libc++
doesn’t actually move <code class="highlight"><c- n>cont</c-></code> twice; we consider the delegating constructor merely a tool
to shorten the spec.</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>v</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-> <c- n>s</c-> <c- o>=</c-> <c- p>{</c-> <c- n>v</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- p>(),</c-> <c- n>std</c-><c- o>::</c-><c- n>allocator</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-><c- p>()</c-> <c- p>};</c->
  <c- c1>// OK</c->
<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-> <c- n>s</c-> <c- o>=</c-> <c- p>{</c-> <c- n>v</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- p>()</c-> <c- p>};</c->
  <c- c1>// Before: Ill-formed</c->
  <c- c1>// After: OK</c->
</pre>
   <h3 class="heading settled" data-level="4.1" id="wording-explicit-oops"><span class="secno">4.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-explicit-oops"></a></h3>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.multiset.cons], constructors</c->
<c- n>flat_multiset</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->

<del><c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
<ins><c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>)</c-></ins>
  <ins><c- o>:</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c-></ins>
<ins><c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>);</c-></ins>
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.cons">[flat.multiset.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><del><c- k>explicit</c-></del> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <del><c- o>=</c-> <c- n>key_compare</c-><c- p>()</c-></del><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.set.cons], constructors</c->
<c- n>flat_set</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->

<del><c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c-></del>
<ins><c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>)</c-></ins>
  <ins><c- o>:</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c-></ins>
<ins><c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>);</c-></ins>
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.cons">[flat.set.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><del><c- k>explicit</c-></del> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <del><c- o>=</c-> <c- n>key_compare</c-><c- p>()</c-></del><c- p>);</c->
</pre></small>
   </blockquote>
   <h2 class="heading settled" data-level="5" id="set-insert-range"><span class="secno">5. </span><span class="content">Add move semantics to <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>insert_range</c-></code></span><a class="self-link" href="#set-insert-range"></a></h2>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>fs1</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>v1</c-> <c- o>=</c-> <c- p>{</c-><c- s>"hello"</c-><c- p>,</c-> <c- s>"world"</c-><c- p>};</c->
<c- n>fs1</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>as_rvalue</c-><c- p>(</c-><c- n>v1</c-><c- p>));</c->
  <c- c1>// Before: Copies the strings.</c->
  <c- c1>// After: Moves the strings.</c->

<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>fs2</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>v2</c-><c- p>;</c->
<c- n>fs2</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>as_rvalue</c-><c- p>(</c-><c- n>v2</c-><c- p>));</c->
  <c- c1>// Before: Ill-formed.</c->
  <c- c1>// After: Moves the unique_ptrs.</c->
</pre>
   <h3 class="heading settled" data-level="5.1" id="wording-set-insert-range"><span class="secno">5.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-set-insert-range"></a></h3>
   <p>Change <a href="https://eel.is/c++draft/flat.set#modifiers-10">[flat.set.modifiers]/10</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
</pre> <p>10․ Effects: Adds elements to <code class="highlight"><c- n>c</c-></code> as if by:</p> <pre class="highlight"><c- k>for</c-> <c- p>(</c-><del><c- k>const</c-> <c- k>auto</c-><c- o>&amp;</c-></del> <ins><c- k>auto</c-><c- o>&amp;&amp;</c-></ins> <c- n>e</c-> <c- o>:</c-> <c- n>rg</c-><c- p>)</c-> <c- p>{</c->
  <c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <ins><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- k>decltype</c-><c- p>(</c-><c- n>e</c-><c- p>)</c-><c- o>></c-><c- p>(</c-></ins><c- n>e</c-><ins><c- p>)</c-></ins><c- p>);</c->
<c- p>}</c->
</pre><p>Then, sorts the range of newly inserted elements with respect to <i><code class="highlight"><c- n>compare</c-></code></i>;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases all but the first element from each group of consecutive equivalent elements.</p> <p>11․ Complexity: N + M log M, where N is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> before the operation and M is <del><code class="highlight"><c- n>distance</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code></del> <ins><code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>distance</c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-></code></ins>.</p> <p>12․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</p> </small>
   </blockquote>
   <p>Add a new section to <a href="https://eel.is/c++draft/flat.multiset#modifiers">[flat.multiset.modifiers]</a> explaining the semantics of <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>insert_range</c-></code>.</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
</pre> <p><ins>x․ Effects: Adds elements to <code class="highlight"><c- n>c</c-></code> as if by:</ins> </p><pre class="highlight"><ins><c- k>for</c-> <c- p>(</c-><c- k>auto</c-><c- o>&amp;&amp;</c-> <c- n>e</c-> <c- o>:</c-> <c- n>rg</c-><c- p>)</c-> <c- p>{</c-></ins>
  <ins><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- k>decltype</c-><c- p>(</c-><c- n>e</c-><c- p>)</c-><c- o>></c-><c- p>(</c-><c- n>e</c-><c- p>));</c-></ins>
<ins><c- p>}</c-></ins>
</pre><ins>Then, sorts the range of newly inserted elements with respect to <i><code class="highlight"><c- n>compare</c-></code></i>, and
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range. <p><ins>x․ Complexity: N + M log M, where N is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> before the operation and M is <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>distance</c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-></code>.</ins> </p><p><ins>x․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</ins> </p></ins></small>
   </blockquote>
   <h2 class="heading settled" data-level="6" id="map-insert-range"><span class="secno">6. </span><span class="content">Add move semantics to <code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>insert_range</c-></code></span><a class="self-link" href="#map-insert-range"></a></h2>
   <p><code class="highlight"><c- n>flat_map</c-></code>'s <code class="highlight"><c- n>insert_range</c-></code> has the same issue as <code class="highlight"><c- n>flat_set</c-></code>'s, at least on paper.</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>flat_map</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-> <c- n>fs2</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>>></c-> <c- n>v2</c-><c- p>;</c->
<c- n>fs2</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>as_rvalue</c-><c- p>(</c-><c- n>v2</c-><c- p>));</c->
  <c- c1>// Before: Ill-formed.</c->
  <c- c1>// After: Moves the unique_ptrs.</c->
</pre>
   <p>However, libc++'s implementation of <code class="highlight"><c- n>flat_map</c-></code> and <code class="highlight"><c- n>flat_multimap</c-></code> didn’t need
to change — we already "accidentally" support move semantics in the maps' <code class="highlight"><c- n>insert_range</c-></code> methods,
because we factor out a helper method <code class="highlight"><c- n>__append_pairs</c-></code> that is used by all three of <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>, <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>, and <code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-></code>.
It looks very similar to the specification proposed below.</p>
   <p>The current specification says:</p>
<pre class="language-c++ highlight"><c- k>for</c-> <c- p>(</c-><c- k>const</c-> <c- k>auto</c-><c- o>&amp;</c-> <c- n>e</c-> <c- o>:</c-> <c- n>rg</c-><c- p>)</c-> <c- p>{</c->
  <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>e</c-><c- p>.</c-><c- n>first</c-><c- p>);</c->
  <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>e</c-><c- p>.</c-><c- n>second</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <p>The <code class="highlight"><c- n>insert_range</c-></code> method is constrained on <i><code class="highlight"><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></code></i><code class="highlight"><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-></code>,
i.e. <code class="highlight"><c- n>convertible_to</c-><c- o>&lt;</c-><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>,</c-> <c- n>value_type</c-><c- o>></c-></code>.
But in fact the current spec’s algorithm never attempts to convert <code class="highlight"><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-></code> to <code class="highlight"><c- n>value_type</c-></code>.
Instead, it implicitly requires that <code class="highlight"><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>::</c-><c- n>first</c-></code> be convertible to <code class="highlight"><c- n>key_type</c-></code> and <code class="highlight"><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>>::</c-><c- n>second</c-></code> be convertible to <code class="highlight"><c- n>mapped_type</c-></code>. If <code class="highlight"><c- n>range_reference_t</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-></code> is
something without <code class="highlight"><c- n>first</c-></code> and <code class="highlight"><c- n>second</c-></code> members, the current spec doesn’t work at all.</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-> <c- n>p1</c-> <c- o>=</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>};</c->
<c- n>std</c-><c- o>::</c-><c- n>reference_wrapper</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>>></c-> <c- n>a</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- n>p1</c-> <c- p>};</c->
<c- n>std</c-><c- o>::</c-><c- n>flat_map</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-> <c- n>fm</c-><c- p>;</c->
<c- n>fm</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
  <c- c1>// Before: Ill-formed: reference_wrapper has no .first member</c->
  <c- c1>// After: OK</c->
</pre>
   <h3 class="heading settled" data-level="6.1" id="wording-map-insert-range"><span class="secno">6.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-map-insert-range"></a></h3>
   <p>We don’t need to touch [flat.multimap.modifiers]; in fact it does not currently exist;
because of <a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview]/4</a>:</p>
   <p><small></small></p>
   <blockquote><small> 4․ Except as otherwise noted, operations on <code class="highlight"><c- n>flat_multimap</c-></code> are equivalent to those of <code class="highlight"><c- n>flat_map</c-></code>,
except that <code class="highlight"><c- n>flat_multimap</c-></code> operations do not remove or replace elements with equal keys.<p></p> </small></blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.map.modifiers#12">[flat.map.modifiers]/12</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
</pre> <p>12․ Effects: Adds elements to <code class="highlight"><c- n>c</c-></code> as if by:</p> <pre class="highlight"><c- k>for</c-> <c- p>(</c-><del><c- k>const</c-> <c- k>auto</c-><c- o>&amp;</c-></del> <ins><c- n>value_type</c-></ins> <c- n>e</c-> <c- o>:</c-> <c- n>rg</c-><c- p>)</c-> <c- p>{</c->
  <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <ins><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-></ins><c- n>e</c-><c- p>.</c-><c- n>first</c-><ins><c- p>)</c-></ins><c- p>);</c->
  <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <ins><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-></ins><c- n>e</c-><c- p>.</c-><c- n>second</c-><ins><c- p>)</c-></ins><c- p>);</c->
<c- p>}</c->
</pre><p>Then, sorts the range of newly inserted elements with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases the duplicate elements as if by:</p> <pre class="highlight"><c- k>auto</c-> <c- n>zv</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>zip_view</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>);</c->
<c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>unique</c-><c- p>(</c-><c- n>zv</c-><c- p>,</c-> <c- n>key_equiv</c-><c- p>(</c-><c- n>compare</c-><c- p>)).</c-><c- n>begin</c-><c- p>();</c->
<c- k>auto</c-> <c- n>dist</c-> <c- o>=</c-> <c- n>distance</c-><c- p>(</c-><c- n>zv</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>it</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
<c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
</pre> <p>13․ Complexity: N + M log M, where N is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> before the operation and M is <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>distance</c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-></code>.</p> <p>14․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="7" id="insert-emplace"><span class="secno">7. </span><span class="content"><code class="highlight"><c- n>insert</c-></code> is more primitive than <code class="highlight"><c- n>emplace</c-></code></span><a class="self-link" href="#insert-emplace"></a></h2>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>set_default_resource</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>null_memory_resource</c-><c- p>());</c->
<c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>monotonic_buffer_resource</c-> <c- nf>mr</c-><c- p>(</c-><c- mi>1</c->’<c- mo>000</c->’<c- mo>000</c-><c- p>);</c->

<c- k>auto</c-> <c- n>fm</c-> <c- o>=</c-> <c- n>PmrFlatSet</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- o>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-> <c- n>ps</c-><c- p>(</c-><c- s>"too long to fit in the small string buffer"</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>fm</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>ps</c-><c- p>);</c->
  <c- c1>// Before: runtime abort, cannot default-allocate t</c->
  <c- c1>// After: OK</c->
</pre>
   <p>Whenever we insert or emplace into a set or multiset, we have two tasks:</p>
   <ul>
    <li data-md>
     <p>Construct the new <code class="highlight"><c- n>value_type</c-></code> object.</p>
    <li data-md>
     <p>Find the correct insertion point for the new object.</p>
   </ul>
   <p><code class="highlight"><c- n>emplace</c-></code> receives a bag of constructor arguments, so it has no choice: it must do
"construct <code class="highlight"><c- n>t</c-></code>, find insertion point for <code class="highlight"><c- n>t</c-></code>, move-insert <code class="highlight"><c- n>t</c-></code> into the container" exactly as specified above.</p>
   <p>But <code class="highlight"><c- n>insert</c-></code> receives an already-constructed <code class="highlight"><c- n>value_type</c-></code>! It shouldn’t discard that valuable information;
it should use the given <code class="highlight"><c- n>value_type</c-></code> to find the appropriate insertion point, and then construct the new object
directly in place. There is no reason to construct <code class="highlight"><c- n>t</c-></code> on the stack first.</p>
   <h3 class="heading settled" data-level="7.1" id="heterogeneous-insert-multiset"><span class="secno">7.1. </span><span class="content">Heterogeneous <code class="highlight"><c- n>multiset</c-><c- o>::</c-><c- n>insert</c-></code></span><a class="self-link" href="#heterogeneous-insert-multiset"></a></h3>
   <p><a data-link-type="biblio" href="#biblio-p2363" title="Extending associative containers with the remaining heterogeneous overloads">[P2363]</a> <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html#ins">explains</a> why the node-based <code class="highlight"><c- n>multiset</c-></code> still lacks a heterogeneous <code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code>:</p>
   <blockquote>
    <p>Adding heterogeneous <code class="highlight"><c- n>insert</c-></code> overload makes no sense for associative containers with non-unique keys (<code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>multimap</c-></code>, <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>multiset</c-></code>, <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>unordered_multimap</c-></code> and <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>unordered_multiset</c-></code>) because the insertion will be successful in any case and the key would be always
constructed. All additional overheads introduced by <code class="highlight"><c- n>insert</c-></code> can be mitigated by using <code class="highlight"><c- n>emplace</c-></code>.</p>
   </blockquote>
   <p>For <code class="highlight"><c- n>flat_multiset</c-></code>, the last sentence is false; generic <code class="highlight"><c- n>emplace</c-></code> is unusable for PMR allocators, because it
must first construct <code class="highlight"><c- n>t</c-></code> using the default allocator. Therefore we also propose to add a heterogeneous-comparison
overload of <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>insert</c-></code>.</p>
<pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- n>class</c-> <c- n>C</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c->
<c- n>using</c-> <c- n>PmrFlatMultiset</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_multiset</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>C</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c-><c- p>;</c->
 
<c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>monotonic_buffer_resource</c-> <c- nf>mr</c-><c- p>(</c-><c- mi>1</c->’<c- mo>000</c->’<c- mo>000</c-><c- p>);</c->
<c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>set_default_resource</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>null_memory_resource</c-><c- p>());</c->
<c- k>const</c-> <c- b>char</c-> <c- n>s</c-><c- p>[]</c-> <c- o>=</c-> <c- s>"too long to fit in the small string buffer"</c-><c- p>;</c->

<c- k>auto</c-> <c- n>m</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>multiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- o>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>m</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// OK</c->
<c- n>m</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// runtime abort, cannot default-allocate x</c->

<c- k>auto</c-> <c- n>fm</c-> <c- o>=</c-> <c- n>PmrFlatMultiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- o>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>fm</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// runtime abort, cannot default-allocate t</c->
<c- n>fm</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// runtime abort, cannot default-allocate x</c->

<c- k>auto</c-> <c- n>m2</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>multiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>m2</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// OK</c->
<c- n>m2</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// runtime abort, cannot default-allocate x</c->

<c- k>auto</c-> <c- n>fm2</c-> <c- o>=</c-> <c- n>PmrFlatMultiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>fm2</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>s</c-><c- p>);</c-> <c- c1>// runtime abort, cannot default-allocate t</c->
<c- n>fm2</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>);</c->
  <c- c1>// Before: runtime abort, cannot default-allocate x</c->
  <c- c1>// After: OK</c->
</pre>
   <p>Notice the asymmetry between <code class="highlight"><c- n>fm2</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>)</c-></code> and <code class="highlight"><c- n>m2</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>)</c-></code>. Arthur thinks it would be
nice to support heterogeneous <code class="highlight"><c- n>insert</c-></code> for node-based <code class="highlight"><c- n>multiset</c-></code> and <code class="highlight"><c- n>unordered_multiset</c-></code> (<em>contra</em> P2363’s reasoning),
but that’s out of scope for this particular paper P2767. For P2767’s purposes, we’re satisfied
once there exists <em>some</em> way of inserting <code class="highlight"><c- n>s</c-></code> into <code class="highlight"><c- n>fm2</c-></code>. We don’t mind that the working approaches
use different spellings: <code class="highlight"><c- n>m2</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>s</c-><c- p>)</c-></code> versus <code class="highlight"><c- n>fm2</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>)</c-></code>.</p>
   <h3 class="heading settled" data-level="7.2" id="emplace-constraint"><span class="secno">7.2. </span><span class="content">Unusual constraints</span><a class="self-link" href="#emplace-constraint"></a></h3>
   <p>The usual pattern in [containers] is that <code class="highlight"><c- n>x</c-><c- p>.</c-><c- n>emplace</c-><c- p>(</c-><c- n>args</c-><c- p>...)</c-></code> has a precondition (<a href="https://eel.is/c++draft/containers#sequence.reqmts-21">[sequence.reqmts]</a>, <a href="https://eel.is/c++draft/containers#associative.reqmts.general-48">[associative.reqmts.general]</a>)
but no Constraints element. That is, <code class="highlight"><c- n>emplace</c-></code> is not SFINAE-friendly. And it has only the one overload,
so it doesn’t need a constraint for purposes of overload resolution.</p>
   <p>No Constraints on <code class="highlight"><c- n>emplace</c-></code>: <a href="https://eel.is/c++draft/deque.modifiers#lib:deque,emplace"><code class="highlight"><c- n>deque</c-></code></a> <a href="https://eel.is/c++draft/list.modifiers"><code class="highlight"><c- n>list</c-></code></a>, <a href="https://eel.is/c++draft/priqueue.members#lib:priority_queue,emplace"><code class="highlight"><c- n>priority_queue</c-></code></a>, <a href="https://eel.is/c++draft/vector.modifiers"><code class="highlight"><c- n>vector</c-></code></a></p>
   <p>But these two places have a Constraints element on <code class="highlight"><c- n>emplace</c-></code>: <a href="https://eel.is/c++draft/flat.map.modifiers#lib:flat_map,emplace"><code class="highlight"><c- n>flat_map</c-></code></a>, <a href="https://eel.is/c++draft/flat.multiset.modifiers#lib:flat_multiset,emplace"><code class="highlight"><c- n>flat_multiset</c-></code></a>.</p>
   <blockquote>
    <p>Constraints: <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>key_type</c-><c- p>,</c-> <c- n>mapped_type</c-><c- o>></c-><c- p>,</c-> <c- n>Arg</c-><c- p>...</c-><c- o>></c-></code> is <code class="highlight">true</code>.</p>
   </blockquote>
   <p>I believe this element was accidentally copy-pasted from the spec of <a href="https://eel.is/c++draft/flat.map.modifiers#4"><code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>P</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code></a> —<wbr>which <em>does</em> need the constraint because it’s part of <code class="highlight"><c- n>insert</c-></code>'s large overload set — to <code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>emplace</c-></code>,
and then from there to <code class="highlight"><c- n>flat_multiset</c-><c- o>::</c-><c- n>emplace</c-></code>. The constraint is already (correctly) absent
from <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>emplace</c-></code>.</p>
   <p>Therefore, the proposed wording for this section simply deletes those Constraints elements.</p>
   <h3 class="heading settled" data-level="7.3" id="wording-insert-emplace"><span class="secno">7.3. </span><span class="content">Wording</span><a class="self-link" href="#wording-insert-emplace"></a></h3>
   <p>We don’t need to touch [flat.multimap.modifiers]; in fact it does not currently exist;
because of <a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview]/4</a>:</p>
   <p><small></small></p>
   <blockquote><small> 4․ Except as otherwise noted, operations on <code class="highlight"><c- n>flat_multimap</c-></code> are equivalent to those of <code class="highlight"><c- n>flat_map</c-></code>, 
except that <code class="highlight"><c- n>flat_multimap</c-></code> operations do not remove or replace elements with equal keys.<p></p> </small></blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.map.modifiers], modifiers</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>);</c->

<c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>

<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>P</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>P</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>P</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>P</c-><c- o>&amp;&amp;</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.map.modifiers">[flat.map.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>);</c->
</pre><del>1․ Constraints: <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>key_type</c-><c- p>,</c-> <c- n>mapped_type</c-><c- o>></c-><c- p>,</c-> <c- n>Args</c-><c- p>...</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> <p>2․ Effects: Initializes an object <code class="highlight"><c- n>t</c-></code> of type <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>key_type</c-><c- p>,</c-> <c- n>mapped_type</c-><c- o>></c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...</c-></code>;
if the map already contains an element whose key is equivalent to <code class="highlight"><c- n>t</c-><c- p>.</c-><c- n>first</c-></code>, <code class="highlight"><c- o>*</c-><c- k>this</c-></code> is unchanged. Otherwise, equivalent to: </p><pre class="highlight"><c- k>auto</c-> <c- n>key_it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>t</c-><c- p>.</c-><c- n>first</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c->
<c- k>auto</c-> <c- n>value_it</c-> <c- o>=</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>distance</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>key_it</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>key_it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>t</c-><c- p>.</c-><c- n>first</c-><c- p>));</c->
<c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>value_it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>t</c-><c- p>.</c-><c- n>second</c-><c- p>));</c->
</pre> <p>3․ Returns: The <code class="highlight"><c- b>bool</c-></code> component of the returned pair is <code class="highlight">true</code> if and only if the insertion took place,
and the iterator component of the pair points to the element with key equivalent to <code class="highlight"><c- n>t</c-><c- p>.</c-><c- n>first</c-></code>.</p> <pre class="highlight"><ins><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
<ins><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><ins>x․ Effects: If the map already contains an element whose key is equivalent to <code class="highlight"><c- n>x</c-><c- p>.</c-><c- n>first</c-></code>, <code class="highlight"><c- o>*</c-><c- k>this</c-></code> and <code class="highlight"><c- n>x</c-></code> are unchanged. Otherwise, equivalent to:</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>key_it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>x</c-><c- p>.</c-><c- n>first</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- k>auto</c-> <c- n>value_it</c-> <c- o>=</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>distance</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>key_it</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>key_it</c-><c- p>,</c-> <c- n>x</c-><c- p>.</c-><c- n>first</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>value_it</c-><c- p>,</c-> <c- n>x</c-><c- p>.</c-><c- n>second</c-><c- p>);</c-></ins>
</pre><ins>for the first overload and</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>key_it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>x</c-><c- p>.</c-><c- n>first</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- k>auto</c-> <c- n>value_it</c-> <c- o>=</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>distance</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>key_it</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>key_it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>.</c-><c- n>first</c-><c- p>));</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>value_it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>.</c-><c- n>second</c-><c- p>));</c-></ins>
</pre><ins>for the second overload.</ins> <pre class="highlight"><c- k>template</c-><class p> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>P</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- k>template</c-><class p> <c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>P</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
</class></class></pre><p>4․ Constraints: <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>pair</c-><c- o>&lt;</c-><c- n>key_type</c-><c- p>,</c-> <c- n>mapped_type</c-><c- o>></c-><c- p>,</c-> <c- n>P</c-><c- o>></c-></code> is <code class="highlight">true</code>.</p> <p>5․ Effects: The first form is equivalent to <code class="highlight"><c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>P</c-><c- o>></c-><c- p>(</c-><c- n>x</c-><c- p>));</c-></code>.
The second form is equivalent to <code class="highlight"><c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>P</c-><c- o>></c-><c- p>(</c-><c- n>x</c-><c- p>));</c-></code>.</p> </small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// modifiers</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>iterator</c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>);</c->

<c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>

<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>P</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>P</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>P</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>P</c-><c- o>&amp;&amp;</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.multiset.modifiers], modifiers</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>iterator</c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
  <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
    <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></ins>

<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
<c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>hint</c-><c- p>,</c-> <c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><del><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>iterator</c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>);</c-></del>
</pre><p><del>1․ Constraints: <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>value_type</c-><c- p>,</c-> <c- n>Args</c-><c- p>...</c-><c- o>></c-></code> is <code class="highlight">true</code>.</del> </p><p><del>2․ Effects: First, initializes an object <code class="highlight"><c- n>t</c-></code> of type <code class="highlight"><c- n>value_type</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...</c-></code>,
then inserts <code class="highlight"><c- n>t</c-></code> as if by:</del> </p><pre class="highlight"><del><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>t</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></del>
<del><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>t</c-><c- p>));</c-></del>
</pre><p><del>3․ Returns: An iterator that points to the inserted element.</del> </p><pre class="highlight"><ins><c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
<ins><c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><ins>x․ Effects: Inserts a new element as if by:</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><ins>for the first overload or</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-></ins>
</pre><ins>for the second overload.</ins> <p><ins>x․ Returns: An iterator that points to the inserted element.</ins> </p><pre class="highlight"><ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>hint</c-><c- p>,</c-> <c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><p><ins>x․ Constraints: The <em>qualified-id</em> <code class="highlight"><c- n>Compare</c-><c- o>::</c-><c- n>is_transparent</c-></code> is valid and denotes a type. <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>value_type</c-><c- p>,</c-> <c- n>K</c-><c- o>></c-></code> is <code class="highlight">true</code>.</ins> </p><p><ins>x․ Preconditions: The conversion from <code class="highlight"><c- n>x</c-></code> into <code class="highlight"><c- n>value_type</c-></code> constructs an object <code class="highlight"><c- n>u</c-></code>, for which <code class="highlight"><c- n>find</c-><c- p>(</c-><c- n>x</c-><c- p>)</c-> <c- o>==</c-> <c- n>find</c-><c- p>(</c-><c- n>u</c-><c- p>)</c-></code> is <code class="highlight">true</code>.</ins> </p><p><ins>x․ Effects: If the set already contains an element equivalent to <code class="highlight"><c- n>x</c-></code>, <code class="highlight"><c- o>*</c-><c- k>this</c-></code> and <code class="highlight"><c- n>x</c-></code> are unchanged. Otherwise, inserts a new element as if by <code class="highlight"><c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>K</c-><c- o>></c-><c- p>(</c-><c- n>x</c-><c- p>))</c-></code>.</ins> </p><p><ins>x․ Returns: An iterator that points to the inserted element.</ins> </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.set.modifiers], modifiers</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>emplace</c-><c- p>(</c-><c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
  <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-><c- p>...</c-> <c- n>Args</c-><c- o>></c->
  <c- n>iterator</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>Args</c-><c- o>&amp;&amp;</c-><c- p>...</c-> <c- n>args</c-><c- p>)</c-><del><c- p>;</c-></del>
    <ins><c- p>{</c-> <c- k>return</c-> <c- n>insert</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>Args</c-><c- o>></c-><c- p>(</c-><c- n>args</c-><c- p>)...));</c-> <c- p>}</c-></ins>

<c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- n>iterator</c-> <c- nf>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-> <c- p>}</c-></del>
<c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>position</c-><c- p>,</c-> <c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c-><ins><c- p>;</c-></ins>
  <del><c- p>{</c-> <c- k>return</c-> <c- n>emplace_hint</c-><c- p>(</c-><c- n>position</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-> <c- p>}</c-></del>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>hint</c-><c- p>,</c-> <c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.modifiers">[flat.set.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><ins><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- k>const</c-> <c- n>value_type</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
<ins><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><ins>x․ Effects: If the set already contains an element equivalent to <code class="highlight"><c- n>x</c-></code>, <code class="highlight"><c- o>*</c-><c- k>this</c-></code> and <code class="highlight"><c- n>x</c-></code> are unchanged.
Otherwise, inserts a new element as if by:</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>x</c-><c- p>);</c-></ins>
</pre><ins>for the first overload or</ins> <pre class="highlight"><ins><c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>x</c-><c- p>,</c-> <c- n>compare</c-><c- p>);</c-></ins>
<ins><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>it</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>x</c-><c- p>));</c-></ins>
</pre><ins>for the second overload.</ins> <p><ins>x․ Returns: The <code class="highlight"><c- b>bool</c-></code> component of the returned pair is <code class="highlight">true</code> if and only if the insertion took place.
The returned iterator points to the element whose key is equivalent to <code class="highlight"><c- n>x</c-></code>.</ins> </p><pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-> <c- n>insert</c-><c- p>(</c-><c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>K</c-><c- o>></c-> <c- n>iterator</c-> <c- n>insert</c-><c- p>(</c-><c- n>const_iterator</c-> <c- n>hint</c-><c- p>,</c-> <c- n>K</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
</pre><p>1․ Constraints: The <em>qualified-id</em> <code class="highlight"><c- n>Compare</c-><c- o>::</c-><c- n>is_transparent</c-></code> is valid and denotes a type. <code class="highlight"><c- n>is_constructible_v</c-><c- o>&lt;</c-><c- n>value_type</c-><c- p>,</c-> <c- n>K</c-><c- o>></c-></code> is <code class="highlight">true</code>.</p> <p>2․ Preconditions: The conversion from <code class="highlight"><c- n>x</c-></code> into <code class="highlight"><c- n>value_type</c-></code> constructs an object <code class="highlight"><c- n>u</c-></code>, for which <code class="highlight"><c- n>find</c-><c- p>(</c-><c- n>x</c-><c- p>)</c-> <c- o>==</c-> <c- n>find</c-><c- p>(</c-><c- n>u</c-><c- p>)</c-></code> is <code class="highlight">true</code>.</p> <p>3․ Effects: If the set already contains an element equivalent to <code class="highlight"><c- n>x</c-></code>, <code class="highlight"><c- o>*</c-><c- k>this</c-></code> and <code class="highlight"><c- n>x</c-></code> are unchanged. Otherwise, inserts a new element as if by</p> <del><code class="highlight"><c- n>emplace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>K</c-><c- o>></c-><c- p>(</c-><c- n>x</c-><c- p>))</c-></code></del> <ins><code class="highlight"><c- n>insert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>K</c-><c- o>></c-><c- p>(</c-><c- n>x</c-><c- p>))</c-></code></ins>. <p>4․ Returns: In the first overload, the <code class="highlight"><c- b>bool</c-></code> component of the returned pair is <code class="highlight">true</code> if and only if the insertion took place.
The returned iterator points to the element whose key is equivalent to <code class="highlight"><c- n>x</c-></code>.</p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="8" id="insert-range-sorted-unique"><span class="secno">8. </span><span class="content"><code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code></span><a class="self-link" href="#insert-range-sorted-unique"></a></h2>
   <p>The multi-element insertion API consists of these overloads:</p>
<pre class="language-c++ highlight"><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c->
<c- n>insert</c-><c- p>(</c-><c- n>il</c-><c- p>);</c->
<c- n>insert_range</c-><c- p>(</c-><c- n>rg</c-><c- p>);</c->

<c- n>insert</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c->
<c- n>insert</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>il</c-><c- p>);</c->
</pre>
   <p>An overload of <code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code> is conspicuously missing.</p>
<pre class="language-c++ highlight"><c- k>auto</c-> <c- n>rg</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>iota</c-><c- p>(</c-><c- mi>0</c-><c- p>,</c-> <c- mi>100</c-><c- p>)</c-> <c- o>|</c-> <c- n>std</c-><c- o>::</c-><c- n>take_while</c-><c- p>(</c-><c- n>lessThan50</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- o>!</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>common_range</c-><c- o>&lt;</c-><c- n>decltype</c-><c- p>(</c-><c- n>rg</c-><c- p>)</c-><c- o>></c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>is_sorted</c-><c- p>(</c-><c- n>rg</c-><c- p>));</c->

<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>fs</c-><c- p>;</c->

<c- n>fs</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>rg</c-><c- p>);</c->
  <c- c1>// OK, but unnecessarily re-sorts the input</c->

<c- k>if</c-> <c- p>(</c-><c- k>auto</c-> <c- n>cv</c-> <c- o>=</c-> <c- n>rg</c-> <c- o>|</c-> <c- n>std</c-><c- o>::</c-><c- n>views</c-><c- o>::</c-><c- n>common</c-><c- p>;</c-> true<c- p>)</c-> <c- p>{</c->
  <c- n>fs</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>cv</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>cv</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
    <c- c1>// OK, doesn’t re-sort, but arcane</c->
<c- p>}</c->

<c- n>fs</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>rg</c-><c- p>);</c->
  <c- c1>// Before: Ill-formed</c->
  <c- c1>// After: OK</c->
</pre>
   <p>Now, we’re also conspicuously missing a constructor overload <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>sorted_unique</c-><c- p>,</c-> <c- n>from_range</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code>.
There we have a real API-design conflict: Which of <code class="highlight"><c- n>sorted_unique</c-></code> and <code class="highlight"><c- n>from_range</c-></code> should come first?
This is enough of a reason to simply give up on that constructor. But <code class="highlight"><c- n>insert_range</c-></code> has no such API-design
problem. We could add this overload easily.</p>
   <h3 class="heading settled" data-level="8.1" id="wording-insert-range-sorted-unique"><span class="secno">8.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-insert-range-sorted-unique"></a></h3>
   <p>Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p>Add a new entry to <a href="https://eel.is/c++draft/flat.map.modifiers">[flat.map.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
</pre> <p><ins>x․ Effects: Equivalent to <code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>))</c-></code>.</ins> </p><p><ins>x․ Complexity: Linear in N, where N is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> after the operation.</ins> </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p>Add a new entry to <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
</pre> <p><ins>x․ Effects: Equivalent to <code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>))</c-></code>.</ins> </p><p><ins>x․ Complexity: Linear in N, where N is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> after the operation.</ins> </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
<c- b>void</c-> <c- nf>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-> <c- n>s</c-><c- p>,</c-> <c- n>initializer_list</c-><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>il</c-><c- p>)</c->
  <c- p>{</c-> <c- n>insert</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>il</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>il</c-><c- p>.</c-><c- n>end</c-><c- p>());</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p>Add a new entry to <a href="https://eel.is/c++draft/flat.set.modifiers">[flat.set.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><ins><c- k>template</c-><c- o>&lt;</c-><i><c- n>container</c-><c- o>-</c-><c- n>compatible</c-><c- o>-</c-><c- n>range</c-></i><c- o>&lt;</c-><c- n>value_type</c-><c- o>></c-> <c- n>R</c-><c- o>></c-></ins>
  <ins><c- b>void</c-> <c- n>insert_range</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>R</c-><c- o>&amp;&amp;</c-> <c- n>rg</c-><c- p>);</c-></ins>
</pre> <p><ins>x․ Effects: Equivalent to <code class="highlight"><c- n>insert_range</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>forward</c-><c- o>&lt;</c-><c- n>R</c-><c- o>></c-><c- p>(</c-><c- n>rg</c-><c- p>))</c-></code>.</ins> </p><p><ins>x․ Complexity: Linear in N, where N is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> after the operation.</ins> </p></small>
   </blockquote>
   <h2 class="heading settled" data-level="9" id="sorting-complexity"><span class="secno">9. </span><span class="content">Sorting complexity</span><a class="self-link" href="#sorting-complexity"></a></h2>
   <p>Most operations that require sorting come in <code class="highlight"><c- n>sorted_unique</c-></code> and non-<code class="highlight"><c- n>sorted_unique</c-></code> flavors;
the <code class="highlight"><c- n>sorted_unique</c-></code> flavor is rightly specified not to sort, which means it can be O(N)
instead of O(N + M log M). That’s fine. But some non-<code class="highlight"><c- n>sorted_unique</c-></code> constructors have
Complexity clauses that mandate O(N) performance on input that <em>happens</em> to be sorted
at runtime. The vendor has three ways to deal with this:</p>
   <ul>
    <li data-md>
     <p>Guarantee that <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>sort</c-></code> (or <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>stable_sort</c-></code> if <a href="#stable-sorting">§ 12.1 Stable sorting in insert</a> is adopted) will
always run in O(N) time on sorted input. This is not currently mandated by <a href="https://eel.is/c++draft/alg.sort#sort-5">[alg.sort]</a>,
so no vendor is likely to know off the top of their heads that they really guarantee this
for all possible sorted inputs. libc++ certainly doesn’t know this for sure.</p>
    <li data-md>
     <p>Add a linear-time pass on the front, e.g. <code class="highlight"><c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>std</c-><c- o>::</c-><c- n>is_sorted</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>))</c-> <c- n>std</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>.
This wastes O(N) cycles in every case: it might improve the asymptotic performance in the
rare case that the input happens to be sorted at runtime, but only at the cost of slowing down
the expected case where the input is not sorted. libc++ doesn’t want to slow down the
average caller.</p>
    <li data-md>
     <p>Ignore the spec’s Complexity requirement. libc++ also doesn’t want to do this.</p>
   </ul>
   <p>Louis Dionne would be happy with a resolution that requires all vendors to implement this
optimization in <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>sort</c-></code> itself, for ranges that happen to be sorted. I.e., change <a href="https://eel.is/c++draft/alg.sort#sort-5">[sort]/5</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> 5․ Complexity: Let N be <code class="highlight"><c- n>last</c-> <c- o>-</c-> <c- n>first</c-></code>. <ins>If the input is sorted with respect to <code class="highlight"><c- n>comp</c-></code> and <code class="highlight"><c- n>proj</c-></code>, O(N) comparisons and projections. Otherwise,</ins> O(N log N) comparisons and projections. <ins>In either case, twice as many projections as comparisons.</ins><p></p> </small></blockquote>
   <p>and change <a href="https://eel.is/c++draft/alg.sort#stable.sort-5">[stable.sort]/5</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> 5․ Complexity: Let N be <code class="highlight"><c- n>last</c-> <c- o>-</c-> <c- n>first</c-></code>. <ins>If the input is sorted with respect to <code class="highlight"><c- n>comp</c-></code> and <code class="highlight"><c- n>proj</c-></code>, O(N) comparisons.</ins> If enough extra memory is available, <ins>O(</ins>N log(N)<ins>)</ins> comparisons.
Otherwise, <del>at most</del> <ins>O(</ins>N log<sup>2</sup>(N)<ins>)</ins> comparisons.
In <del>either</del> <ins>any</ins> case, twice as many projections as <del>the number of</del> comparisons.<p></p> </small></blockquote>
   <p>If we changed [alg.sort], then we’d get [flat.foo]'s unusual complexity guarantees for free, and
the following changes in [flat.foo] would be no-ops, just a bit of editorial cleanup.
However, Louis and Arthur would prefer to leave [alg.sort] alone for now,
making the following changes in [flat.foo] significant and non-editorial.</p>
   <h3 class="heading settled" data-level="9.1" id="wording-sorting-complexity"><span class="secno">9.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-sorting-complexity"></a></h3>
   <p>If these changes are not adopted wholesale, we still propose editorially to replace <code class="highlight"><c- n>zip_view</c-></code> with <code class="highlight"><c- n>zip</c-></code> and "if the container arguments are already sorted with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>" with
"if <code class="highlight"><c- n>key_cont</c-></code> is already sorted with respect to <code class="highlight"><c- n>compare</c-></code>."</p>
   <p>Change <a href="https://eel.is/c++draft/flat.map.cons">[flat.map.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
         <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre><p>1․ Effects: Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>,
and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>; sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>; and
finally erases the duplicate elements as if by:</p> <pre class="highlight"><c- k>auto</c-> <c- n>zv</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>zip</c-><del><c- n>_view</c-></del><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>);</c->
<c- k>auto</c-> <c- n>it</c-> <c- o>=</c-> <c- n>ranges</c-><c- o>::</c-><c- n>unique</c-><c- p>(</c-><c- n>zv</c-><c- p>,</c-> <c- n>key_equiv</c-><c- p>(</c-><c- n>compare</c-><c- p>)).</c-><c- n>begin</c-><c- p>();</c->
<c- k>auto</c-> <c- n>dist</c-> <c- o>=</c-> <c- n>distance</c-><c- p>(</c-><c- n>zv</c-><c- p>.</c-><c- n>begin</c-><c- p>(),</c-> <c- n>it</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
<c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>erase</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>begin</c-><c- p>()</c-> <c- o>+</c-> <c- n>dist</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>.</c-><c- n>end</c-><c- p>());</c->
</pre> <p>2․ Complexity: <del>Linear in N if the container arguments are already sorted with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code> and otherwise N log N, where N is the value of <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> <ins>Same as <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>ranges</c-><c- o>::</c-><c- n>zip</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>),</c-> <c- n>value_comp</c-><c- p>())</c-></code>.</ins> </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.cons">[flat.multimap.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
              <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre><p>1․ Effects: Initializes <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>)</c-></code>, <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>values</c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>)</c-></code>,
and <code class="highlight"><c- n>compare</c-></code> with <code class="highlight"><c- n>comp</c-></code>; sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code>.</p> <p>2․ Complexity: <del>Linear in N if the container arguments are already sorted with respect to <code class="highlight"><c- n>value_comp</c-><c- p>()</c-></code> and otherwise N log N, where N is the value of <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> <ins>Same as <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>ranges</c-><c- o>::</c-><c- n>zip</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>,</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>),</c-> <c- n>value_comp</c-><c- p>())</c-></code>.</ins> </p></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.cons">[flat.multiset.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>explicit</c-> <c- n>flat_multiset</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre> <p>1․ Effects: Initializes <i><code class="highlight"><c- n>c</c-></code></i> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <i><code class="highlight"><c- n>compare</c-></code></i> with <code class="highlight"><c- n>comp</c-></code><del>, and</del> <ins>;</ins> sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <i><code class="highlight"><c- n>compare</c-></code></i>.</p> <p>2․ Complexity: <del>Linear in N if <code class="highlight"><c- n>cont</c-></code> is sorted with respect to <i><code class="highlight"><c- n>compare</c-></code></i> and otherwise N log N, where N is the value of <code class="highlight"><c- n>cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> <ins>Same as <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>compare</c-><c- p>)</c-></code>.</ins></p> </small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.cons">[flat.set.cons]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>explicit</c-> <c- n>flat_set</c-><c- p>(</c-><c- n>container_type</c-> <c- n>cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre> <p>1․ Effects: Initializes <i><code class="highlight"><c- n>c</c-></code></i> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>)</c-></code> and <i><code class="highlight"><c- n>compare</c-></code></i> with <code class="highlight"><c- n>comp</c-></code><del>,</del> <ins>;</ins> sorts the range [<code class="highlight"><c- n>begin</c-><c- p>()</c-></code>, <code class="highlight"><c- n>end</c-><c- p>()</c-></code>) with respect to <i><code class="highlight"><c- n>compare</c-></code></i><del>,</del> <ins>;</ins> and finally erases all but the first element from each group of consecutive equivalent elements.</p> <p>2․ Complexity: <del>Linear in N if <code class="highlight"><c- n>cont</c-></code> is sorted with respect to <i><code class="highlight"><c- n>compare</c-></code></i> and otherwise N log N, where N is the value of <code class="highlight"><c- n>cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> before this call.</del> <ins>Same as <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>sort</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>compare</c-><c- p>)</c-></code>.</ins></p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="10" id="replace-by-value"><span class="secno">10. </span><span class="content"><code class="highlight"><c- n>replace</c-></code> should take by value</span><a class="self-link" href="#replace-by-value"></a></h2>
   <p>The current specification for <code class="highlight"><c- n>replace</c-></code> takes the new container(s) by rvalue reference,
which means you can’t just pass in a container the way you can with the <code class="highlight"><c- n>key_cont</c-></code> constructor;
instead, you have to manually <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>move</c-></code> the container.</p>
   <p>This might have been originally intended as a guard against accidental expensive copying of containers.
But C++ doesn’t use this (explicit-pass-by-rvalue-reference) pattern anywhere else; and it’s
inconsistent with the specification of the <code class="highlight"><c- n>key_cont</c-></code> constructors, which do take by value
and happily allow passing in lvalue containers by copy.</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>v</c-> <c- o>=</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>};</c->
<c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-> <c- n>fs</c-><c- p>;</c->

<c- n>fs</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- p>(</c-><c- n>v</c-><c- p>);</c-> <c- c1>// OK</c->
<c- n>fs</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- p>(</c-><c- n>v</c-><c- p>));</c-> <c- c1>// OK</c->

<c- n>fs</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>v</c-><c- p>);</c->
  <c- c1>// Before: Ill-formed</c->
  <c- c1>// After: OK</c->
</pre>
   <p>Taking by value and move-constructing into place is almost always just as performant as
taking by rvalue-reference and move-constructing into place. Caveat: some containers
are expensive to move-construct. <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-></code> is <em>not</em> such a container.
Boost <code class="highlight"><c- n>static_vector</c-></code> is. But we shouldn’t cater for such types, especially not at
the cost of API consistency.</p>
<pre class="highlight"><c- n>boost</c-><c- o>::</c-><c- n>container</c-><c- o>::</c-><c- n>static_vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- mi>100</c-><c- o>></c-> <c- n>v</c-><c- p>;</c->
<c- k>auto</c-> <c- n>fs</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>v</c-><c- p>));</c-> <c- c1>// OK, does 2 expensive moves</c->
<c- n>fs</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>v</c-><c- p>));</c->
  <c- c1>// Before: OK, does 1 expensive move</c->
  <c- c1>// After: OK, does 2 expensive moves</c->
<c- n>fs</c-><c- p>.</c-><c- n>replace</c-><c- p>(</c-><c- n>v</c-><c- p>);</c->
  <c- c1>// Before: Ill-formed</c->
  <c- c1>// After: OK, does 1 expensive copy and 1 expensive move</c->
</pre>
   <h3 class="heading settled" data-level="10.1" id="wording-replace-by-value"><span class="secno">10.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-replace-by-value"></a></h3>
   <p>Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>containers</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
<c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>key_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>mapped_cont</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.map.modifiers#lib:replace,flat_map">[flat.map.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>key_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>mapped_cont</c-><c- p>);</c->
</pre> <p>36․ Preconditions: <code class="highlight"><c- n>key_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-> <c- o>==</c-> <c- n>mapped_cont</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> is <code class="highlight">true</code>, the elements of <code class="highlight"><c- n>key_cont</c-></code> are sorted with respect to <code class="highlight"><c- n>compare</c-></code>,
and <code class="highlight"><c- n>key_cont</c-></code> contains no equal elements.</p> <p>37․ Effects: Equivalent to:</p> <pre class="highlight"><c- n>c</c-><c- p>.</c-><c- n>keys</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>);</c->
<c- n>c</c-><c- p>.</c-><c- n>values</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>containers</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
<c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>key_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>mapped_cont</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>container_type</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
<c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.modifiers#lib:replace,flat_multiset">[flat.multiset.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>cont</c-><c- p>);</c->
</pre> <p>12․ Preconditions: The elements of <code class="highlight"><c- n>cont</c-></code> are sorted with respect to <code class="highlight"><c- n>compare</c-></code>.</p> <p>13․ Effects: Equivalent to: <code class="highlight"><c- n>c</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>);</c-></code></p> </small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>container_type</c-> <c- nf>extract</c-><c- p>()</c-> <c- o>&amp;&amp;</c-><c- p>;</c->
<c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.modifiers#lib:replace,flat_set">[flat.set.modifiers]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- b>void</c-> <c- nf>replace</c-><c- p>(</c-><c- n>container_type</c-><del><c- o>&amp;&amp;</c-></del> <c- n>cont</c-><c- p>);</c->
</pre> <p>12․ Preconditions: The elements of <code class="highlight"><c- n>cont</c-></code> are sorted with respect to <code class="highlight"><c- n>compare</c-></code>, and <code class="highlight"><c- n>cont</c-></code> contains no equal elements.</p> <p>13․ Effects: Equivalent to: <code class="highlight"><c- n>c</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont</c-><c- p>);</c-></code></p> </small>
   </blockquote>
   <h2 class="heading settled" data-level="11" id="keys-method"><span class="secno">11. </span><span class="content">Add <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>keys</c-><c- p>()</c-></code></span><a class="self-link" href="#keys-method"></a></h2>
   <p><code class="highlight"><c- n>flat_map</c-></code> and <code class="highlight"><c- n>flat_multimap</c-></code> both provide <code class="highlight"><c- n>keys</c-><c- p>()</c-></code> and <code class="highlight"><c- n>values</c-><c- p>()</c-></code> getters:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><i><c- c1>// observers</c-></i>
<c- n>key_compare</c-> <c- nf>key_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->
<c- n>value_compare</c-> <c- nf>value_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->

<c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- nf>keys</c-><c- p>()</c-> <c- k>const</c-> <c- k>noexcept</c->      <c- p>{</c-> <c- k>return</c-> <c- n>c</c-><c- p>.</c-><c- n>keys</c-><c- p>;</c-> <c- p>}</c->
<c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- nf>values</c-><c- p>()</c-> <c- k>const</c-> <c- k>noexcept</c-> <c- p>{</c-> <c- k>return</c-> <c- n>c</c-><c- p>.</c-><c- n>values</c-><c- p>;</c-> <c- p>}</c->
</pre></small>
   </blockquote>
   <p><code class="highlight"><c- n>flat_set</c-></code> and <code class="highlight"><c- n>flat_multiset</c-></code> do not:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><i><c- c1>// observers</c-></i>
<c- n>key_compare</c-> <c- nf>key_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->
<c- n>value_compare</c-> <c- nf>value_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->
</pre></small>
   </blockquote>
   <p>libc++ has found that <code class="highlight"><c- p>.</c-><c- n>keys</c-></code> and <code class="highlight"><c- p>.</c-><c- n>values</c-></code> are helpful in unit tests.
The <code class="highlight"><c- p>.</c-><c- n>extract</c-></code> method is a poor replacement.</p>
<pre class="language-c++ highlight"><c- k>auto</c-> <c- n>ks</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>A</c-><c- o>></c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>},</c-> <c- n>A</c-><c- p>(</c-><c- mi>1</c-><c- p>));</c->
<c- k>auto</c-> <c- n>vs</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>A</c-><c- o>></c-><c- p>({</c-><c- mi>4</c-><c- p>,</c-><c- mi>5</c-><c- p>,</c-><c- mi>6</c-><c- p>},</c-> <c- n>A</c-><c- p>(</c-><c- mi>2</c-><c- p>));</c->
<c- k>auto</c-> <c- n>m</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_map</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>ks</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>vs</c-><c- p>));</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>.</c-><c- n>keys</c-><c- p>().</c-><c- n>get_allocator</c-><c- p>()</c-> <c- o>==</c-> <c- n>A</c-><c- p>(</c-><c- mi>1</c-><c- p>));</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>.</c-><c- n>values</c-><c- p>().</c-><c- n>get_allocator</c-><c- p>()</c-> <c- o>==</c-> <c- n>A</c-><c- p>(</c-><c- mi>2</c-><c- p>));</c->
  <c- c1>// convenient</c->

<c- k>auto</c-> <c- n>ks</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>A</c-><c- o>></c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>},</c-> <c- n>A</c-><c- p>(</c-><c- mi>1</c-><c- p>));</c->
<c- k>auto</c-> <c- n>s</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>ks</c-><c- p>));</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>s</c-><c- p>).</c-><c- n>extract</c-><c- p>().</c-><c- n>get_allocator</c-><c- p>()</c-> <c- o>==</c-> <c- n>A</c-><c- p>(</c-><c- mi>1</c-><c- p>));</c->
  <c- c1>// awkward, and modifies the value of s</c->
</pre>
   <p>For a const <code class="highlight"><c- n>flat_set</c-></code>, there’s literally no way to get at the container
and query its properties, such as capacity, allocator, or even size
(which is important for unit tests, if not for real programming).</p>
<pre class="language-c++ highlight"><c- n>using</c-> <c- n>S</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;></c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>A</c-><c- o>>></c-><c- p>;</c->
<c- k>const</c-> <c- n>S</c-> <c- n>s</c-> <c- o>=</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>};</c->
<c- n>assert</c-><c- p>(</c-><c- n>s</c-><c- p>.</c-><c- n>keys</c-><c- p>().</c-><c- n>size</c-><c- p>()</c-> <c- o>==</c-> <c- mi>3</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>s</c-><c- p>.</c-><c- n>keys</c-><c- p>().</c-><c- n>capacity</c-><c- p>()</c-> <c- o>>=</c-> <c- mi>3</c-><c- p>);</c->
  <c- c1>// Before: Impossible to retrieve this information</c->
  <c- c1>// After: OK</c->
</pre>
   <p>Therefore we suggest adding a getter for the <code class="highlight"><c- p>.</c-><c- n>keys</c-></code> of a set, just
like we already have for the flat map types.</p>
   <p>Notice that <code class="highlight"><c- n>flat_map</c-></code>'s <code class="highlight"><c- p>.</c-><c- n>values</c-><c- p>()</c-></code> getter returns a container of <code class="highlight"><c- n>mapped_type</c-></code>,
not a container of <code class="highlight"><c- n>value_type</c-></code>. <code class="highlight"><c- n>flat_set</c-></code> doesn’t have a <code class="highlight"><c- n>mapped_type</c-></code>;
therefore it shouldn’t have <code class="highlight"><c- p>.</c-><c- n>values</c-><c- p>()</c-></code> either.</p>
   <h3 class="heading settled" data-level="11.1" id="wording-keys-method"><span class="secno">11.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-keys-method"></a></h3>
   <p>Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><i><c- c1>// observers</c-></i>
<c- n>key_compare</c-> <c- nf>key_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->
<c- n>value_compare</c-> <c- nf>value_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->

<ins><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- nf>keys</c-><c- p>()</c-> <c- k>const</c-> <c- k>noexcept</c-> <c- p>{</c-> <c- k>return</c-> <i><c- n>c</c-></i><c- p>;</c-> <c- p>}</c-></ins>
</pre></small>
   </blockquote>
   <p>Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><i><c- c1>// observers</c-></i>
<c- n>key_compare</c-> <c- nf>key_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->
<c- n>value_compare</c-> <c- nf>value_comp</c-><c- p>()</c-> <c- k>const</c-><c- p>;</c->

<ins><c- k>const</c-> <c- n>container_type</c-><c- o>&amp;</c-> <c- nf>keys</c-><c- p>()</c-> <c- k>const</c-> <c- k>noexcept</c-> <c- p>{</c-> <c- k>return</c-> <i><c- n>c</c-></i><c- p>;</c-> <c- p>}</c-></ins>
</pre></small>
   </blockquote>
   <h2 class="heading settled" data-level="12" id="issues-for-discussion"><span class="secno">12. </span><span class="content">Issues for discussion</span><a class="self-link" href="#issues-for-discussion"></a></h2>
   <p>The following subsections describe known issues with the flat containers where we
don’t (yet) strongly propose a change. In some cases Louis Dionne asks for further
clarification and/or changes to the wording. In some cases we’re just reporting
implementation experience. In some cases it seems like a change is warranted, but
it’s confusing enough that we don’t have a good wording patch yet.</p>
   <h3 class="heading settled" data-level="12.1" id="stable-sorting"><span class="secno">12.1. </span><span class="content">Stable sorting in <code class="highlight"><c- n>insert</c-></code></span><a class="self-link" href="#stable-sorting"></a></h3>
   <p>For the tree-based associative containers, <a href="https://eel.is/c++draft/associative.reqmts#general-68.sentence-2">[associative.reqmts.general]</a> defines
the single-element <code class="highlight"><c- n>foo</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>val</c-><c- p>)</c-></code> to insert in a well-defined order; <a href="https://eel.is/c++draft/associative.reqmts.general#lib:insert,ordered_associative_containers___">[associative.reqmts.general]</a> defines
the multi-element <code class="highlight"><c- n>foo</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code> to insert in an unspecified order.
Nevertheless, in practice, all three vendors implement the latter as a simple
loop over the former, so we have this de-facto behavior portable everywhere:</p>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>Apathy</c-> <c- p>{</c-> <c- b>bool</c-> <c- nf>operator</c-><c- p>()(</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- p>)</c-> <c- k>const</c-> <c- p>{</c-> <c- k>return</c-> false<c- p>;</c-> <c- p>}</c-> <c- p>};</c->
<c- b>int</c-> <c- n>a</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>,</c-><c- mi>4</c-><c- p>,</c-><c- mi>5</c-><c- p>};</c->
<c- n>std</c-><c- o>::</c-><c- n>multiset</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>Apathy</c-><c- o>></c-> <c- n>s</c-><c- p>;</c->

<c- c1>// #1</c->
<c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>i</c-> <c- o>:</c-> <c- n>a</c-><c- p>)</c-> <c- n>s</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>i</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->

<c- c1>// #2</c->
<c- n>s</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>a</c-><c- p>,</c-> <c- n>a</c-><c- o>+</c-><c- mi>5</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>is_permutation</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de facto portable</c->

<c- c1>// #3</c->
<c- n>s</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>is_permutation</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>s</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de facto portable</c->
</pre>
   <p>Similarly with equivalent keys in a <code class="highlight"><c- n>map</c-></code> or <code class="highlight"><c- n>multimap</c-></code>:</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>pair</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-> <c- n>a</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{{</c-><c- mi>1</c-><c- p>,</c-><c- mi>1</c-><c- p>},{</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>},{</c-><c- mi>1</c-><c- p>,</c-><c- mi>3</c-><c- p>}};</c->
<c- n>std</c-><c- o>::</c-><c- n>map</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- p>,</c-> <c- n>Apathy</c-><c- o>></c-> <c- n>m</c-><c- p>;</c->

<c- c1>// #1</c->
<c- k>for</c-> <c- p>(</c-><c- k>auto</c-> <c- n>kv</c-> <c- o>:</c-> <c- n>a</c-><c- p>)</c-> <c- n>m</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>kv</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>==</c-> <c- mi>1</c-><c- p>);</c-> <c- c1>// de jure</c->

<c- c1>// #2</c->
<c- n>m</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>a</c-><c- p>,</c-> <c- n>a</c-><c- o>+</c-><c- mi>5</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>></c-> <c- mi>0</c-><c- p>);</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>==</c-> <c- mi>1</c-><c- p>);</c-> <c- c1>// de facto portable</c->

<c- c1>// #3</c->
<c- n>m</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>></c-> <c- mi>0</c-><c- p>);</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>m</c-><c- p>[</c-><c- mi>1</c-><c- p>]</c-> <c- o>==</c-> <c- mi>1</c-><c- p>);</c-> <c- c1>// de facto portable</c->
</pre>
   <p>Arthur’s libc++ implementation leans into the idea that <code class="highlight"><c- n>flat_foo</c-></code> is a drop-in replacement for <code class="highlight"><c- n>foo</c-></code>,
and ensures that <code class="highlight"><c- n>flat_foo</c-><c- o>::</c-><c- n>insert</c-><c- p>{,</c-><c- n>_range</c-><c- p>}</c-></code> will behave exactly like <code class="highlight"><c- n>foo</c-><c- o>::</c-><c- n>insert</c-><c- p>{,</c-><c- n>_range</c-><c- p>}</c-></code>.</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>flat_multiset</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>Apathy</c-><c- o>></c-> <c- n>fs</c-><c- p>;</c->

<c- c1>// #1</c->
<c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>i</c-> <c- o>:</c-> <c- n>a</c-><c- p>)</c-> <c- n>fs</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>i</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->

<c- c1>// #2</c->
<c- n>fs</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>a</c-><c- p>,</c-> <c- n>a</c-><c- o>+</c-><c- mi>5</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>is_permutation</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// libc++</c->

<c- c1>// #3</c->
<c- n>fs</c-><c- p>.</c-><c- n>insert_range</c-><c- p>(</c-><c- n>a</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>is_permutation</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// de jure</c->
<c- n>assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>ranges</c-><c- o>::</c-><c- n>equal</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>a</c-><c- p>));</c-> <c- c1>// libc++</c->
</pre>
   <p><code class="highlight"><c- n>flat_foo</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code> is defined by <a href="https://eel.is/c++draft/flat.set.modifiers#lib:insert,flatset">[flat.set.modifiers]</a> to insert in order and then "sort the range." The vendor will be tempted to use <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>sort</c-></code>,
which in practice is not stable. Arthur’s implementation uses <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>stable_sort</c-></code> specifically
to ensure that <code class="highlight"><c- n>fs</c-></code> will give the same results as <code class="highlight"><c- n>s</c-></code> for all multi-element insertions.</p>
   <p>Louis Dionne worries that by providing this additional de-facto guarantee, libc++ might be creating
a "portability trap" — the programmer writes obvious code that works perfectly on libc++, and then when
the programmer migrates to libstdc++ or Microsoft STL, they suddenly find that their code no longer works.</p>
   <p>Therefore Louis asks whether LWG could <em>specifically require</em> that newly inserted elements be sorted stably, e.g.</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>InputIterator</c-><c- o>></c->
  <c- b>void</c-> <c- n>insert</c-><c- p>(</c-><c- n>InputIterator</c-> <c- n>first</c-><c- p>,</c-> <c- n>InputIterator</c-> <c- n>last</c-><c- p>);</c->
</pre> <p>5․ Effects: Adds elements to <code class="highlight"><c- n>c</c-></code> as if by:</p> <pre class="highlight"><c- n>c</c-><c- p>.</c-><c- n>insert</c-><c- p>(</c-><c- n>c</c-><c- p>.</c-><c- n>end</c-><c- p>(),</c-> <c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>);</c->
</pre><p>Then, <ins>stably</ins> sorts the range of newly inserted elements with respect to <code class="highlight"><c- n>compare</c-></code>;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases all but the first element from each group of consecutive equivalent elements.</p> <p>6․ Complexity: N + M log M, where N is <code class="highlight"><c- n>size</c-><c- p>()</c-></code> before the operation and M is <code class="highlight"><c- n>distance</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>.</p> <p>7․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</p> </small>
   </blockquote>
   <p>This operation already requires an in-place merge, which allocates memory,
so requiring it to also do a stable sort — which allocates memory — might not be considered such a big deal.</p>
   <p>The alternative here would be for libc++ to lean into the idea that <code class="highlight"><c- n>multiset</c-><c- o>::</c-><c- n>insert_range</c-></code> is supposed to
leave the order of equivalent elements unspecified, and instrument it under libc++'s existing <code class="highlight"><c- n>_LIBCPP_DEBUG_RANDOMIZE_UNSPECIFIED_STABILITY</c-></code> flag (currently used only for <code class="highlight"><c- n>sort</c-></code>, <code class="highlight"><c- n>nth_element</c-></code>, and <code class="highlight"><c- n>partial_sort</c-></code>).
This would preserve the symmetry between <code class="highlight"><c- n>multiset</c-></code> and <code class="highlight"><c- n>flat_multiset</c-></code>, by making both of them de facto
randomized order (at least in debug mode).</p>
   <h3 class="heading settled" data-level="12.2" id="deceptive"><span class="secno">12.2. </span><span class="content">Non-explicit constructor from two containers</span><a class="self-link" href="#deceptive"></a></h3>
   <p>Arthur has observed <a href="https://quuxplusone.github.io/blog/2023/04/28/flat-map-constructors/">in a blog post</a> that <code class="highlight"><c- n>flat_map</c-></code>'s non-explicit constructor from two containers is deceptive when used with braced initializers.</p>
<pre class="language-c++ highlight"><c- b>void</c-> <c- nf>print_map</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>flat_multimap</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- b>int</c-><c- o>></c-><c- p>);</c->

<c- c1>// Test the two-container constructor... or is it?</c->

<c- n>print_map</c-><c- p>({</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>3</c-><c- p>},</c-> <c- p>{</c-><c- mi>10</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>30</c-><c- p>}</c-> <c- p>});</c-> <c- c1>// {1,10}, {2,20}, {3,30}</c->
<c- n>print_map</c-><c- p>({</c-> <c- p>{</c-><c- mi>1</c-><c- p>,</c-> <c- mi>2</c-><c- p>},</c->    <c- p>{</c-><c- mi>10</c-><c- p>,</c-> <c- mi>20</c-><c- p>}</c-> <c- p>});</c->     <c- c1>// {1,2}, {10,20}</c->
<c- n>print_map</c-><c- p>({</c-> <c- p>{</c-><c- mi>1</c-><c- p>},</c->       <c- p>{</c-><c- mi>10</c-><c- p>}</c-> <c- p>});</c->         <c- c1>// {1,10}</c->
<c- n>print_map</c-><c- p>({</c-> <c- p>{},</c->        <c- p>{}</c-> <c- p>});</c->           <c- c1>// {0,0}, {0,0}</c->
</pre>
   <p>To address this issue (if we wanted to), we could make one of the relevant constructors <code class="highlight"><c- k>explicit</c-></code>.
We obviously can’t prevent <code class="highlight"><c- n>vector</c-></code>'s construction from a braced list
of elements, nor <code class="highlight"><c- n>pair</c-></code>'s from a braced list of (exactly two) elements, nor (in practice) <code class="highlight"><c- n>pair</c-></code>'s construction from <code class="highlight"><c- p>{}</c-></code>; so the only constructor we could explicify to address this
would be <code class="highlight"><c- n>flat_multimap</c-></code>'s own constructor from a braced list of (exactly two) containers. That is,
we’d do this (and likewise in <code class="highlight"><c- n>flat_map</c-></code>; <code class="highlight"><c- n>flat_set</c-></code> doesn’t need to change):</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><ins><c- k>explicit</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>)</c-></ins>
  <ins><c- o>:</c-> <c- n>flat_multimap</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>key_cont</c-><c- p>),</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>mapped_cont</c-><c- p>),</c-> <c- n>key_compare</c-><c- p>())</c-> <c- p>{}</c-></ins>
<c- n>flat_multimap</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
              <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <del><c- o>=</c-> <c- n>key_compare</c-><c- p>()</c-></del><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
                <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Allocator</c-><c- o>></c->
  <c- n>flat_multimap</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
                <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Allocator</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Arthur thinks this change would be appreciated by programmers in practice (or rather, if we <em>don’t</em> make this change, then programmers will only ever notice this issue when it bites them).
But it would be surprisingly asymmetric to explicify only this one constructor. The small benefit
probably does not justify the asymmetry.</p>
   <p>We recently made some constructors <code class="highlight"><c- k>explicit</c-></code> in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2711r1.html">P2711 "Making multi-param constructors of views explicit,"</a> but that paper’s goal was to <em>increase</em> uniformity and symmetry, not to decrease it.</p>
   <h3 class="heading settled" data-level="12.3" id="complexity-equal-range"><span class="secno">12.3. </span><span class="content">Complexity of <code class="highlight"><c- n>equal_range</c-></code></span><a class="self-link" href="#complexity-equal-range"></a></h3>
   <p><a href="https://eel.is/c++draft/associative.reqmts.general#171">[associative.reqmts.general]/171 and /174</a> define the complexity of <code class="highlight"><c- n>b</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- n>k</c-><c- p>)</c-></code> and <code class="highlight"><c- n>a_tran</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- n>ke</c-><c- p>)</c-></code> as "Logarithmic."
This means that we have the following required complexities, for both <code class="highlight"><c- n>foo</c-></code> and <code class="highlight"><c- n>flat_foo</c-></code>:</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>s</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>multiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>ms</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>></c-> <c- n>st</c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>multiset</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>></c-> <c- n>mst</c-><c- p>;</c->

<c- n>s</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- n>s</c-><c- p>);</c->
  <c- c1>// 171: lower_bound, lower_bound+1; (1 + lg N) operations total</c->
<c- n>ms</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- n>s</c-><c- p>);</c->
  <c- c1>// 171: lower_bound, upper_bound; (2 lg N) operations total</c->
<c- n>st</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- p>);</c->
  <c- c1>// 174: lower_bound, upper_bound; (2 lg N) operations total</c->
<c- n>mst</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- p>);</c->
  <c- c1>// 174: lower_bound, upper_bound; (2 lg N) operations total</c->
</pre>
   <p>For <code class="highlight"><c- n>st</c-><c- p>.</c-><c- n>equal_range</c-></code>, <a href="https://eel.is/c++draft/associative.reqmts.general#7.22">[associative.reqmts.general]/7.22</a> forces us to consider the possibility that <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>::</c-><c- k>operator</c-><c- p>()(</c-><c- n>key_type</c-><c- p>,</c-> <c- k>const</c-> <c- b>char</c-><c- o>*</c-><c- p>)</c-></code> is a less granular equivalence relation than <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>::</c-><c- k>operator</c-><c- p>()(</c-><c- n>key_type</c-><c- p>,</c-> <c- n>key_type</c-><c- p>)</c-></code>; i.e., even though
this is a <code class="highlight"><c- n>set</c-></code>, it might still contain "duplicates" from the point of view of the heterogeneous comparator.
It would be efficient in practice to find <code class="highlight"><c- n>lower_bound</c-><c- p>(</c-><c- s>"abc"</c-><c- p>)</c-></code> in lg N time and then step forward linearly
until we find an element not equal to <code class="highlight"><c- s>"abc"</c-></code> — the expected number of duplicates for the average real-world workload
is small. But the number of duplicates <em>theoretically</em> could be O(N); so we’re not allowed to do this
(at least not without an arbitrary cap, e.g. if we don’t find the end of the range in 10 probes then fall back
to <code class="highlight"><c- n>upper_bound</c-></code> — bookkeeping which would again unnecessarily slow down the average case).</p>
   <p>Consider a working programmer who writes</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- o>></c-> <c- n>s</c-><c- p>;</c->
<c- n>s</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- p>);</c->
  <c- c1>// lower_bound, lower_bound+1; (1 + lg N) operations total</c->
</pre>
   <p>and then switches to a heterogeneous comparator in an effort to "speed up" the code
by avoiding the conversion to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>string</c-></code>:</p>
<pre class="language-c++ highlight"><c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>string</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;>></c-> <c- n>st</c-><c- p>;</c->
<c- n>st</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- s>"abc"</c-><c- p>);</c->
  <c- c1>// lower_bound, upper_bound; (2 lg N) operations total, cache-unfriendly</c->
</pre>
   <p>libc++ would like to see vendors given a little more freedom to experiment here.</p>
   <p>The proposed wording below doesn’t require any vendor to change their implementation,
since an existing implementation in O(log N) certainly also satisfies O(M + log N).</p>
   <h4 class="heading settled" data-level="12.3.1" id="wording-complexity-equal-range"><span class="secno">12.3.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-complexity-equal-range"></a></h4>
   <p>Change <a href="https://eel.is/c++draft/associative.reqmts.general#171">[associative.reqmts.general]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- n>a_tran</c-><c- p>.</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>ku</c-><c- p>)</c->
</pre> <p>166․ Result: <code class="highlight"><c- n>iterator</c-></code>; <code class="highlight"><c- n>const_iterator</c-></code> for constant <code class="highlight"><c- n>a_tran</c-></code>.</p> <p>167․ Returns: An iterator pointing to the first element with key <code class="highlight"><c- n>r</c-></code> such that <code class="highlight"><c- n>c</c-><c- p>(</c-><c- n>ku</c-><c- p>,</c-> <c- n>r</c-><c- p>)</c-></code>, or <code class="highlight"><c- n>a_tran</c-><c- p>.</c-><c- n>end</c-><c- p>()</c-></code> if such an element is not found.</p> <p>168․ Complexity: Logarithmic.</p> <pre class="highlight"><c- n>b</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- n>k</c-><c- p>)</c->
</pre> <p>169․ Result: <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- n>iterator</c-><c- o>></c-></code>; <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>const_iterator</c-><c- p>,</c-> <c- n>const_iterator</c-><c- o>></c-></code> for constant <code class="highlight"><c- n>b</c-></code>.</p> <p>170․ Effects: Equivalent to: <code class="highlight"><c- k>return</c-> <c- n>make_pair</c-><c- p>(</c-><c- n>b</c-><c- p>.</c-><c- n>lower_bound</c-><c- p>(</c-><c- n>k</c-><c- p>),</c-> <c- n>b</c-><c- p>.</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>k</c-><c- p>));</c-></code></p> <p>171․ Complexity: <del>Logarithmic.</del> <ins>O(M + log N), where N is <code class="highlight"><c- n>b</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> and M is <code class="highlight"><c- n>distance</c-><c- p>(</c-><c- n>b</c-><c- p>.</c-><c- n>lower_bound</c-><c- p>(</c-><c- n>k</c-><c- p>),</c-> <c- n>b</c-><c- p>.</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>k</c-><c- p>))</c-></code>.</ins></p> <pre class="highlight"><c- n>a_tran</c-><c- p>.</c-><c- n>equal_range</c-><c- p>(</c-><c- n>ke</c-><c- p>)</c->
</pre> <p>172․ Result: <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- n>iterator</c-><c- o>></c-></code>; <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>const_iterator</c-><c- p>,</c-> <c- n>const_iterator</c-><c- o>></c-></code> for constant <code class="highlight"><c- n>a_tran</c-></code>.</p> <p>173․ Effects: Equivalent to: <code class="highlight"><c- k>return</c-> <c- n>make_pair</c-><c- p>(</c-><c- n>a_tran</c-><c- p>.</c-><c- n>lower_bound</c-><c- p>(</c-><c- n>ke</c-><c- p>),</c-> <c- n>a_tran</c-><c- p>.</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>ke</c-><c- p>));</c-></code></p> <p>174․ Complexity: <del>Logarithmic.</del> <ins>O(M + log N), where N is <code class="highlight"><c- n>a_tran</c-><c- p>.</c-><c- n>size</c-><c- p>()</c-></code> and M is <code class="highlight"><c- n>distance</c-><c- p>(</c-><c- n>a_tran</c-><c- p>.</c-><c- n>lower_bound</c-><c- p>(</c-><c- n>ke</c-><c- p>),</c-> <c- n>a_tran</c-><c- p>.</c-><c- n>upper_bound</c-><c- p>(</c-><c- n>ke</c-><c- p>))</c-></code>.</ins></p> </small>
   </blockquote>
   <h3 class="heading settled" data-level="12.4" id="special-members"><span class="secno">12.4. </span><span class="content">Special member functions</span><a class="self-link" href="#special-members"></a></h3>
   <p><a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> currently does not declare
any special member functions. This implies that they are defaulted, which implicitly specifies
their constexprness, noexceptness, and triviality.</p>
   <p>All three C++20 container adaptors (e.g. <a href="https://eel.is/c++draft/priqueue.overview">[priqueue.overview]</a>)
follow that approach, too.</p>
   <p>All four associative and four unordered containers (e.g. <a href="https://eel.is/c++draft/set.overview">[set.overview]</a>)
explicitly provide signatures for all five special members, including the destructor, like
this:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight">    <c- n>set</c-><c- p>(</c-><c- k>const</c-> <c- n>set</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c->
    <c- n>set</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>);</c->
<c- p>[...]</c->
    <c- o>~</c-><c- n>set</c-><c- p>();</c->
    <c- n>set</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- k>const</c-> <c- n>set</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>);</c->
    <c- n>set</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;&amp;</c-> <c- n>x</c-><c- p>)</c->
      <c- k>noexcept</c-><c- p>(</c-><c- n>allocator_traits</c-><c- o>&lt;</c-><c- n>Allocator</c-><c- o>>::</c-><c- n>is_always_equal</c-><c- o>::</c-><c- n>value</c-> <c- o>&amp;&amp;</c->
               <c- n>is_nothrow_move_assignable_v</c-><c- o>&lt;</c-><c- n>Compare</c-><c- o>></c-><c- p>);</c->
</pre></small>
   </blockquote>
   <p>Should <code class="highlight"><c- n>flat_set</c-></code>'s spec hew more closely to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>set</c-></code>'s or <code class="highlight"><c- n>priority_queue</c-></code>'s?
We tentatively think <code class="highlight"><c- n>set</c-></code>'s is the better model, so that the vendor would be free to
make the special members non-defaulted. Vendors are still permitted to strengthen the
noexceptness and/or triviality of declared functions; for example, both libc++ and libstdc++
make <code class="highlight"><c- n>set</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> conditionally noexcept.</p>
<pre class="language-c++ highlight"><c- n>using</c-> <c- n>V</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>experimental</c-><c- o>::</c-><c- n>fixed_capacity_vector</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- mi>100</c-><c- o>></c-><c- p>;</c->
<c- k>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_destructible_v</c-><c- o>&lt;</c-><c- n>V</c-><c- o>></c-><c- p>);</c->
<c- n>using</c-> <c- n>M</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-><c- p>,</c-> <c- n>V</c-><c- o>></c-><c- p>;</c->
<c- k>static_assert</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>is_trivially_destructible_v</c-><c- o>&lt;</c-><c- n>M</c-><c- o>></c-><c- p>);</c->
  <c- c1>// Before: Mandatory.</c->
  <c- c1>// After: Permitted but not mandatory.</c->
</pre>
   <h3 class="heading settled" data-level="12.5" id="move-from-comparator"><span class="secno">12.5. </span><span class="content">Moving from the comparator</span><a class="self-link" href="#move-from-comparator"></a></h3>
   <p>As shown above, the associative and unordered containers give their move-assignment operator
a noexcept-spec that strongly implies it must move-from the comparator, never copy it.
This particularly affects libstdc++, where <code class="highlight"><c- n>set</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> will copy a stateful comparator
(e.g. <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-></code>) instead of moving-from it, but <code class="highlight"><c- n>set</c-><c- o>::</c-><c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> must move
the comparator, leaving the source object in a "radioactive" state.</p>
   <p>This whole area is the subject of <a data-link-type="biblio" href="#biblio-lwg2227" title="Stateful comparison objects in associative containers">[LWG2227]</a> "Stateful comparison objects in associative containers,"
and is certainly beyond the scope of this paper P2767.</p>
<pre class="language-c++ highlight"><c- k>struct</c-> <c- nc>TestLess</c-> <c- o>:</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;></c-> <c- p>{</c->
  <c- c1>// make this too big to fit in the small buffer</c->
  <c- b>char</c-> <c- n>pad_</c-><c- p>[</c-><c- mi>1000</c-><c- p>];</c->
<c- p>};</c->
<c- n>using</c-> <c- n>C</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>function</c-><c- o>&lt;</c-><c- b>bool</c-><c- p>(</c-><c- b>int</c-><c- p>,</c-><c- b>int</c-><c- p>)</c-><c- o>></c-><c- p>;</c->
<c- n>std</c-><c- o>::</c-><c- n>set</c-><c- o>&lt;</c-><c- b>int</c-><c- p>,</c-> <c- n>C</c-><c- o>></c-> <c- n>s</c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>},</c-> <c- n>C</c-><c- p>(</c-><c- n>TestLess</c-><c- p>()));</c->
<c- n>assert</c-><c- p>(</c-><c- n>s</c-><c- p>.</c-><c- n>key_comp</c-><c- p>()</c-> <c- o>!=</c-> <c- n>nullptr</c-><c- p>);</c->
<c- k>auto</c-> <c- n>t</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>s</c-><c- p>);</c->
<c- n>assert</c-><c- p>(</c-><c- n>s</c-><c- p>.</c-><c- n>key_comp</c-><c- p>()</c-> <c- o>!=</c-> <c- n>nullptr</c-><c- p>);</c->
  <c- c1>// libstdc++: Succeeds</c->
  <c- c1>// libc++: Fails</c->
<c- n>s</c-><c- p>.</c-><c- n>clear</c-><c- p>();</c->
<c- n>s</c-><c- p>.</c-><c- n>insert</c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>});</c->
  <c- c1>// libstdc++: OK</c->
  <c- c1>// libc++: Throws std::bad_function_call</c->
<c- n>t</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>s</c-><c- p>);</c->
<c- n>s</c-><c- p>.</c-><c- n>insert</c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>});</c->
  <c- c1>// Everyone: Throws std::bad_function_call</c->
</pre>
   <p>If we user-declare <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>flat_set</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code>,
we must decide whether to give it a similar noexcept-spec.</p>
   <h4 class="heading settled" data-level="12.5.1" id="wording-special-members"><span class="secno">12.5.1. </span><span class="content">Possible wording</span><a class="self-link" href="#wording-special-members"></a></h4>
   <p>(This wording merge-conflicts with the resolution of <a data-link-type="biblio" href="#biblio-lwg3884" title="flat_foo is missing allocator-extended copy/move constructors">[LWG3884]</a>, which in turn merge-conflicts
with the editorial refactoring at the beginning of this paper P2767. We can polish it later;
the first question is whether LWG wants to pursue this direction at all.)</p>
   <p>For example, change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.map.cons], constructors</c->
<c- n>flat_map</c-><c- p>()</c-> <c- o>:</c-> <c- n>flat_map</c-><c- p>(</c-><c- n>key_compare</c-><c- p>())</c-> <c- p>{</c-> <c- p>}</c->

<ins><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>flat_map</c-><c- o>&amp;</c-><c- p>);</c-></ins>
<ins><c- n>flat_map</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;&amp;</c-><c- p>);</c-></ins>
<ins><c- n>flat_map</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- k>const</c-> <c- n>flat_multimap</c-><c- o>&amp;</c-><c- p>);</c-></ins>
<ins><c- n>flat_map</c-><c- o>&amp;</c-> <c- k>operator</c-><c- o>=</c-><c- p>(</c-><c- n>flat_multimap</c-><c- o>&amp;&amp;</c-><c- p>)</c-></ins>
  <ins><c- k>noexcept</c-><c- p>(</c-><c- n>is_nothrow_move_assignable_v</c-><c- o>&lt;</c-><c- n>KeyContainer</c-><c- o>></c-> <c- o>&amp;&amp;</c-></ins>
           <ins><c- n>is_nothrow_move_assignable_v</c-><c- o>&lt;</c-><c- n>MappedContainer</c-><c- o>></c-> <c- o>&amp;&amp;</c-></ins>
           <ins><c- n>is_nothrow_move_assignable_v</c-><c- o>&lt;</c-><c- n>Compare</c-><c- o>></c-><c- p>);)</c-></ins>
<ins><c- o>~</c-><c- n>flat_map</c-><c- p>();</c-></ins>

<c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-> <c- n>mapped_cont</c-><c- p>,</c->
         <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-> <c- o>=</c-> <c- n>key_compare</c-><c- p>());</c->
</pre></small>
   </blockquote>
   <h3 class="heading settled" data-level="12.6" id="qualifies-container"><span class="secno">12.6. </span><span class="content">"Qualifies as a container"</span><a class="self-link" href="#qualifies-container"></a></h3>
   <p>Arthur’s libc++ implements an alternative resolution to <a data-link-type="biblio" href="#biblio-lwg3803" title="flat_foo constructors taking KeyContainer lack KeyCompare parameter">[LWG3803]</a>. This resolution applies
generally to all container adaptors, and has the advantage of not ad-hoc relying on a
complicated type trait (<code class="highlight"><c- n>is_invocable</c-></code>) but being a little more consistent with the
pre-existing spec.</p>
   <p>The choice of <code class="highlight"><c- n>C</c-><c- o>::</c-><c- n>const_iterator</c-></code> is simply because <code class="highlight"><c- n>T</c-><c- o>::</c-><c- n>value_type</c-></code> is already present
for allocators, and <code class="highlight"><c- n>T</c-><c- o>::</c-><c- n>iterator</c-></code> is already present for many iterators (those that inherit
from <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>iterator</c-></code>, for example). We could just as well choose a criterion like
"The expression <code class="highlight"><c- n>declval</c-><c- o>&lt;</c-><c- n>C</c-><c- o>&amp;></c-><c- p>().</c-><c- n>size</c-><c- p>()</c-></code> is well-formed when treated as an unevaluated operand."</p>
   <h4 class="heading settled" data-level="12.6.1" id="wording-qualifies-container"><span class="secno">12.6.1. </span><span class="content">Wording</span><a class="self-link" href="#wording-qualifies-container"></a></h4>
   <p>
    Arthur’s preferred resolution is shown in 
    <ins>this color</ins>
    .
Parts of the current C++23 Working Draft that were introduced by the adopted
resolution of LWG3803, but would be removed by this change, are shown in 
    <src>this color</src>
    .
   </p>
   <p>Change <a href="https://eel.is/c++draft/container.requirements#container.reqmts-69">[container.reqmts]/69</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> 69․ The behavior of certain container member functions and deduction guides depends on whether types qualify as
input iterators<ins>, containers,</ins> or allocators.<p></p> <p><ins>x․</ins> The extent to which an implementation determines that a type cannot be an input iterator is unspecified,
except that as a minimum integral types shall not qualify as input iterators. </p><p><ins>x․</ins> <del>Likewise, the</del> <ins>The</ins> extent to which an implementation determines that a type cannot be an allocator is unspecified,
except that as a minimum a type <code class="highlight"><c- n>A</c-></code> shall not qualify as an allocator unless it meets both of the following conditions: </p><ul><li data-md><p>(69.1) The qualified-id <code class="highlight"><c- n>A</c-><c- o>::</c-><c- n>value_type</c-></code> is valid and denotes a type ([temp.deduct]).</p> </li><li data-md><p>(69.2) The expression <code class="highlight"><c- n>declval</c-><c- o>&lt;</c-><c- n>A</c-><c- o>&amp;></c-><c- p>().</c-><c- n>allocate</c-><c- p>(</c-><c- b>size_t</c-><c- p>{})</c-></code> is well-formed when treated as an unevaluated operand.</p> </li></ul> <p><ins>x․ The extent to which an implementation determines that a type cannot be a container
is unspecified, except that as a minimum a type C shall not qualify as a container
unless the qualified-id <code class="highlight"><c- n>C</c-><c- o>::</c-><c- n>const_iterator</c-></code> is valid and denotes a type.</ins> </p></small></blockquote>
   <p>Change <a href="https://eel.is/c++draft/container.adaptors.general">[container.adaptors.general]/6</a> as follows:</p>
   <p><small></small></p>
   <blockquote><small> 6․ A deduction guide for a container adaptor shall not participate in overload resolution if any of the following are true:<p></p> <ul><li data-md><p>(6.1) It has an <code class="highlight"><c- n>InputIterator</c-></code> template parameter and a type that does not qualify as an input iterator is deduced for that parameter.</p> </li><li data-md><p>(6.2) It has a <code class="highlight"><c- n>Compare</c-></code> template parameter and a type that qualifies as an allocator is deduced for that parameter.</p> </li><li data-md><p>(6.3) It has a <code class="highlight"><c- n>Container</c-></code>, <code class="highlight"><c- n>KeyContainer</c-></code>, or <code class="highlight"><c- n>MappedContainer</c-></code> template parameter
 and a type that <del>qualifies as an allocator</del> <ins>does not qualify as a container</ins> is deduced for that parameter.</p> </li><li data-md><p>(6.4) It has no <code class="highlight"><c- n>Container</c-></code>, <code class="highlight"><c- n>KeyContainer</c-></code>, or <code class="highlight"><c- n>MappedContainer</c-></code> template parameter,
 and it has an <code class="highlight"><c- n>Allocator</c-></code> template parameter, and a type that does not qualify as an allocator is deduced for that parameter.</p> </li><li data-md><p>(6.5) It has both <code class="highlight"><c- n>Container</c-></code> and <code class="highlight"><c- n>Allocator</c-></code> template parameters, and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>Container</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">false</code>.</p> </li><li data-md><p>(6.6) It has both <code class="highlight"><c- n>KeyContainer</c-></code> and <code class="highlight"><c- n>Allocator</c-></code> template parameters, and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>KeyContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">false</code>.</p> </li><li data-md><src>(6.7) It has both <code class="highlight"><c- n>KeyContainer</c-></code> and <code class="highlight"><c- n>Compare</c-></code> template parameters, and</src> <pre class="highlight"><src><c- n>is_invocable_v</c-><c- o>&lt;</c-><c- k>const</c-> <c- n>Compare</c-><c- o>&amp;</c-><c- p>,</c-></src>
              <src><c- k>const</c-> <c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>&amp;</c-><c- p>,</c-></src>
              <src><c- k>const</c-> <c- k>typename</c-> <c- nc>KeyContainer</c-><c- o>::</c-><c- n>value_type</c-><c- o>&amp;></c-></src>
</pre><src>is not a valid expression or is <code class="highlight">false</code>.</src> </li><li data-md><p>(6.8) It has both <code class="highlight"><c- n>MappedContainer</c-></code> and <code class="highlight"><c- n>Allocator</c-></code> template parameters, and <code class="highlight"><c- n>uses_allocator_v</c-><c- o>&lt;</c-><c- n>MappedContainer</c-><c- p>,</c-> <c- n>Allocator</c-><c- o>></c-></code> is <code class="highlight">false</code>.</p> </li></ul> </small></blockquote>
   <h3 class="heading settled" data-level="12.7" id="iterator-types"><span class="secno">12.7. </span><span class="content"><code class="highlight"><c- n>iterator</c-></code> and <code class="highlight"><c- n>const_iterator</c-></code></span><a class="self-link" href="#iterator-types"></a></h3>
   <p><code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>iterator</c-></code> and <code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>const_iterator</c-></code> are presented as if they could be
two different types. This is consistent with how we do it in <code class="highlight"><c- n>set</c-></code> and <code class="highlight"><c- n>unordered_set</c-></code>.
But in practice, all three vendors make <code class="highlight"><c- n>set</c-><c- o>::</c-><c- n>iterator</c-></code> and <code class="highlight"><c- n>set</c-><c- o>::</c-><c- n>const_iterator</c-></code> the
same type. We should consider refactoring the spec of <code class="highlight"><c- n>set</c-></code>, <code class="highlight"><c- n>unordered_set</c-></code>, and <code class="highlight"><c- n>flat_set</c-></code> all at once to <em>mandate</em> that these iterator types be the same type, the same way we
already do for <a href="https://eel.is/c++draft/string.view#footnote-207"><code class="highlight"><c- n>basic_string_view</c-></code></a> and (since C++23 introduced <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>const_iterator</c-></code>) <a href="https://eel.is/c++draft/span.overview"><code class="highlight"><c- n>span</c-><c- o>&lt;</c-><c- k>const</c-> <c- n>T</c-><c- o>></c-></code></a>.</p>
   <p>This would allow us to remove a lot of redundant overloads from the specification,
e.g. we don’t need both <code class="highlight"><c- n>iterator</c-> <c- n>find</c-><c- p>(</c-><c- n>value_type</c-><c- p>)</c-></code> and <code class="highlight"><c- n>const_iterator</c-> <c- n>find</c-><c- p>(</c-><c- n>value_type</c-><c- p>)</c-> <c- k>const</c-></code> if those are the same iterator type. Vendors can already do this removal in their implementations
if they choose to. This is merely a question of our getting to do it in the paper specification too,
under the banner of "standardizing existing practice."</p>
   <h3 class="heading settled" data-level="12.8" id="containers"><span class="secno">12.8. </span><span class="content">Support for non-standard containers</span><a class="self-link" href="#containers"></a></h3>
   <p>Vendors are required to support "random-access containers," which means <code class="highlight"><c- n>vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code> (except for <code class="highlight"><c- n>vector</c-><c- o>&lt;</c-><c- b>bool</c-><c- o>></c-></code>)
and <code class="highlight"><c- n>deque</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>. It’s unclear if vendors are required to support non-standard containers such as <code class="highlight"><c- n>boost</c-><c- o>::</c-><c- n>container</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>; and if so, what public API those containers must provide in order
to interoperate with <code class="highlight"><c- n>flat_set</c-></code>.</p>
   <p>For example, suppose the underlying container supports <code class="highlight"><c- n>C</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code> but not <code class="highlight"><c- n>C</c-><c- p>(</c-><c- n>from_range</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code>. Then I would expect that I couldn’t initialize a <code class="highlight"><c- n>flat_set</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>Compare</c-><c- p>,</c-> <c- n>C</c-><c- o>></c-></code> with <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>from_range</c-><c- p>,</c-> <c- n>rg</c-><c- p>)</c-></code>; but I should still be able to initialize it with <code class="highlight"><c- n>flat_set</c-><c- p>(</c-><c- n>first</c-><c- p>,</c-> <c- n>last</c-><c- p>)</c-></code>,
right? It would be nice to see what’s required and what’s encouraged in this area.</p>
   <p>libc++ goes very slightly out of its way to support <code class="highlight"><c- n>vector</c-><c- o>&lt;</c-><c- b>bool</c-><c- o>></c-></code> as the underlying container,
even though we believe we’re not required to support it.</p>
   <h3 class="heading settled" data-level="12.9" id="redundancy"><span class="secno">12.9. </span><span class="content">Inconsistent handling of redundancy in [flat.multiset] and [flat.multimap]</span><a class="self-link" href="#redundancy"></a></h3>
   <p>See <a href="https://github.com/cplusplus/draft/pull/6246#issuecomment-1539789693">#6246</a>.</p>
   <p><a href="https://eel.is/c++draft/flat.multiset#overview-4">[flat.multiset.overview/4]</a> uses
the same boilerplate as <code class="highlight"><c- n>vector</c-></code>, <code class="highlight"><c- n>set</c-></code>, <code class="highlight"><c- n>flat_set</c-></code>, and <code class="highlight"><c- n>flat_map</c-></code>:</p>
   <p><small></small></p>
   <blockquote><small> Descriptions are provided here only for operations on <code class="highlight"><c- n>flat_multiset</c-></code> that are not described
in one of the general sections or for operations where there is additional semantic information.<p></p> </small></blockquote>
   <p><a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview/4]</a> uses
different boilerplate:</p>
   <p><small></small></p>
   <blockquote><small> Except as otherwise noted, operations on <code class="highlight"><c- n>flat_multimap</c-></code> are equivalent to those of <code class="highlight"><c- n>flat_map</c-></code>,
except that <code class="highlight"><c- n>flat_multimap</c-></code> operations do not remove or replace elements with equal keys.<p></p> <p>[Example 1: <code class="highlight"><c- n>flat_multimap</c-></code> constructors and emplace do not erase non-unique elements after sorting them. —end example]</p> </small></blockquote>
   <p>That’s a little handwavey: It doesn’t bother to explain that <code class="highlight"><c- n>flat_multimap</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>sorted_equivalent_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- p>)</c-></code> is "equivalent to" <code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>initializer_list</c-><c- p>)</c-></code>. It doesn’t bother to explain how
the <code class="highlight"><c- n>iterator</c-></code> return value of <code class="highlight"><c- n>flat_multimap</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code> is derived from the <code class="highlight"><c- n>pair</c-><c- o>&lt;</c-><c- n>iterator</c-><c- p>,</c-> <c- b>bool</c-><c- o>></c-></code> return value of <code class="highlight"><c- n>flat_map</c-><c- o>::</c-><c- n>insert</c-><c- p>(</c-><c- n>value_type</c-><c- o>&amp;&amp;</c-><c- p>)</c-></code>.</p>
   <p>But it does make the spec a lot shorter! Should we apply the same technique to [flat.multiset]
that we already apply to [flat.multimap]? I haven’t written wording for this yet, but can do so
if LWG is interested.</p>
   <p>Vice versa, should we tweak [flat.multimap]'s wording to address the two "doesn’t bother" points above?
Should we tweak it to say "equivalent keys" or "duplicate keys" instead of "equal keys"?</p>
   <h3 class="heading settled" data-level="12.10" id="noexcept-swap"><span class="secno">12.10. </span><span class="content">Noexcept <code class="highlight"><c- n>swap</c-></code></span><a class="self-link" href="#noexcept-swap"></a></h3>
   <p>This area seems to have been tweaked quite a bit at Batavia 2018.
See <a href="https://wiki.edg.com/bin/view/LWGBatavia2018/WednesdayAMMinutes">the minutes</a>.</p>
   <p><code class="highlight"><c- n>flat_set</c-><c- o>::</c-><c- n>swap</c-></code> is currently specified as unconditionally noexcept, which is inconsistent both
with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>set</c-></code> and with the pre-existing adaptors.</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.set.defn]</c->
<c- b>void</c-> <c- nf>swap</c-><c- p>(</c-><c- n>flat_set</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c->

<c- c1>// [priqueue.overview]</c->
<c- b>void</c-> <c- nf>swap</c-><c- p>(</c-><c- n>priority_queue</c-><c- o>&amp;</c-> <c- n>q</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>(</c-><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>Container</c-><c- o>></c-> <c- o>&amp;&amp;</c->
                                      <c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>Compare</c-><c- o>></c-><c- p>)</c->
  <c- p>{</c-> <c- k>using</c-> <c- n>std</c-><c- o>::</c-><c- n>swap</c-><c- p>;</c-> <c- n>swap</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>q</c-><c- p>.</c-><c- n>c</c-><c- p>);</c-> <c- n>swap</c-><c- p>(</c-><c- n>comp</c-><c- p>,</c-> <c- n>q</c-><c- p>.</c-><c- n>comp</c-><c- p>);</c-> <c- p>}</c->

<c- c1>// [set.overview]</c->
<c- b>void</c-> <c- nf>swap</c-><c- p>(</c-><c- n>set</c-><c- o>&amp;</c-><c- p>)</c->
  <c- k>noexcept</c-><c- p>(</c-><c- n>allocator_traits</c-><c- o>&lt;</c-><c- n>Allocator</c-><c- o>>::</c-><c- n>is_always_equal</c-><c- o>::</c-><c- n>value</c-> <c- o>&amp;&amp;</c->
           <c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>Compare</c-><c- o>></c-><c- p>);</c->
</pre><p><a href="https://eel.is/c++draft/associative.reqmts#except-3">[associative.reqmts.except]/3</a>:
For associative containers, no <code class="highlight"><c- n>swap</c-></code> function throws an exception unless that exception
is thrown by the swap of the container’s <code class="highlight"><c- n>Compare</c-></code> object (if any).</p> </small>
   </blockquote>
   <p>Suppose the underlying container has a throwing move-constructor (like MSVC <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>list</c-></code>), and lacks a custom <code class="highlight"><c- n>swap</c-></code>;
then <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>swap</c-><c- o>&lt;</c-><c- n>Container</c-><c- o>></c-></code> can throw. Or, suppose the underlying container is <code class="highlight"><c- n>boost</c-><c- o>::</c-><c- n>container</c-><c- o>::</c-><c- n>static_vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-></code>;
then its <code class="highlight"><c- n>swap</c-></code> must swap <code class="highlight"><c- n>T</c-></code> objects, which can throw.</p>
   <p>Now, what happens if swapping the containers actually does throw? Then both containers are in an unknown
state, so we must restore the invariant by clearing both containers. We do the same thing if <code class="highlight"><c- n>insert</c-></code> or <code class="highlight"><c- n>erase</c-></code> throws, so this is nothing new.</p>
   <p>What happens if swapping the comparators throws? Then we cannot recover. Louis suggests adding <code class="highlight"><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>Compare</c-><c- o>></c-></code> as a constraint. The intent is nicely ergonomic:
Almost all comparators are nothrow swappable (including <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-></code>, if we want to support that: <a data-link-type="biblio" href="#biblio-lwg2227" title="Stateful comparison objects in associative containers">[LWG2227]</a>).
And the resulting behavior seems better: In the pathological corner case where <code class="highlight"><c- n>flat_set</c-></code> cannot safely provide
swappability, it’s better for it not to be swappable at all, than for it to falsely advertise a
noexcept <code class="highlight"><c- n>swap</c-></code>. But, if we constrain away <code class="highlight"><c- n>flat_set</c-></code>'s hidden-friend <code class="highlight"><c- n>swap</c-></code>, <code class="highlight"><c- n>swap</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>fs</c-><c- p>)</c-></code> will still
compile; it’ll just fall back to <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>swap</c-><c- o>&lt;</c-><c- n>T</c-><c- o>></c-> <c- p>[</c-><c- n>with</c-> <c- n>T</c-><c- o>=</c-><c- n>flat_set</c-><c- p>]</c-></code>. We could actually <code class="highlight"><c- o>=</c-><c- k>delete</c-></code> the <code class="highlight"><c- n>swap</c-></code> function, like this:</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight">    <del><c- b>void</c-> <c- nf>swap</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-> <c- k>noexcept</c-><c- p>;</c-></del>
    <ins><c- b>void</c-> <c- nf>swap</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-></ins>
      <ins><c- k>noexcept</c-><c- p>(</c-><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- o>></c-> <c- o>&amp;&amp;</c-></ins>
               <ins><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- o>></c-><c- p>)</c-></ins>
      <ins><c- k>requires</c-> <c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>key_compare</c-><c- o>></c-></ins>
    <c- b>void</c-> <c- n>clear</c-><c- p>()</c-> <c- k>noexcept</c-><c- p>;</c->

<c- p>[...]</c->

    <del><c- k>friend</c-> <c- b>void</c-> <c- n>swap</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>,</c-> <c- n>flat_map</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-> <c- k>noexcept</c-> <c- p>{</c-> <c- n>x</c-><c- p>.</c-><c- n>swap</c-><c- p>(</c-><c- n>y</c-><c- p>);</c-> <c- p>}</c-></del>
    <ins><c- k>friend</c-> <c- b>void</c-> <c- n>swap</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>,</c-> <c- n>flat_map</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-></ins>
      <ins><c- k>noexcept</c-><c- p>(</c-><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>key_container_type</c-><c- o>></c-> <c- o>&amp;&amp;</c-></ins>
               <ins><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>mapped_container_type</c-><c- o>></c-><c- p>)</c-></ins>
      <ins><c- k>requires</c-> <c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>key_compare</c-><c- o>></c-></ins>
        <ins><c- p>{</c-> <c- n>x</c-><c- p>.</c-><c- n>swap</c-><c- p>(</c-><c- n>y</c-><c- p>);</c-> <c- p>}</c-></ins>
    <ins><c- k>friend</c-> <c- b>void</c-> <c- n>swap</c-><c- p>(</c-><c- n>flat_map</c-><c- o>&amp;</c-> <c- n>x</c-><c- p>,</c-> <c- n>flat_map</c-><c- o>&amp;</c-> <c- n>y</c-><c- p>)</c-></ins>
      <ins><c- k>requires</c-> <c- p>(</c-><c- o>!</c-><c- n>is_nothrow_swappable_v</c-><c- o>&lt;</c-><c- n>key_compare</c-><c- o>></c-><c- p>)</c-> <c- o>=</c-> <c- k>delete</c-><c- p>;</c-></ins>
</pre></small>
   </blockquote>
   <p>but even then <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-><c- p>(</c-><c- n>fs</c-><c- p>,</c-> <c- n>fs</c-><c- p>)</c-></code> would still compile; it would just fall back to the
three-step move-and-assign.</p>
   <h4 class="heading settled" data-level="12.10.1" id="ranges-swap"><span class="secno">12.10.1. </span><span class="content">Specified in terms of <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-></code></span><a class="self-link" href="#ranges-swap"></a></h4>
   <p>Orthogonally: It surprises us that [flat.map.modifiers] specifies <code class="highlight"><c- n>swap</c-></code>'s
implementation in terms of <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>y</c-><c- p>.</c-><c- n>c</c-><c- p>)</c-></code> etc. This feels overspecified; <a href="https://eel.is/c++draft/container.reqmts#49">[container.reqmts]</a> adequately covers the semantics of swapping,
and vendors should be able to decide for themselves how to swap comparator objects, just like
we do in <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>set</c-></code>. Arguably the tight specification helps programmers providing their own
underlying containers: they know they just need to provide an ADL <code class="highlight"><c- n>swap</c-></code> or the requirements
of <a href="https://eel.is/c++draft/concept.swappable#2.3.sentence-1">[concept.swappable]/2.3</a>.
But one might point out to those programmers that their underlying container
must provide the API required in <a href="https://eel.is/c++draft/container.reqmts#49">[container.reqmts]/49–51</a>,
so the vendor can use ADL <code class="highlight"><c- n>swap</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>y</c-><c- p>.</c-><c- n>c</c-><c- p>)</c-></code> or <code class="highlight"><c- n>c</c-><c- p>.</c-><c- n>swap</c-><c- p>(</c-><c- n>y</c-><c- p>.</c-><c- n>c</c-><c- p>)</c-></code> if they want to.</p>
   <p>libc++'s implementation currently uses ADL <code class="highlight"><c- n>swap</c-><c- p>(</c-><c- n>c</c-><c- p>,</c-> <c- n>y</c-><c- p>.</c-><c- n>c</c-><c- p>)</c-></code>, which is equivalent to <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-></code> for all containers satisfying <a href="https://eel.is/c++draft/container.reqmts#51">[container.reqmts]/51</a>;
but the difference between <code class="highlight"><c- n>swap</c-><c- p>(</c-><c- n>compare</c-><c- p>,</c-> <c- n>y</c-><c- p>.</c-><c- n>compare</c-><c- p>)</c-></code> and <code class="highlight"><c- n>ranges</c-><c- o>::</c-><c- n>swap</c-><c- p>(</c-><c- n>compare</c-><c- p>,</c-> <c- n>y</c-><c- p>.</c-><c- n>compare</c-><c- p>)</c-></code> is probably observable.</p>
   <h3 class="heading settled" data-level="12.11" id="lwg-3802"><span class="secno">12.11. </span><span class="content">Allocator-extended constructors lack move semantics</span><a class="self-link" href="#lwg-3802"></a></h3>
   <p>libc++ has implemented move-aware allocator-extended constructors for all four flat containers
(<a href="https://godbolt.org/z/We7K1K6bE">Godbolt</a>).</p>
<pre class="language-c++ highlight"><c- n>template</c-><c- o>&lt;</c-><c- n>class</c-> <c- n>T</c-><c- p>,</c-> <c- n>class</c-> <c- n>C</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>less</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c->
<c- n>using</c-> <c- n>PmrFlatSet</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- o>&lt;</c-><c- n>T</c-><c- p>,</c-> <c- n>C</c-><c- p>,</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>T</c-><c- o>>></c-><c- p>;</c->

<c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>monotonic_buffer_resource</c-> <c- n>mr</c-><c- p>;</c->
<c- k>auto</c-> <c- n>sets</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>PmrFlatSet</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-><c- p>(</c-><c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- k>auto</c-> <c- n>cont1</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- b>int</c-><c- o>></c-><c- p>({</c-><c- mi>1</c-><c- p>,</c-><c- mi>2</c-><c- p>,</c-><c- mi>3</c-><c- p>},</c-> <c- o>&amp;</c-><c- n>mr</c-><c- p>);</c->
<c- n>sets</c-><c- p>.</c-><c- n>emplace_back</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont1</c-><c- p>));</c->
  <c- c1>// Before: Makes copies of all the data</c->
  <c- c1>// After: Takes ownership of the existing data</c->

<c- k>auto</c-> <c- n>cont2</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>pmr</c-><c- o>::</c-><c- n>vector</c-><c- o>&lt;</c-><c- n>std</c-><c- o>::</c-><c- n>unique_ptr</c-><c- o>&lt;</c-><c- b>int</c-><c- o>>></c-><c- p>();</c->
<c- k>auto</c-> <c- n>fs</c-> <c- o>=</c-> <c- n>std</c-><c- o>::</c-><c- n>flat_set</c-><c- p>(</c-><c- n>std</c-><c- o>::</c-><c- n>move</c-><c- p>(</c-><c- n>cont2</c-><c- p>));</c->
  <c- c1>// Before: Ill-formed</c->
  <c- c1>// After: OK</c->
</pre>
   <p>This is <a data-link-type="biblio" href="#biblio-lwg3802" title="flat_foo allocator-extended constructors lack move semantics">[LWG3802]</a>. The wording patch for this (based on top of P2767’s editorial refactoring)
would look something like this. I haven’t written wording for this yet, but can do so,
if LWG is interested, after P2767’s editorial refactoring is merged.</p>
   <p><small></small></p>
   <blockquote>
    <p></p>
    <small> <pre class="highlight"><c- c1>// [flat.map.cons.alloc], constructors with allocators</c->

<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-> <c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c->
  <c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c->
           <c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c->
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- k>const</c-> <c- n>key_container_type</c-><c- o>&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>mapped_container_type</c-><c- o>&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
<ins><c- k>template</c-><c- o>&lt;</c-><c- k>class</c-> <c- nc>Alloc</c-><c- o>></c-></ins>
  <ins><c- n>flat_map</c-><c- p>(</c-><c- n>sorted_unique_t</c-><c- p>,</c-> <c- n>key_container_type</c-><c- o>&amp;&amp;</c-> <c- n>key_cont</c-><c- p>,</c-></ins>
           <ins><c- n>mapped_container_type</c-><c- o>&amp;&amp;</c-> <c- n>mapped_cont</c-><c- p>,</c-></ins>
           <ins><c- k>const</c-> <c- n>key_compare</c-><c- o>&amp;</c-> <c- n>comp</c-><c- p>,</c-> <c- k>const</c-> <c- n>Alloc</c-><c- o>&amp;</c-> <c- n>a</c-><c- p>);</c-></ins>
</pre></small>
   </blockquote>
   <h2 class="heading settled" data-level="13" id="experience"><span class="secno">13. </span><span class="content">Implementation experience</span><a class="self-link" href="#experience"></a></h2>
   <p>I have implemented all of <a data-link-type="biblio" href="#biblio-p0429" title="A standard flat_map">[P0429]</a>/<a data-link-type="biblio" href="#biblio-p1222" title="A standard flat_set">[P1222]</a> and all of this proposal
as a series of patches against libc++ trunk; see <a data-link-type="biblio" href="#biblio-patch" title="[libc++] trivially_relocatable branch">[Patch]</a>.
You can experiment with it <a href="https://godbolt.org/z/Trneaj4Mo">on Godbolt Compiler Explorer</a>;
just use the P1144 branch of Clang, which uses this patched libc++ by default.</p>
   <h2 class="heading settled" data-level="14" id="acknowledgments"><span class="secno">14. </span><span class="content">Acknowledgments</span><a class="self-link" href="#acknowledgments"></a></h2>
   <ul>
    <li data-md>
     <p>Thanks to Tomasz Kamiński for recommending Arthur write this paper.</p>
    <li data-md>
     <p>Thanks to Louis Dionne for his code review of libc++'s <code class="highlight"><c- n>flat_set</c-></code> implementation.</p>
   </ul>
  </main>
<script>
(function() {
  "use strict";
  var collapseSidebarText = '<span aria-hidden="true">←</span> '
                          + '<span>Collapse Sidebar</span>';
  var expandSidebarText   = '<span aria-hidden="true">→</span> '
                          + '<span>Pop Out Sidebar</span>';
  var tocJumpText         = '<span aria-hidden="true">↑</span> '
                          + '<span>Jump to Table of Contents</span>';

  var sidebarMedia = window.matchMedia('screen and (min-width: 78em)');
  var autoToggle   = function(e){ toggleSidebar(e.matches) };
  if(sidebarMedia.addListener) {
    sidebarMedia.addListener(autoToggle);
  }

  function toggleSidebar(on) {
    if (on == undefined) {
      on = !document.body.classList.contains('toc-sidebar');
    }

    /* Don’t scroll to compensate for the ToC if we’re above it already. */
    var headY = 0;
    var head = document.querySelector('.head');
    if (head) {
      // terrible approx of "top of ToC"
      headY += head.offsetTop + head.offsetHeight;
    }
    var skipScroll = window.scrollY < headY;

    var toggle = document.getElementById('toc-toggle');
    var tocNav = document.getElementById('toc');
    if (on) {
      var tocHeight = tocNav.offsetHeight;
      document.body.classList.add('toc-sidebar');
      document.body.classList.remove('toc-inline');
      toggle.innerHTML = collapseSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, 0 - tocHeight);
      }
      tocNav.focus();
      sidebarMedia.addListener(autoToggle); // auto-collapse when out of room
    }
    else {
      document.body.classList.add('toc-inline');
      document.body.classList.remove('toc-sidebar');
      toggle.innerHTML = expandSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, tocNav.offsetHeight);
      }
      if (toggle.matches(':hover')) {
        /* Unfocus button when not using keyboard navigation,
           because I don’t know where else to send the focus. */
        toggle.blur();
      }
    }
  }

  function createSidebarToggle() {
    /* Create the sidebar toggle in JS; it shouldn’t exist when JS is off. */
    var toggle = document.createElement('a');
      /* This should probably be a button, but appearance isn’t standards-track.*/
    toggle.id = 'toc-toggle';
    toggle.class = 'toc-toggle';
    toggle.href = '#toc';
    toggle.innerHTML = collapseSidebarText;

    sidebarMedia.addListener(autoToggle);
    var toggler = function(e) {
      e.preventDefault();
      sidebarMedia.removeListener(autoToggle); // persist explicit off states
      toggleSidebar();
      return false;
    }
    toggle.addEventListener('click', toggler, false);


    /* Get <nav id=toc-nav>, or make it if we don’t have one. */
    var tocNav = document.getElementById('toc-nav');
    if (!tocNav) {
      tocNav = document.createElement('p');
      tocNav.id = 'toc-nav';
      /* Prepend for better keyboard navigation */
      document.body.insertBefore(tocNav, document.body.firstChild);
    }
    /* While we’re at it, make sure we have a Jump to Toc link. */
    var tocJump = document.getElementById('toc-jump');
    if (!tocJump) {
      tocJump = document.createElement('a');
      tocJump.id = 'toc-jump';
      tocJump.href = '#toc';
      tocJump.innerHTML = tocJumpText;
      tocNav.appendChild(tocJump);
    }

    tocNav.appendChild(toggle);
  }

  var toc = document.getElementById('toc');
  if (toc) {
    createSidebarToggle();
    toggleSidebar(sidebarMedia.matches);

    /* If the sidebar has been manually opened and is currently overlaying the text
       (window too small for the MQ to add the margin to body),
       then auto-close the sidebar once you click on something in there. */
    toc.addEventListener('click', function(e) {
      if(e.target.tagName.toLowerCase() == "a" && document.body.classList.contains('toc-sidebar') && !sidebarMedia.matches) {
        toggleSidebar(false);
      }
    }, false);
  }
  else {
    console.warn("Can’t find Table of Contents. Please use <nav id='toc'> around the ToC.");
  }

  /* Wrap tables in case they overflow */
  var tables = document.querySelectorAll(':not(.overlarge) > table.data, :not(.overlarge) > table.index');
  var numTables = tables.length;
  for (var i = 0; i < numTables; i++) {
    var table = tables[i];
    var wrapper = document.createElement('div');
    wrapper.className = 'overlarge';
    table.parentNode.insertBefore(wrapper, table);
    wrapper.appendChild(table);
  }

})();
</script>
  <h2 class="no-num no-ref heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>
  <h3 class="no-num no-ref heading settled" id="informative"><span class="content">Informative References</span><a class="self-link" href="#informative"></a></h3>
  <dl>
   <dt id="biblio-lwg2227">[LWG2227]
   <dd>Juan Soulie. <a href="https://cplusplus.github.io/LWG/issue2227"><cite>Stateful comparison objects in associative containers</cite></a>. December 2012. URL: <a href="https://cplusplus.github.io/LWG/issue2227">https://cplusplus.github.io/LWG/issue2227</a>
   <dt id="biblio-lwg3802">[LWG3802]
   <dd>Arthur O'Dwyer. <a href="https://cplusplus.github.io/LWG/issue3802"><cite>flat_foo allocator-extended constructors lack move semantics</cite></a>. October 2022. URL: <a href="https://cplusplus.github.io/LWG/issue3802">https://cplusplus.github.io/LWG/issue3802</a>
   <dt id="biblio-lwg3803">[LWG3803]
   <dd>Arthur O'Dwyer. <a href="https://cplusplus.github.io/LWG/issue3803"><cite>flat_foo constructors taking KeyContainer lack KeyCompare parameter</cite></a>. October 2022. URL: <a href="https://cplusplus.github.io/LWG/issue3803">https://cplusplus.github.io/LWG/issue3803</a>
   <dt id="biblio-lwg3884">[LWG3884]
   <dd>Arthur O'Dwyer. <a href="https://cplusplus.github.io/LWG/issue3884"><cite>flat_foo is missing allocator-extended copy/move constructors</cite></a>. February 2023. URL: <a href="https://cplusplus.github.io/LWG/issue3884">https://cplusplus.github.io/LWG/issue3884</a>
   <dt id="biblio-p0429">[P0429]
   <dd>Zach Laine. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf"><cite>A standard flat_map</cite></a>. June 2022. URL: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf</a>
   <dt id="biblio-p1163">[P1163]
   <dd>Nevin Liber. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1163r0.pdf"><cite>Explicitly implicifying explicit constructors</cite></a>. August 2018. URL: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1163r0.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1163r0.pdf</a>
   <dt id="biblio-p1222">[P1222]
   <dd>Zach Laine. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf"><cite>A standard flat_set</cite></a>. June 2022. URL: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf</a>
   <dt id="biblio-p2363">[P2363]
   <dd>Konstantin Boyarinov; Sergey Vinogradov; Ruslan Arutyunyan. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html"><cite>Extending associative containers with the remaining heterogeneous overloads</cite></a>. February 2023. URL: <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html</a>
   <dt id="biblio-patch">[Patch]
   <dd>Arthur O'Dwyer. <a href="https://github.com/Quuxplusone/llvm-project/compare/main...trivially-relocatable"><cite>[libc++] trivially_relocatable branch</cite></a>. May 2023. URL: <a href="https://github.com/Quuxplusone/llvm-project/compare/main...trivially-relocatable">https://github.com/Quuxplusone/llvm-project/compare/main...trivially-relocatable</a>
  </dl>