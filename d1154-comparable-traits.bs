<pre class='metadata'>
Title: Type traits for structural comparison
Shortname: D1154
Revision: 2
!Draft Revision: 8
Audience: LWG
Status: D
Group: WG21
URL:
!Current Source: <a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d1154-comparable-traits.bs">github.com/Quuxplusone/draft/blob/gh-pages/d1154-comparable-traits.bs</a>
!Current: <a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d1154-comparable-traits.html">rawgit.com/Quuxplusone/draft/gh-pages/d1154-comparable-traits.html</a>
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Editor: Jeff Snyder, jeff-isocpp@caffeinated.me.uk
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  Now that [[P0732|P0732R2 "Class Types in Non-Type Template Parameters"]] has been adopted,
  we propose the new type-trait <code>has_strong_structural_equality&lt;T&gt;</code>.
  Code is more robust and maintainable when we can <code>static_assert</code> this property.
Date: 2019-03-10
</pre>

<style>
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>

# Changelog # {#changelog}

- R2 (post-Kona):

    - Removed five of the six proposed type-traits at LEWG's request (see [[#polls]]).
        LEWG voted to forward this version to LWG for C++2a.


# Strong structural equality should be static-assertable # {#structural-equality}

The concept of "having strong structural equality" that was introduced by [[P0732]] will become important
to programmers. Take this class type for example:

```c++
template<std::size_t N>
struct fixed_string
{
    constexpr fixed_string(const char (&s)[N+1])
        { std::copy_n(s, N+1, m_data); }
    auto operator<=>(const fixed_string &) const = default;
    char m_data[N+1];
};
```

This type's `operator<=>` is a "structural comparison operator"
because it is defaulted, and invokes only other structural comparison operators. Since it yields
`strong_ordering`, it also has what we might call "strong structural ordering",
although this term is not introduced by P0732.
"Strong structural ordering" is a stricter requirement than P0732's "strong structural equality,"
which is the prerequisite to use a user-defined type as a non-type template parameter.

C++ should permit the programmer to test the presence or absence of this property.
Example:

```c++
static_assert(std::has_strong_structural_equality_v< fixed_string<5> >);
```

This permits maintainability-minded programmers to express their intention in code.

```c++
template<std::size_t N>
struct broken_fixed_string
{
    constexpr broken_fixed_string(const char (&s)[N+1])
        { std::copy_n(s, N+1, m_data); }
    auto operator<=>(const broken_fixed_string &rhs) const
        { return std::memcmp(m_data, rhs.m_data, N+1) <=> 0; }
    char m_data[N+1];
};
static_assert(std::has_strong_structural_equality_v< broken_fixed_string<5> >,
    "broken_fixed_string lacks the strong structural equality we expected");

// ... possibly many lines of code here ...
// ... possibly written by a different programmer ...

template<auto V> struct A {};
A<broken_fixed_string("hello")> a;
```

In the snippet above, we get a nice descriptive `static_assert` failure, instead of an
unfriendly spew of diagnostics on the line that tries to instantiate `A`.


# This feature benefits from compiler support # {#compiler-builtin}

P1154R0 claimed that this type-trait could not be implemented without a compiler builtin.
In fact, `has_strong_structural_equality` *can* be implemented according to standard C++17:

```c++
template<auto> struct A {};

template<class T, template<T> class = A> using B = void;

template<class T, class = void>
struct HasStrongStructuralEquality : std::false_type {};

template<class T>
struct HasStrongStructuralEquality<T, B<T>> : std::true_type {};

static_assert(HasStrongStructuralEquality< int >::value);
static_assert(!HasStrongStructuralEquality< std::string >::value);
```

This code relies on subtle and maybe-uncertain rules governing when
`template<auto> struct A` is a valid argument for a parameter of type
`template<T> class`.

- GCC currently does not support this code â€” that is,
    they fail the second `static_assert`.

- MSVC flatly rejects it because they don't support `auto` template parameters yet.

- Clang accepts this code. The worst that can be said of Clang
    is that they give the wrong answer for `HasStrongStructuralEquality<int&&>`,
    but that can easily be worked around on the library side.

Right now the burden is on the application programmer to know this trivia
and come up with workarounds for GCC and MSVC. We propose to simplify the programmer's job
by putting this trait into the standard library, where the burden will be on the library
to get it right (probably using a compiler builtin).


# Provide just the one type trait # {#batteries-included}

P1154R1 proposed six type-traits, with implementations shown in terms of a
hypothetical compiler builtin `__has_structural_comparison(T)`. After the adoption
of [[P1185]], the general notion of "structural comparison" is no longer meaningful; the
new core-language feature is "strong structural equality" (only).

Strong structural equality may be provided by a structural (defaulted) `operator<=>`
or by a structural (defaulted) `operator==`. In the latter case, the type might not
support `operator<=>` at all.

Therefore we propose only the following type-trait, with accompanying `_v` variable template.
For exposition purposes only, we provide a sample implementation in terms of
a hypothetical compiler builtin `__has_strong_structural_equality(T)`.

<small>
```c++
template<class T> struct has_strong_structural_equality :
    bool_constant< __has_strong_structural_equality(T) > {};
```
</small>


# Proposed wording for C++2a # {#wording}

Add one new entry to Table 47 in <a href="http://eel.is/c++draft/meta.unary.prop">[meta.unary.prop]</a>:

<small><blockquote>
<table>
<tr><th>Template</th><th>Condition</th><th>Preconditions</th></tr>
<tr>
<td>`template<class T> struct has_strong_structural_equality;`</td>
<td>The type `T` has strong structural equality (10.10.1).</td>
<td>T shall be a complete type, <i>cv</i> `void`, or an array of unknown bound.</td>
</tr>
</table>
</blockquote></small>


# Straw polls taken of LEWG in Kona (2019-02-18) # {#polls}

<table class="def">
<tr><th style="width: 70%;"></th><th>**SF**</th><th>**F**</th><th>**N**</th><th>**A**</th><th>**SA**</th></tr>

<tr><th><small>We want all of the traits [from P1154R1] (rather than just strong structural equality).</th>
<th>0</th><th>2</th><th>4</th><th>0</th><th>3</th></tr>

<tr><th><small>Drop everything but `has_strong_structural_equality[_v]`, make sure to coordinate with [[P1185]], and forward to LWG for C++20.</th>
<th>3</th><th>5</th><th>1</th><th>0</th><th>0</th></tr>
</table>

<pre class=biblio>
{
  "D1354": {
    "title": "SG7 Guidelines for Review of Proposals",
    "authors": [
        "Chandler Carruth"
    ],
    "href": "http://wiki.edg.com/pub/Wg21sandiego2018/SG7/d1354r0.html",
    "date": "November 2018"
  },
  "P0732": {
    "title": "Class Types in Non-Type Template Parameters",
    "authors": [
        "Jeff Snyder",
        "Louis Dionne"
    ],
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0732r2.pdf",
    "date": "June 2018"
  },
  "P1185": {
    "title": "<=> != ==",
    "authors": [
        "Barry Revzin"
    ],
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1185r1.html",
    "date": "January 2019"
  }
}
</pre>
