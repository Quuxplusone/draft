<pre class='metadata'>
Title: Object relocation in terms of move plus destroy
Shortname: D1144
Revision: 0
Audience: LEWG, EWG
Status: D
Group: WG21
URL:
!Current Source: <a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d1144.bs">github.com/Quuxplusone/draft/blob/gh-pages/d1144.bs</a>
!Current: <a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d1132.html">rawgit.com/Quuxplusone/draft/gh-pages/d1132.html</a>
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Editor: Mingxin Wang, wmx16835vv@163.com
Abstract:
  We define a verb `relocate`, tantamount to a move and a destroy, analogous to the existing verb `swap` which is tantamount to a move, two move-assignments, and a destroy.
  We observe that the `relocate` operation for most (but not all) C++ types is tantamount to `memcpy`.
  We provide a type-trait to detect situations when `relocate` is known to be tantamount to `memcpy`, for the benefit of library implementors.
  Finally, we provide a portable way for any user-defined type (such as `boost::shared_ptr`) to warrant to the compiler that its `relocate` operation is equivalent to `memcpy`, thus gaining the same performance benefits as the standard library types.
Date: 2018-07-06
Markup Shorthands: markdown yes, biblio yes, markup yes
</pre>

<style>
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>

# Revision History # {#changelog}

## Revision 0 ## {#changelog-r0}

    Initial revision.

# Introduction and motivation # {#intro}

If you are reading this paper, and you have not yet watched Arthur's session from C++Now 2018
on "The Best Type Traits C++ Doesn't Have," it will help if you immediately stop reading and
[[https://www.youtube.com/watch?v=MWBfmmg8-Yo|go watch]]
the first 30 minutes of that video at 2x speed with the captions turned on.<sup><a href="#fn_Best">[Best]</a></sup>
It's going to be worth your 15 minutes. I'll wait.

In the video, besides showing implementation techniques and benchmark results, we defined our
terms. These terms are summarized briefly below.

C++ has the verbs "move," "copy," and "destroy." To this list we propose to add the verb "relocate."
Given an object type <code>T</code> and memory addresses <code>src</code> and <code>dst</code>,
the phrase "<em>relocate</em> a <code>T</code> from <code>src</code> to <code>dst</code>" means no more and no
less than "<em>move-construct</em> <code>dst</code> from <code>src</code>, and then immediately
<em>destroy</em> the object at <code>src</code>."
From this verb, we get the adjective "relocatable." Any type which is both move-constructible and
destructible is <i>relocatable</i>. The notion can be modified by adverbs: we say that a type
is "nothrow relocatable" if its relocation operation is noexcept, and we say that a type
is "trivially relocatable" if its relocation operation is trivial (which, just like trivial move-construction
and trivial copy-construction, means "the operation is tantamount to a <code>memcpy</code>").

Almost all relocatable types are trivially relocatable: <code>std::unique_ptr&lt;int&gt;</code>,
<code>std::vector&lt;int&gt;</code>, <code>std::string</code>, <code>std::any</code>. Non-trivially relocatable
types exist but are rare: <code>boost::interprocess::offset_ptr&lt;int&gt;</code>, TODO FIXME BUG HACK.

Arthur has established (via benchmarks<sup><a href="#fn_Bench">[Bench]</a></sup> such as those shown in the video)
that if standard library code had a reliable way of detecting "trivial relocatability," we could optimize
that case and get a speed boost of up to 3x on routines that perform reallocation, such as

```c++
    std::vector&lt;R>::resize
    std::vector&lt;R>::reserve
    std::vector&lt;R>::emplace_back
    std::vector&lt;R>::push_back
```

Furthermore, Mingxin Wang points out that we can use the same "trivially relocatability" property to shrink the code
generated by small-buffer-optimized (SBO) type-erasing wrappers such as <code>std::function</code> and <code>std::any</code>.
For these types, a <i>move</i> of the wrapper object is implemented in terms of a
<i>relocation</i> of the contained object. (See for example
[[https://github.com/llvm-mirror/libcxx/blob/8fdc491860efbccb65ab2f01ec25e13b024da538/include/any#L389-L394|libc++'s `std::any`]],
where the function that performs the relocation operation is confusingly named <code>__move</code>.)
In general, the <i>relocate</i> operation for a contained type <code>C</code> involves calls to <code>C</code>'s
move constructor and destructor, which must be uniquely codegenned for each different <code>C</code>; the
number of instantiations of <i>relocate</i> scales linearly with the count of distinct types <code>C</code>
in the program.
But for any trivially relocatable <code>C</code>, its <i>relocate</i> operation depends only on the number of
bytes being <code>memcpy</code>ed, and so the number of instantiations of <i>relocate</i> scales linearly with the count
of distinct <em>sizes</em> of <code>C</code> being used in the program; or indeed, linearly with the count
of distinct <em>sizes of SBO buffer</em> being used in the program.

A smaller number of instantiations means faster compile times, a smaller text section, and perhaps
"hotter" code (because a relatively higher proportion of your code now fits in icache).

In between these two scenarios, we also find the move-constructor of <code>fixed_capacity_vector&lt;R,N></code>,
which can be implemented as an element-by-element <i>move</i> (leaving the source vector's elements in their
moved-from state), or can be implemented more efficiently as an element-by-element <i>relocate</i> (leaving
the source vector empty).

Note:
The name <code>fixed_capacity_vector</code> is my preferred name for the type
that Boost.Container calls <code>static_vector</code>.
<code>boost::container::static_vector&lt;R,N></code> implements the
less efficient element-by-element-move strategy; moving-out-of a
<code>boost::container::static_vector</code> will not make the source vector
<code>empty()</code>.


# Design goals # {#design-goals}

Every C++ type already <i>is</i> or <i>is not</i> trivially relocatable. This proposal is not about
"making more types trivially relocatable."

The optimizations discussed above are purely in the domain of library vendors. If you're writing
a vector, and you detect that your element type <code>T</code> is trivially relocatable, then
whether you do any special optimization in that case is merely a Quality of Implementation (QoI) issue.
This proposal is not about "standardizing certain library optimizations."

What C++ lacks is a standard way for library vendors to <i>detect</i> the (existing) trivial relocatability
of a type <code>T</code>, so that they can reliably apply their (existing) optimizations.
All we really need is to add <i>detection</i>, and then all the optimizations described above will naturally
emerge without any further special effort by WG21.

Today we can detect the trivial relocatability of several of these categories, via the following definition.
We'll take this as our starting point.

```c++
    #include &lt;type_traits>
    template&lt;class T>
    struct is_trivially_relocatable : bool_constant&lt;
        is_trivially_move_constructible_v&lt;T> and
        is_trivially_destructible_v&lt;T>
    > {};

    auto lam = [x=42]{};
    static_assert(is_trivially_relocatable&lt; int >::value);
    static_assert(is_trivially_relocatable&lt; decltype(lam) >::value);
```

## Important use case \#1: Standard library types such as `std::string` ## {#use1}

In order to optimize <code>std::vector&lt;std::string>::resize</code>, we must come up with a way to achieve
```c++
    #include &lt;string>
    static_assert(is_trivially_relocatable&lt; std::string >::value);
```
This could be done unilaterally by the library vendor, via a non-standard attribute
(<code>[[clang::trivially_relocatable]]</code>), or a member typedef with a reserved name
(<code>using __is_triv_relocatable = void</code>), or simply a vendor-provided specialization
of <code>std::is_trivially_relocatable&lt;std::string></code>.

That is, we can solve this use-case with "magic" that is confined to the headers of the implementation itself.
The programmer doesn't have to learn anything new, so far.


## Important use case \#2: Program-defined types with defaulted special members ## {#use2}

In order to optimize the SBO <code>std::function</code> in any meaningful sense,
we must come up with a way to achieve
```c++
    #include &lt;string>
    auto lam2 = [x=std::string("hello")]{};
    static_assert(is_trivially_relocatable&lt; decltype(lam2) >::value);
```
Lambdas are not a special case in C++; they are simply class types with all their special members defaulted.
Therefore, presumably we should be able to use the same solution for lambdas as for
```c++
    #include &lt;string>
    struct A {
        std::string s;
    };
    static_assert(is_trivially_relocatable&lt; A >::value);
```
Here <code>struct A</code> follows the Rule of Zero: its move-constructor and destructor are both defaulted.
If they were also <i>trivial</i>, then we'd be done. In fact they are non-trivial; and yet, because the type
is composited from trivially relocatable types, the type as a whole <em>is</em> trivially relocatable.

This use-case asks specifically that we achieve the program above without breaking the "Rule of Zero."
We do not want to require the programmer to annotate <code>struct A</code> with a special attribute, or
a special member typedef, or anything like that. We want it to Just Work. Even for lambda types.
This is a much uglier problem than use-case #1. It requires core-language support.


## Lesser use case \#3: Program-defined types with non-defaulted special members ## {#use3}

In order to optimize <code>std::vector&lt;boost::shared_ptr&lt;T>>::resize</code>,
we must come up with a way to achieve
```c++
    struct B {
        B(B&amp;&amp;);  // non-trivial
        ~B();  // non-trivial
    };
    [SOME ADDITIONAL CODE HERE]
    static_assert(is_trivially_relocatable&lt; B >::value);
```
The <code>[SOME ADDITIONAL CODE HERE]</code> cannot possibly be "no code at all," because there exist
examples of types that look just like <code>B</code> and <em>are</em> trivially relocatable (for example,
<code>boost::unique_ptr&lt;int></code>) and there exist types that look just like <code>B</code> and are
<em>not</em> trivially relocatable (for example, <code>boost::interprocess::offset_ptr&lt;int></code>).
The compiler cannot "crack open" the definitions of <code>B(B&amp;&amp;)</code> and <code>~B()</code> to see if
they combine to form a trivial operation. For one thing, that's the Halting Problem; for another thing,
the definitions of <code>B(B&amp;&amp;)</code> and <code>~B()</code> might not be available in this translation
unit.

(For another thing, the definitions of <code>B(B&amp;&amp;)</code> and <code>~B()</code> might actually be
available and "crackable" in <em>this</em> translation unit, but unavailable in some other translation unit!
This would lead to ODR violations and generally really bad stuff. So we can't possibly achieve this
without <code>[SOME ADDITIONAL CODE HERE]</code>.)

I call this a "lesser" case because it is the only one that requires us to design the syntax of
<code>[SOME ADDITIONAL CODE HERE]</code>. In use-case #1, any special syntax is hidden inside the
implementation's own headers. In use-case #2, our design goal is to <em>avoid</em> special syntax.
In use-case #3, we must design syntax.

Therefore, I believe it would be acceptable to punt on use-case #3 and come back to it later.
We say, "Sure, that would be nice, but there's no syntax for it. Be glad that it works for
core-language and library types. Ask again in three years."  And as long as we leave the design
space open, I believe we wouldn't lose anything by delaying a solution to use-case #3.

This paper does propose a solution for use-case #3 — which in turn provides a
<em>simple and portable</em> solution to use-case #1 for library vendors. However, this
solution is detachable from the rest of this paper.


# Proposed language and library features # {#proposal}

This paper proposes five essentially orthogonal additions to C++. They combine to produce
a solution to each of the three use-cases above. However, it is okay to consider and accept
or reject each addition on its own merits.  For example, if the <code>[[trivially_relocatable]]</code>
attribute is adopted, library vendors will certainly use it in their implementations;
but if the attribute is rejected, library vendors could still achieve use-case #1
by adding partial specializations of <code>is_trivially_relocatable</code>.

- A new type trait, <code>is_trivially_relocatable&lt;T></code>, in the <code>&lt;type_traits></code>
  header. This is the <em>detection</em> mechanism.

- A new attribute, <code>[[trivially_relocatable]]</code>, in the core language.
  This is the <em>opt-in</em> mechanism for program-defined types.

- A new core-language rule by which the <code>[[trivially_relocatable]]</code> attribute
  is "inherited" according to the Rule of Zero.

- A new standard algorithm, <code>uninitialized_relocate(first, last, d_first)</code>,
  in the <code>&lt;memory></code> header.

- Additional type traits, <code>is_relocatable&lt;T></code> and <code>is_nothrow_relocatable&lt;T></code>,
  in the <code>&lt;type_traits></code> header.

The first and third bullets in that list motivate the second bullet. In order to achieve use-case #2,
we <em>must</em> define a core-language mechanism by which we can "inherit" trivial relocatability.
```c++
    template&lt;class T>
    struct D {
        T t;
    };

    // class C comes in from outside, already marked, via whatever mechanism
    constexpr bool c = is_trivially_relocatable&lt; C >::value;
    constexpr bool dc = is_trivially_relocatable&lt; D&lt;C> >::value;
    static_assert(dc == c);
```
I propose that <code>std::is_trivially_relocatable&lt;T></code> should be just a plain old
class template, exactly like <code>std::is_trivially_destructible&lt;T></code> and so on.
The core language <em>should not know or care</em><sup><a href="#fn_Contra">[Contra]</a></sup> that this class template exists.

I propose that the opt-in mechanism should be an attribute. The programmer will mark
<code>C</code> trivially relocatable like this:
```c++
    struct [[trivially_relocatable]] C {
        C(C&amp;&amp;);  // defined elsewhere
        ~C(); // defined elsewhere
    };
    static_assert(is_trivially_relocatable&lt; C >::value);
```
I expect that, just like <code>is_trivially_destructible</code>, the library vendor will
implement <code>std::is_trivially_relocatable</code> in terms of a non-standard compiler
builtin, whose natural spelling is <code>__is_trivially_relocatable(T)</code>. The compiler
computes the value of <code>__is_trivially_relocatable(T)</code> by inspecting the
definition of <code>T</code> (and the definitions of its base classes and members,
recursively, in the case that both of its special members are defaulted).

The fourth and fifth bullets are completely "unnecessary," but should be provided for symmetry with the
other uninitialized-memory algorithms in the <code>&lt;memory></code> header
(<code>uninitialized_copy</code>, <code>uninitialized_move</code>, and <code>destroy</code>)
and the other trios of type-traits in the <code>&lt;type_traits></code> header
(one such trio being <code>is_destructible</code>, <code>is_nothrow_destructible</code>,
<code>is_trivially_destructible</code>). I do not expect these templates to be generally useful,
but I believe they must be provided, so as not to unpleasantly surprise the programmer
by their absence.


# Proposed wording for C++20 # {#wording}

The wording in this section is relative to WG21 draft N4750,<sup><a href="#N4750">[N4750]</a></sup>
that is, the current draft of the C++17 standard.

**TODO FIXME BUG HACK**


# Further considerations and directions # {#further}

## Trivially swappable types ## {#trivially-swappable}

Mingxin Wang<sup><a href="#fn_Wang">[Wang]</a></sup> has proposed that "swap"
could be expressed in terms of "relocate". <code>std::swap</code> today is
typically implemented in terms of one move-construction, two move-assignments,
and one destruction; but there is nothing in the Standard that prevents a library
vendor from implementing it as three relocations, which in the trivially-relocatable
case (the usual case for most types) could be optimized into three calls to
<code>memcpy</code>.

For reasons described elsewhere,<sup>TODO FIXME BUG HACK</sup> it seems reasonable
to claim that move-assignment must always "do the sane thing," and therefore we
might propose to define
```c++
    template&lt;class T>
    struct is_trivially_swappable : bool_constant&lt;
        is_trivially_relocatable_v&lt;T> and
        is_move_assignable_v&lt;T>
    > {};
```
thus completing the currently-incomplete trio with
<code>is_swappable</code> and <code>is_nothrow_swappable</code>.

However, we do not propose "trivially swappable" at the present time.
It can easily be added in a later paper.


## Heterogeneous relocation ## {#hetero}

Consider that <code>is_relocatable_v&lt;T></code> means
<code>is_constructible_v&lt;T,T&amp;&amp;> and is_destructible_v&lt;T></code>.
We have access to a heterogeneous <code>is_constructible&lt;T,Us...></code>,
and we have the precedent of a heterogeneous <code>is_swappable_with&lt;T,U></code>.
So, should we add a heterogeneous <code>is_relocatable_from</code>?

Notice that <code>uninitialized_copy</code> and <code>uninitialized_move</code>
are already heterogeneous.
Here is what a heterogeneous <code>uninitialized_relocate</code> would look like.
```c++
template&lt;class FwdIt, class OutIt>
void uninitialized_relocate(FwdIt first, FwdIt last, OutIt d_first) {
    using SrcT = remove_cvref_t&lt;decltype(*first)>;
    using DstT = remove_cvref_t&lt;decltype(*d_first)>;
    static_assert(is_relocatable_from_v&lt;DstT, SrcT>);
    if constexpr (is_trivially_relocatable_from_v&lt;DstT, SrcT>) {
        static_assert(sizeof (SrcT) == sizeof(DstT));
        if constexpr (is_pointer_v&lt;FwdIt> &amp;&amp; is_pointer_v&lt;OutIt>) {
            // Trivial relocation + contiguous iterators = memcpy
            size_t n = last - first;
            if (n) memcpy(d_first, first, n * sizeof (SrcT));
            d_first += n;
        } else {
            while (first != last) {
                memcpy(addressof(*d_first), addressof(*first), sizeof (SrcT));
                ++d_first; ++first;
            }
        }
    } else {
        while (first != last) {
            ::new ((void*)addressof(*d_first)) DstT(move(*first));
            (*first).~SrcT();
            ++d_first; ++first;
        }
    }
    return d_first;
}
```
This implementation could be used to quickly relocate an array of
<code>int*</code> into an array of <code>unique_ptr&lt;int></code>
(but not vice versa). It could also be used to quickly relocate an array of
<code>T</code> into an array of <code>tombstone::optional&lt;T></code>.<sup><a href="#fn_Best">[Best]</a></sup>
All we'd need is for somebody to set the value of <code>is_trivially_relocatable_from</code>
appropriately for each pair of types in the program.

I think this is a very intriguing idea. The detection syntax is fairly obvious:
<code>is_trivially_relocatable_from</code>. But I don't see what the opt-in syntax
would look like on a program-defined class such as <code>tombstone::optional</code>.
Let's leave that problem alone for a few years and see what develops.

We could provide the detection trait <code>is_trivially_relocatable_from</code> today,
with deliberately curtailed semantics, e.g.:
```c++
    template&lt;class T, class U>
    struct is_trivially_relocatable_from : bool_constant&lt;
        is_trivially_relocatable_v&lt;T> and
        is_same_v&lt;U, remove_cvref_t&lt;T>>
    > {};
    template&lt;class T, class U>
    struct is_trivially_relocatable_from&lt;T, U&amp;> : is_trivially_relocatable_from&lt;T, U> {};
    template&lt;class T, class U>
    struct is_trivially_relocatable_from&lt;T, U&amp;&amp;> : is_trivially_relocatable_from&lt;T, U> {};
```
plus permission for vendors to extend the trait via partial specializations on
a QoI basis:
```c++
    template&lt;class T>
    struct is_trivially_relocatable_from&lt;unique_ptr&lt;T>, T*> : true_type {};
    template&lt;class T>
    struct is_trivially_relocatable_from&lt;const T*, T*> : true_type {};
    struct is_trivially_relocatable_from&lt;int, unsigned> : true_type {};
    // and so on
```
However, if we do this, we may soon find that programmers are adding specializations
of <code>is_trivially_relocatable_from</code> to their own programs, because they find it
makes their code run faster. It will become a de-facto customization point, and we will
never be able to "fix it right" for fear of breaking programmers' existing code.

Therefore, I believe that we should <em>not</em> pursue "heterogeneous" relocation
operations at the present time.

Note that vendors are already free to optimize heterogeneous operations inside
library algorithms, under the as-if rule. We lack a portable and generic detection
trait, but vendors are presumably well aware of specific special cases that they
<em>could</em> detect and optimize today —
for example, a <code>std::copy</code> from an array of <code>int*</code> into
an array of <code>const int*</code>, or from an array of 64-bit <code>long</code> into
an array of 64-bit <code>long long</code>.<sup><a href="#fn_TCF">[TCF]</a></sup>
Today vendors choose not to perform these optimizations.


# Acknowledgements # {#acknowledgements}

Thanks to Elias Kosunen and Niall Douglas for their feedback on drafts of this paper.

<pre class=biblio>
{
	"SV": {
		"authors": [
			"Microsoft"
		],
		"title": "CComPtr::operator& Operator",
		"href": "https://msdn.microsoft.com/en-us/library/31k6d0k7.aspx",
		"date": "2015"
	},
	"Best": {
		"authors": [
			"Arthur O'Dwyer"
		],
		"title": "The Best Type Traits C++ Doesn't Have (video)",
		"href": "https://www.youtube.com/watch?v=MWBfmmg8-Yo",
                "date": "April 2018"
	},
	"Bench": {
		"authors": [
			"Arthur O'Dwyer"
		],
		"title": "Benchmark code from \"The Best Type Traits C++ Doesn't Have\"",
		"href": "https://github.com/Quuxplusone/from-scratch/blob/095b246d4dc9b88fbdbb6c38771866c0a25289db/cppnow2018/benchmark-relocatable.cc",
                "date": "April 2018"
	},
	"Contra": {
		"authors": [
			"Arthur O'Dwyer"
		],
		"title": "_Contra_ built-in library types",
		"href": "https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/",
                "date": "April 2018"
	},
	"LWG2139": {
		"authors": [
			"Loïc Joly"
		],
		"title": "LWG 2139: What is a user-defined type?",
		"href": "https://cplusplus.github.io/LWG/issue2139",
                "date": "March 2012–June 2018"
	},
	"LWG3119": {
		"authors": [
			"Hubert Tong"
		],
		"title": "LWG 3119: Program-definedness of closure types",
		"href": "https://cplusplus.github.io/LWG/issue3119",
                "date": "June 2018—"
	},
	"N4750": {
		"authors": [
			"ISO/IEC JTC1/SC22/WG21 - The C++ Standards Committee",
			"Richard Smith"
		],
		"title": "N4750: Working Draft, Standard for Programming Language C++",
		"href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf",
		"date": "May 2018"
	},
	"P1029R0": {
		"authors": [
			"Niall Douglas"
		],
		"title": "P1029R0: SG14 `[[move_relocates]]`",
		"href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1029r0.pdf",
		"date": "May 2018"
	},
	"TCF": {
		"authors": [
			"Arthur O'Dwyer"
		],
		"title": "Trivially-constructible-from",
		"href": "https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/",
		"date": "July 2018"
	},
	"Wang": {
		"authors": [
			"Mingxin Wang"
		],
		"title": "Better Performance in Polymorphic Programming: Trivially Swappable",
		"href": "https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ",
		"date": "June 2018"
	},
}
</pre>
