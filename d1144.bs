<pre class='metadata'>
Title: Object relocation in terms of move plus destroy
Shortname: D1144
Revision: 0
!Draft Revision: 4
Audience: LEWG, EWG
Status: D
Group: WG21
URL:
!Current Source: <a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d1144.bs">github.com/Quuxplusone/draft/blob/gh-pages/d1144.bs</a>
!Current: <a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d1144.html">rawgit.com/Quuxplusone/draft/gh-pages/d1144.html</a>
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Editor: Mingxin Wang, wmx16835vv@163.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  We define a new algorithm "relocate" which is tantamount to a move and a destroy,
  analogous to the existing algorithm "swap" which is tantamount to a move, two move-assignments, and a destroy.
  For most (but not all) C++ types, the "relocate" operation is equivalent to a single <code>memcpy</code>.
  For the benefit of library writers, we provide a standard type trait to detect types whose "relocate" is known to be equivalent to <code>memcpy</code>.
  Finally, we provide a portable way for any user-defined type (such as <code>boost::shared_ptr</code>) to warrant to the implementation that its "relocate" is equivalent to <code>memcpy</code>, thus gaining the same performance benefits as the standard library types.
Date: 2018-07-06
</pre>

<style>
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>


# Introduction and motivation # {#intro}

If you are reading this paper, and you have not yet watched Arthur's session from C++Now 2018
on [[Best|"The Best Type Traits C++ Doesn't Have,"]] it will help if you immediately stop reading and
<a href="https://www.youtube.com/watch?v=MWBfmmg8-Yo">go watch</a>
the first 30 minutes of that video at 2x speed with the captions turned on.
It's going to be worth your 15 minutes. I'll wait.

In the video, besides showing implementation techniques and benchmark results, we defined our
terms. These terms are summarized briefly below.

C++17 knows the verbs "move," "copy," "destroy," and "swap," where "swap" is a higher-level operation
composed of several lower-level operations. To this list we propose to add the verb "relocate,"
which is a higher-level operation composed of exactly two lower-level operations.
Given an object type `T` and memory addresses `src` and `dst`,
the phrase "<b><i>relocate</i></b> a `T` from `src` to `dst`" means no more and no
less than "*move-construct* `dst` from `src`, and then immediately
*destroy* the object at `src`."

Just as the verb "swap" produces the adjective "swappable," the verb "relocate" produces the adjective
"relocatable." Any type which is both move-constructible and
destructible is <b><i>relocatable</i></b>. The notion can be modified by adverbs: we say that a type
is <b><i>nothrow relocatable</i></b> if its relocation operation is noexcept, and we say that a type
is <b><i>[$trivially relocatable$]</i></b> if its relocation operation is trivial (which, just like trivial move-construction
and trivial copy-construction, means "the operation is tantamount to a `memcpy`").

Almost all relocatable types are trivially relocatable: `std::unique_ptr<int>`,
`std::vector<int>`, `std::string`, `std::any`. Non-trivially relocatable
types exist but are rare: `boost::interprocess::offset_ptr<int>`, for example.
See [[#non-trivial-samples]].

Arthur has established (see [[Bench]])
that if standard library code had a reliable way of detecting "trivial relocatability," we could optimize
that case and get a speed boost of up to 3x on routines that perform reallocation, such as

```
    std::vector<R>::resize
    std::vector<R>::reserve
    std::vector<R>::emplace_back
    std::vector<R>::push_back
```

Furthermore, Mingxin Wang points out that we can use the same "trivial relocatability" property to shrink the code
generated by small-buffer-optimized (SBO) type-erasing wrappers such as `std::function` and `std::any`.
For these types, a *move* of the wrapper object is implemented in terms of a
*relocation* of the contained object. (See for example [[Any|libc++'s std::any]],
where the function that performs the relocation operation is confusingly named `__move`.)
In general, the *relocate* operation for a contained type `C` involves calls to `C`'s
move constructor and destructor, which must be uniquely codegenned for each different `C`; the
number of instantiations of *relocate* scales linearly with the count of distinct types `C`
in the program.
But for any trivially relocatable `C`, its *relocate* operation depends only on the number of
bytes being `memcpy`ed, and so the number of instantiations of *relocate* scales linearly with the count
of distinct *sizes* of `C` being used in the program; or indeed, linearly with the count
of distinct *sizes of SBO buffer* being used in the program.

A smaller number of instantiations means faster compile times, a smaller text section, and perhaps
"hotter" code (because a relatively higher proportion of your code now fits in icache).

In between these two scenarios, we also find the move-constructor of `fixed_capacity_vector<R,N>`,
which can be implemented as an element-by-element *move* (leaving the source vector's elements in their
moved-from state), or can be implemented more efficiently as an element-by-element *relocate* (leaving
the source vector empty).

Note:
The name `fixed_capacity_vector` is my preferred name for the type
that Boost.Container calls `static_vector`.
`boost::container::static_vector<R,N>` implements the
less efficient element-by-element-move strategy. Moving-out-of a
`boost::container::static_vector` will not make the source vector
`empty()`.


# Design goals # {#design-goals}

Every C++ type already *is* or *is not* trivially relocatable. This proposal is not about
"making more types trivially relocatable."

The optimizations discussed above are purely in the domain of library vendors. If you're writing
a vector, and you detect that your element type `T` is trivially relocatable, then
whether you do any special optimization in that case is merely a Quality of Implementation (QoI) issue.
This proposal is not about "standardizing certain library optimizations."

What C++ lacks is a standard way for library vendors to *detect* the (existing) trivial relocatability
of a type `T`, so that they can reliably apply their (existing) optimizations.
All we really need is to add *detection*, and then all the optimizations described above will naturally
emerge without any further special effort by WG21.

Library vendors today often (correctly) infer that any *trivially copyable* type is trivially relocatable.
However, we would like to do even better. The following three use-cases are important for improving the
performance of real programs:


## Standard library types such as `std::string` ## {#use1}

In order to optimize `std::vector<std::string>::resize`, we must come up with a way to achieve
```c++
    #include <string>
    static_assert(is_trivially_relocatable< std::string >::value);
```
This could be done unilaterally by the library vendor, via a non-standard attribute
(`[[clang::trivially_relocatable]]`), or a member typedef with a reserved name
(`using __is_triv_relocatable = void`), or simply a vendor-provided specialization
of `std::is_trivially_relocatable<std::string>`.

That is, we can solve this use-case with "magic" that is confined to the headers of the implementation itself.
The programmer doesn't have to learn anything new, so far.


## Program-defined types with defaulted special members ## {#use2}

Note: The term "program-defined types" is defined in [[LWG2139]] and [[LWG3119]].

In order to optimize the SBO `std::function` in any meaningful sense,
we must come up with a way to achieve
```c++
    #include <string>
    auto lam2 = [x=std::string("hello")]{};
    static_assert(is_trivially_relocatable< decltype(lam2) >::value);
```
Lambdas are not a special case in C++; they are simply class types with all their special members defaulted.
Therefore, presumably we should be able to use the same solution for lambdas as for
```c++
    #include <string>
    struct A {
        std::string s;
    };
    static_assert(is_trivially_relocatable< A >::value);
```
Here `struct A` follows the Rule of Zero: its move-constructor and destructor are both defaulted.
If they were also *trivial*, then we'd be done. In fact they are non-trivial; and yet, because the type's
bases and members are all of trivially relocatable types, the type as a whole *is* trivially relocatable.

This use-case asks specifically that we achieve the program above without breaking the "Rule of Zero."
We do not want to require the programmer to annotate `struct A` with a special attribute, or
a special member typedef, or anything like that. We want it to Just Work. Even for lambda types.
This is a much uglier problem than use-case #1. It requires core-language support.


## Program-defined types with non-defaulted special members ## {#use3}

In order to optimize `std::vector<boost::shared_ptr<T>>::resize`,
we must come up with a way to achieve
```c++
    struct B {
        B(B&&);  // non-trivial
        ~B();  // non-trivial
    };
    static_assert(is_trivially_relocatable< B >::value);
```
via some kind of programmer-provided annotation.

Note:
We cannot possibly do it without annotation, because there exist
examples of types that look just like `B` and *are* trivially relocatable (for example,
`boost::unique_ptr<int>`) and there exist types that look just like `B` and are
*not* trivially relocatable (for example, `boost::interprocess::offset_ptr<int>`).
The compiler cannot "crack open" the definitions of `B(B&&)` and `~B()` to see if
they combine to form a trivial operation. One, that's the Halting Problem. Two,
the definitions of `B(B&&)` and `~B()` might not be available in this translation
unit. Three, the definitions might actually be
available and "crackable" in *this* translation unit, but unavailable in some other translation unit!
This would lead to ODR violations and generally really bad stuff. So we cannot achieve
our goal by avoiding annotation.

This use-case is the only one that requires us to design the "opt-in" syntax.
In [[#use1]], any special syntax is hidden inside the
implementation's own headers. In [[#use2]], our design goal is to *avoid* special syntax.
In [[#use3]], WG21 must actually design user-facing syntax.

Therefore, I believe it would be acceptable to punt on use-case #3 and come back to it later.
We say, "Sure, that would be nice, but there's no syntax for it. Be glad that it works for
core-language and library types. Ask again in three years."  And as long as we leave the design
space open, I believe we wouldn't lose anything by delaying a solution to use-case #3.

This paper does propose a standard syntax for use-case #3 — which in turn provides a
*simple and portable* solution to use-case #1 for library vendors. However, this
solution is severable from the rest of this paper.


# Proposed language and library features # {#proposal}

This paper proposes five separate additions to the C++ Standard. These additions introduce
"relocate" as a well-supported C++ notion on par with "swap," and furthermore, successfully
communicate trivial relocatability in each of the three use-cases above.

  - A new standard algorithm, `uninitialized_relocate(first, last, d_first)`,
    in the `<memory>` header.

  - Additional type traits, `is_relocatable<T>` and `is_nothrow_relocatable<T>`,
    in the `<type_traits>` header.

  - A new type trait, `is_trivially_relocatable<T>`, in the `<type_traits>`
    header. This is the *detection* mechanism.

  - A new core-language rule by which a class type's "trivial relocatability"
    is inherited according to the Rule of Zero.

  - A new attribute, `[[trivially_relocatable]]`, in the core language.
    This is the *opt-in* mechanism for program-defined types.

These five bullet points are severable to a certain degree. For example, if the `[[trivially_relocatable]]`
attribute (points 4 and 5) is adopted, library vendors will certainly use it in their implementations;
but if the attribute is rejected, library vendors could still indicate the trivial relocatability
for certain standard library types by providing library specializations of `is_trivially_relocatable`
(point 3).

Points 1 and 2 are completely severable from points 3, 4, and 5;
but we believe these algorithms should be provided for symmetry with the
other uninitialized-memory algorithms in the `<memory>` header
(`uninitialized_copy`, `uninitialized_move`, and `destroy`)
and the other trios of type-traits in the `<type_traits>` header
(one such trio being `is_destructible`, `is_nothrow_destructible`,
`is_trivially_destructible`). I do not expect these templates to be frequently useful,
but I believe they must be provided, so as not to unpleasantly surprise the programmer
by their absence.

Points 3 and 4 together motivate point 5. In order to achieve the goal of [[#use2]],
we *must* define a core-language mechanism by which we can "inherit" trivial relocatability.
This is especially important for the template case.
```c++
    template<class T>
    struct D {
        T t;
    };

    // class C comes in from outside, already marked, via whatever mechanism
    constexpr bool c = is_trivially_relocatable< C >::value;
    constexpr bool dc = is_trivially_relocatable< D<C> >::value;
    static_assert(dc == c);
```
We propose that `std::is_trivially_relocatable<T>` should be just a plain old
class template, exactly like `std::is_trivially_destructible<T>` and so on.
The core language *[[Contra|should not know or care]]* that the class template
`is_trivially_relocatable` exists, any more than it knows that the class template
`is_trivially_destructible` exists.

We expect that the library vendor will implement `std::is_trivially_relocatable`,
just like `std::is_trivially_destructible`, in terms of a non-standard compiler
builtin whose natural spelling is `__is_trivially_relocatable(T)`. The compiler
computes the value of `__is_trivially_relocatable(T)` by inspecting the
definition of `T` (and the definitions of its base classes and members,
recursively, in the case that both of its special members are defaulted). This
recursive process "bottoms out" at primitive types, or at any type with a user-provided
move or destroy operation. Classes with user-provided move or destroy operations must
conservatively be assumed *not* to be trivially relocatable. To achieve the goal
of [[#use3]], we must provide a way for such a class to "opt in" and warrant to the
implementation that it is in fact trivially relocatable (despite being non-trivially
move-constructible and/or non-trivially destructible).

In point 5 we propose that the opt-in mechanism should be an attribute. The programmer
of a trivially relocatable but non-trivially destructible class `C` will mark it for
the compiler using the attribute:
```c++
    struct [[trivially_relocatable]] C {
        C(C&&);  // defined elsewhere
        ~C(); // defined elsewhere
    };
    static_assert(is_trivially_relocatable< C >::value);
```
The attribute overrides the compiler's usual computation. An example of a "conditionally"
trivially relocatable class is shown in [[#sample-conditional]].


# Proposed wording for C++20 # {#wording}

The wording in this section is relative to [[N4750|WG21 draft N4750]],
that is, the current draft of the C++17 standard.


## Relocation operation ## {#wording-operation}

Add a new section in <a href="http://eel.is/c++draft/definitions">[definitions]</a>:

Issue: [definitions] is probably the wrong place for the core-language definition of "relocation operation"

<small><blockquote>

: <dfn dfn-type="abstract-op">relocation operation</dfn>

:: the homogeneous binary operation performed on a range by `std::uninitialized_relocate`, consisting of a move-construction immediately followed by a destruction of the source object

</blockquote></small>

Issue: this definition of "relocation operation" is not good

## Algorithm `uninitialized_relocate` ## {#wording-uninit-relocate}

Add a new section after <a href="http://eel.is/c++draft/uninitialized.move">[uninitialized.move]</a>:

<small><blockquote>
<xmp>
  template<class InputIterator, class ForwardIterator>
  ForwardIterator uninitialized_relocate(InputIterator first, InputIterator last,
                                         ForwardIterator result);
</xmp>

*Effects:* Equivalent to:
<xmp>
  for (; first != last; (void)++result, ++first) {
    ::new (static_cast<void*>(addressof(*result)))
      typename iterator_traits<ForwardIterator>::value_type(std::move(*first));
    destroy_at(addressof(*first));
  }
  return result;
</xmp>
</blockquote></small>


## Algorithm `uninitialized_relocate_n` ## {#wording-uninit-relocate-n}

<small><blockquote>
<xmp>
  template<class InputIterator, class Size, class ForwardIterator>
    pair<InputIterator, ForwardIterator>
      uninitialized_relocate_n(InputIterator first, Size n, ForwardIterator result);
</xmp>

*Effects:* Equivalent to:
<xmp>
  for (; n > 0; ++result, (void) ++first, --n) {
    ::new (static_cast<void*>(addressof(*result)))
      typename iterator_traits<ForwardIterator>::value_type(std::move(*first));
    destroy_at(addressof(*first));
  }
  return {first,result};
</xmp>
</blockquote></small>


## Trivially relocatable type ## {#wording-inheritance}

Issue: Where in the Standard should we place the definition of "trivially relocatable"?

Add a new section somewhere:

<small><blockquote>
An object type `T` is a <dfn dfn-type="abstract-op">trivially relocatable</dfn> type if it is:

  - a type which is move-constructible, trivially move-constructible, and trivially destructible, or

  - a class type marked with the `[[trivially_relocatable]]` attribute, or

  - a class type which:

    - has either a defaulted, non-deleted move constructor or no move constructor and a defaulted, non-deleted copy constructor,

    - has a defaulted, non-deleted destructor,

    - either is final, or has a final destructor, or has a non-virtual destructor,

    - has no virtual base classes,

    - has no members which are not trivially relocatable, and

    - has no base classes which are not trivially relocatable.

[*Note:* For a trivially relocatable type, its [$relocation operation$] (such as the relocation operations
performed by the library functions `std::swap` and `std::vector::resize`) is tantamount
to a simple copy of the underlying bytes. *—end note*]

[*Note:* It is intended that most standard library types be trivially relocatable types. *—end note*]

</blockquote></small>

Note: We could simplify the wording by removing the special case that treats a non-overrideable
virtual destructor the same way as a non-virtual destructor. However, this would lead to the compiler's failing
to identify certain (unrealistic) class types as trivially relocatable, when in fact it has enough
information to infer that they *are* trivially relocatable in practice. This would leave room for a
"better" implementation. I tentatively prefer to make the core concept as strong as possible, optimizing
for maximum performance rather than simplicity of specification.


## `[[trivially_relocatable]]` attribute ## {#wording-attribute}

Add a new section after <a href="http://eel.is/c++draft/dcl.attr.nouniqueaddr">[dcl.attr.nouniqueattr]</a>:

<small><blockquote>
The *attribute-token* `trivially_relocatable` specifies that a class type's relocation operation has no
visible side-effects other than a copy of the underlying bytes, as if by the library function `std::memcpy`.
It shall appear at most once in each *attribute-list* and no *attribute-argument-clause* shall be present.
It may be applied to the declaration of a class.
The first declaration of a type shall specify the `trivially_relocatable` attribute if any declaration of that type
specifies the `trivially_relocatable` attribute.
If a type is declared with the `trivially_relocatable` attribute in one translation unit and the
same type is declared without the `trivially_relocatable` attribute in another translation unit,
the program is ill-formed, no diagnostic required.

If a class type is declared with the `trivially_relocatable` attribute, the implementation may replace
relocation operations involving that type (such as those performed by the library functions
`std::swap` and `std::vector::resize`) with simple copies of the underlying bytes.

If a class type is declared with the `trivially_relocatable` attribute, and the program relies on
observable side-effects of relocation other than a copy of the underlying bytes, the behavior is undefined.
</blockquote></small>


## Type traits `is_relocatable` etc. ## {#wording-traits}

Add new entries to Table 46 in <a href="http://eel.is/c++draft/meta.unary.prop">[meta.unary.prop]</a>:

<small><blockquote>
<table>
<tr><th>Template</th><th>Condition</th><th>Preconditions</th></tr>
<tr>
<td>`template<class T> struct is_relocatable;`</td>
<td>`is_move_constructible_v<T>` is `true` and `is_destructible_v<T>` is `true`</td>
<td>T shall be a complete type, <i>cv</i> `void`, or an array of unknown bound.</td>
</tr>
<tr>
<td>`template<class T> struct is_nothrow_relocatable;`</td>
<td>`is_relocatable_v<T>` is `true` and both the indicated move-constructor and the destructor are known not to throw any exceptions.</td>
<td>T shall be a complete type, <i>cv</i> `void`, or an array of unknown bound.</td>
</tr>
<tr>
<td>`template<class T> struct is_trivially_relocatable;`</td>
<td>`T` is a trivially relocatable type.</td>
<td>T shall be a complete type, <i>cv</i> `void`, or an array of unknown bound.</td>
</tr>
</table>
</blockquote></small>


## `Relocatable` concept ## {#wording-concept}

Add a new section after <a href="http://eel.is/c++draft/concept.moveconstructible">[concept.moveconstructible]</a>:

<small><blockquote>
<xmp>
  template<class T>
    concept Relocatable = MoveConstructible<T> && Destructible<T>;
</xmp>

*Note:* This concept is exactly equivalent to `MoveConstructible<T>`.
</blockquote></small>


# Further considerations and directions # {#further}

## Trivially swappable types ## {#trivially-swappable}

[[Wang|Mingxin Wang has proposed]] that "swap"
could be expressed in terms of "relocate". `std::swap` today is
typically implemented in terms of one move-construction, two move-assignments,
and one destruction; but there is nothing in the Standard that prevents a library
vendor from implementing it as three relocations, which in the trivially-relocatable
case (the usual case for most types) could be optimized into three calls to
`memcpy`.

For reasons [[Sane|described elsewhere]], it seems reasonable
to claim that move-assignment must always "do the sane thing," and therefore we
might propose to define
```c++
    template<class T>
    struct is_trivially_swappable : bool_constant<
        is_trivially_relocatable_v<T> and
        is_move_assignable_v<T>
    > {};
```
thus completing the currently-incomplete trio with
`is_swappable` and `is_nothrow_swappable`.

However, we do not propose "trivially swappable" at the present time.
It can easily be added in a later paper.


## Heterogeneous relocation ## {#hetero}

Consider that `is_relocatable_v<T>` means
`is_constructible_v<T,T&&> and is_destructible_v<T>`.
We have access to a heterogeneous `is_constructible<T,Us...>`,
and we have the precedent of a heterogeneous `is_swappable_with<T,U>`.
So, should we add a heterogeneous `is_relocatable_from`?

Notice that `uninitialized_copy` and `uninitialized_move`
are already heterogeneous.
Here is what a heterogeneous `uninitialized_relocate` would look like.
```c++
template<class FwdIt, class OutIt>
void uninitialized_relocate(FwdIt first, FwdIt last, OutIt d_first) {
    using SrcT = remove_cvref_t<decltype(*first)>;
    using DstT = remove_cvref_t<decltype(*d_first)>;
    static_assert(is_relocatable_from_v<DstT, SrcT>);
    if constexpr (is_trivially_relocatable_from_v<DstT, SrcT>) {
        static_assert(sizeof (SrcT) == sizeof(DstT));
        if constexpr (is_pointer_v<FwdIt> && is_pointer_v<OutIt>) {
            // Trivial relocation + contiguous iterators = memcpy
            size_t n = last - first;
            if (n) memcpy(d_first, first, n * sizeof (SrcT));
            d_first += n;
        } else {
            while (first != last) {
                memcpy(addressof(*d_first), addressof(*first), sizeof (SrcT));
                ++d_first; ++first;
            }
        }
    } else {
        while (first != last) {
            ::new ((void*)addressof(*d_first)) DstT(move(*first));
            (*first).~SrcT();
            ++d_first; ++first;
        }
    }
    return d_first;
}
```
This implementation could be used to quickly relocate an array of
`int*` into an array of `unique_ptr<int>`
(but not vice versa). It could also be used to quickly relocate an array of
`T` into an array of `tombstone::optional<T>`. (The concept of "tombstone optional"
is described in [[Best]].)
All we'd need is for somebody to set the value of `is_trivially_relocatable_from`
appropriately for each pair of types in the program.

I think this is a very intriguing idea. The detection syntax (`is_trivially_relocatable_from`)
is fairly obvious. But I don't see what the opt-in syntax
would look like on a program-defined class such as `tombstone::optional`.
Let's leave that problem alone for a few years and see what develops.

We could conceivably provide the detection trait `is_trivially_relocatable_from` today,
with deliberately curtailed semantics, e.g.:
```c++
    template<class T, class U>
    struct is_trivially_relocatable_from : bool_constant<
        is_trivially_relocatable_v<T> and
        is_same_v<U, remove_cvref_t<T>>
    > {};
    template<class T, class U>
    struct is_trivially_relocatable_from<T, U&> : is_trivially_relocatable_from<T, U> {};
    template<class T, class U>
    struct is_trivially_relocatable_from<T, U&&> : is_trivially_relocatable_from<T, U> {};
```
plus permission for vendors to extend the trait via partial specializations on
a QoI basis:
```c++
    template<class T>
    struct is_trivially_relocatable_from<unique_ptr<T>, T*> : true_type {};
    template<class T>
    struct is_trivially_relocatable_from<const T*, T*> : true_type {};
    struct is_trivially_relocatable_from<int, unsigned> : true_type {};
    // and so on
```
However, if we do this, we may soon find that programmers are adding specializations
of `is_trivially_relocatable_from` to their own programs, because they find it
makes their code run faster. It will become a de-facto customization point, and we will
never be able to "fix it right" for fear of breaking programmers' existing code.

Therefore, I believe that we should *not* pursue "heterogeneous" relocation
operations at the present time.

Note that vendors are already free to optimize heterogeneous operations inside
library algorithms, under the as-if rule. We lack a portable and generic detection
trait, but vendors are presumably well aware of specific special cases that they
*could* detect and optimize today —
for example, a `std::copy` from an array of `int*` into
an array of `const int*`, or from an array of 64-bit `long` into
an array of 64-bit `long long` (see [[TCF]]).
Today vendors generally choose not to perform these optimizations.


# Acknowledgements # {#acknowledgements}

Thanks to Elias Kosunen and Niall Douglas for their feedback on early drafts of this paper.

Thanks to Pablo Halpern for [[N4158]], to which this paper bears a striking and coincidental resemblance —
including the meaning assigned to the word "trivial," and the library-algorithm approach to avoiding the
problems with "lame duck objects" discussed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm#Alternative%20move%20designs">the final section</a>
of [[N1377]].


Appendix A: Straw polls requested {#polls}
==========

## Polls for LEWG ## {#lewg-polls}

<table class="def">
<tr><th style="width: 70%;"></th><th>**SF**</th><th>**F**</th><th>**N**</th><th>**A**</th><th>**SA**</th></tr>

<tr><th><small>The algorithm `uninitialized_relocate(first, last, d_first)` should be added to the `<memory>` header,
as proposed in this paper.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>The type trait `is_relocatable<T>` (and its `_v` version) should be added to the `<type_traits>` header, as proposed in this paper.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>If `is_relocatable<T>` *is* added, then we should also add `is_nothrow_relocatable<T>` (and its `_v` version), as proposed in this paper.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>The type trait `is_trivially_relocatable<T>` (and its `_v` version) should be added to the `<type_traits>` header, under that exact name, as proposed in this paper.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>We approve of a trait with the semantics of `is_trivially_relocatable<T>`, but not necessarily under that exact name. (For example, `is_bitwise_relocatable`.)</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>If `is_trivially_relocatable<T>` *is* added, under that exact name, then the type trait `is_trivially_swappable<T>` (and its `_v` version) should also be added to the `<type_traits>` header.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>
</table>


## Polls for EWG ## {#ewg-polls}

<table class="def">
<tr><th style="width: 70%;"></th><th>**SF**</th><th>**F**</th><th>**N**</th><th>**A**</th><th>**SA**</th></tr>

<tr><th><small>We approve of the general idea that user-defined classes should be able to warrant their own trivial relocatability.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>We approve of the general idea that user-defined classes which follow the Rule of Zero should inherit the trivial relocatability of their bases and members.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>Nobody should be able to warrant the trivial relocatability of `class C` except for `class C` itself (i.e., we do not want to see a customization point analogous to `std::hash`).</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>If a trait with the semantics of `is_trivially_relocatable<T>` is added to the `<type_traits>` header, the programmer should be permitted to specialize it for program-defined types (i.e., we want to see that trait itself become a customization point analogous to `std::hash`).</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>A class should be able to warrant its own trivial relocatability via the attribute `[[trivially_relocatable]]`, as proposed in this paper.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>A class should be able to warrant its own trivial relocatability via some attribute, but not necessarily under that exact name.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>A class should be able to warrant its own trivial relocatability as proposed in this paper, but via a contextual keyword rather than an attribute.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>To simplify [[#sample-conditional]], if an attribute with the semantics of `[[trivially_relocatable]]` is added, it should take a boolean argument.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>
</table>


Appendix B: Sample code {#samples}
======================

## Defining a trivially relocatable function object ## {#sample-deducing}

The following sample illustrates [[#use2]]. Here `A` is a program-defined type
following the Rule of Zero. Because all of its bases and members are warranted as
trivially relocatable, and its move-constructor and destructor are both defaulted,
the compiler concludes that `A` itself is trivially relocatable.
```
    #include <string>
    #include <type_traits>

    // Assume that the library vendor has taken care of this part.
    static_assert(std::is_trivially_relocatable_v< std::string >);

    struct A {
        std::string s;
        std::string operator()(std::string t) const { return s + t; }
    };

    static_assert(std::is_trivially_relocatable_v< A >);
```

The following sample, involving an implementation-defined closure type,
also illustrates [[#use2]].
```
    #include <string>
    #include <type_traits>

    // Assume that the library vendor has taken care of this part.
    static_assert(std::is_trivially_relocatable_v< std::string >);

    auto a = [s = std::string("hello")](std::string t) {
        return s + t;
    };

    static_assert(std::is_trivially_relocatable_v< decltype(a) >);
```

## Warranting that a user-defined relocation operation is equivalent to `memcpy` ## {#sample-opting-in}

The following sample illustrates [[#use3]]. The rules proposed in this paper ensure
that any type with non-trivial user-defined move and destructor operations will be
considered non-trivially relocatable by default.
```
    #include <type_traits>

    struct C {
        const char *s = nullptr;
        C(const char *s) : s(s) {}
        C(C&& rhs) : s(rhs.s) { rhs.s = nullptr; }
        ~C() { delete s; }
    };

    static_assert(not std::is_trivially_relocatable_v< C >);

    struct D : C {};

    static_assert(not std::is_trivially_relocatable_v< D >);
```

The programmer may apply the `[[trivially_relocatable]]` attribute to override the compiler's default
behavior and warrant (under penalty of undefined behavior) that this type is in fact trivially relocatable.
```
    #include <type_traits>

    struct [[trivially_relocatable]] E {
        const char *s = nullptr;
        E(const char *s) : s(s) {}
        E(C&& rhs) : s(rhs.s) { rhs.s = nullptr; }
        ~E() { delete s; }
    };

    static_assert(std::is_trivially_relocatable_v< E >);

    struct F : E {};

    static_assert(std::is_trivially_relocatable_v< F >);
```


## Reference implementation of `std::uninitialized_relocate` ## {#sample-uninit-relocate}

<small>
```
template<class InputIterator, class ForwardIterator>
ForwardIterator uninitialized_relocate(InputIterator first, InputIterator last,
                                       ForwardIterator result)
{
    using T = typename iterator_traits<ForwardIterator>::value_type;
    using U = std::remove_ref_t<decltype(std::move(*first))>;
    constexpr bool memcpyable = (std::is_same_v<T, U> && std::is_trivially_relocatable_v<T>);
    constexpr bool both_contiguous = (std::is_pointer_v<InputIterator> && std::is_pointer_v<ForwardIterator>);

    if constexpr (memcpyable && both_contiguous) {
        std::size_t nbytes = (char *)last - (char *)first;
        if (nbytes != 0) {
            std::memmove(std::addressof(*result), std::addressof(*first), nbytes);
        }
    } else if constexpr (memcpyable) {
        for (; first != last; (void)++result, ++first) {
            std::memmove(std::addressof(*result), std::addressof(*first), sizeof (T));
        }
    } else {
        for (; first != last; (void)++result, ++first) {
            ::new (static_cast<void*>(std::addressof(*result))) T(std::move(*first));
            std::destroy_at(std::addressof(*first));
        }
    }
}
```
</small>

The code in the first branch must use `memmove`, rather than `memcpy`, to preserve the
formally specified behavior in the case that the source range overlaps the destination range.

The code in the second branch, which performs one `memmove` per element, probably
doesn't have much of a performance benefit, and might be eliminated by library vendors.


## Conditionally trivial relocation ## {#sample-conditional}

We expect, but do not require, that `std::optional<T>` should be trivially relocatable
if and only if `T` itself is trivially relocatable. We propose no dedicated syntax for conditional
`[[trivially_relocatable]]`.

The following abbreviated implementation shows how to achieve an `optional<T>` which
has the same trivial-move-constructibility as `T`, the same trivial-destructibility
as `T`, and the same trivial-relocatability as `T`.

<small>
```
template<class T>
class optional :
    optional_a<T, is_trivially_relocatable<T>>
{
    using optional_a<T, is_trivially_relocatable<T>>::optional_a;
};

template<class T, bool R>
class optional_a :
    optional_b<T, is_trivially_destructible<T>, is_trivially_move_constructible<T>>
{
    using optional_b<T, is_trivially_destructible<T>,
        is_trivially_move_constructible<T>>::optional_b;
};

template<class T>
class [[trivially_relocatable]] optional_a<T, true> :
    optional_b<T, is_trivially_destructible<T>, is_trivially_move_constructible<T>>
{
    using optional_b<T, is_trivially_destructible<T>,
        is_trivially_move_constructible<T>>::optional_b;
};

template<class T, bool D, bool M>
class optional_b {
    union {
        char dummy_;
        T value_;
    };
    bool engaged_ = false;

    optional_b() = default;
    optional_b(inplace_t, Args&& args...) :
        engaged_(true), value_(std::forward<Args>(args)...) {}
    optional_b(optional_b&& rhs) {
        if (rhs.engaged_) {
            engaged_ = true;
            ::new (std::addressof(value_)) T(std::move(rhs.value_));
        }
    }
    ~optional_b() {
        if (engaged_) value_.~T();
    }
};

template<class T>
class optional_b<T, false, true> {
    union {
        char dummy_;
        T value_;
    };
    bool engaged_ = false;

    optional_b() = default;
    optional_b(inplace_t, Args&& args...) :
        engaged_(true), value_(std::forward<Args>(args)...) {}
    optional_b(optional_b&&) = default;
    ~optional_b() {
        if (engaged_) value_.~T();
    }
};

template<class T>
class optional_b<T, true, false> {
    union {
        char dummy_;
        T value_;
    };
    bool engaged_ = false;

    optional_b() = default;
    optional_b(inplace_t, Args&& args...) :
        engaged_(true), value_(std::forward<Args>(args)...) {}
    optional_b(optional_b&& rhs) {
        if (rhs.engaged_) {
            engaged_ = true;
            ::new (std::addressof(value_)) T(std::move(rhs.value_));
        }
    }
    ~optional_b() = default;
};

template<class T>
class optional_b<T, true, true> {
    union {
        char dummy_;
        T value_;
    };
    bool engaged_ = false;

    optional_b() = default;
    optional_b(inplace_t, Args&& args...) :
        engaged_(true), value_(std::forward<Args>(args)...) {}

    optional_b(optional_b&&) = default;
    ~optional_b() = default;
};
```
</small>


Appendix C: Examples of non-trivially relocatable class types {#non-trivial-samples}
=============================================================

## Class contains pointer to self ## {#non-trivial-sample-string}

As far as I know, no library vendor actually ships a `std::string` that looks like this,
but it is not entirely far-fetched to imagine a small-buffer optimization that
would be implemented this way. The same principle applies to any small-buffer-optimized
class.

<small>
```
struct string {
    char *data_ = sso();
    size_t size_ = 0;
    size_t capacity_ = 0;

    char *sso() const { return (char*)&capacity_; }
    size_t size_of_sso() const { return sizeof(*this) - offsetof(string, capacity_) - 1; }
    const char *data() const { return data_; }

    string() = default;
    string(const char *s) : size_(strlen(s)) {
        if (size_ < size_of_sso()) {
            strcpy(sso(), s);
        } else {
            capacity_ = size_;
            data_ = strdup(s);
        }
    }
    string(string&& s) : size_(s.size_) {
        memcpy(this, &s, sizeof(*this));
        if (s.data_ == s.sso())
            data_ = sso();
        else
            s.data_ = nullptr;
    }
    ~string() {
        if (data_ != sso())
            free(data_);
    }
};
```
</small>


## Class invariant depends on `this` ## {#non-trivial-sample-offset-ptr}

The `offset_ptr` provided by [[Boost.Interprocess]] is an example of this category.

<small>
```
struct offset_ptr {
    uintptr_t value_;

    uintptr_t here() const { return uintptr_t(this); }
    uintptr_t distance_to(void *p) const { return uintptr_t(p) - here(); }
    void *get() const { return (void*)(here() + value_); }

    offset_ptr() : value_(distance_to(nullptr)) {}
    offset_ptr(void *p) : value_(distance_to(p)) {}
    offset_ptr(const offset_ptr& rhs) : value_(distance_to(rhs.get())) {}
    offset_ptr& operator=(const offset_ptr& rhs) {
        value_ = distance_to(rhs.get());
        return *this;
    }
    ~offset_ptr() = default;
};
```
</small>


## Program invariant depends on `this` ## {#non-trivial-sample-registry}

This example was suggested by Mingxin Wang.
In the following snippet, `struct Widget` is relocatable, but not
trivially relocatable, because the relocation operation of destroying a `Widget` at point A
and constructing a new `Widget` at point B has behavior that is observably different
from a simple `memcpy`.

<small>
```
std::set<void *> registry;

struct registered_object {
    registered_object() { registry.insert(this); }
    registered_object(registered_object&&) = default;
    registered_object(const registered_object&) = default;
    registered_object& operator=(registered_object&&) = default;
    registered_object& operator=(const registered_object&) = default;
    ~registered_object() { registry.erase(this); }
};

struct Widget : registered_object {};
```
</small>


<pre class=biblio>
{
  "Any": {
    "authors": [
      "Eric Fiselier"
    ],
    "title": "libc++ implementation of std::any",
    "href": "https://github.com/llvm-mirror/libcxx/blob/8fdc4918/include/any#L389-L394",
    "date": "July 2016"
  },
  "Best": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "The Best Type Traits C++ Doesn't Have (video)",
    "href": "https://www.youtube.com/watch?v=MWBfmmg8-Yo",
    "date": "April 2018"
  },
  "Bench": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Benchmark code from \"The Best Type Traits C++ Doesn't Have\"",
    "href": "https://github.com/Quuxplusone/from-scratch/blob/095b246d/cppnow2018/benchmark-relocatable.cc",
    "date": "April 2018"
  },
  "Boost.Interprocess": {
    "authors": [
      "Ion Gaztañaga"
    ],
    "title": "Mapping Address Independent Pointer: offset_ptr",
    "href": "https://www.boost.org/doc/libs/1_67_0/doc/html/interprocess/offset_ptr.html",
    "date": "2005"
  },
  "Contra": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Contra built-in library types",
    "href": "https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/",
    "date": "April 2018"
  },
  "LWG2139": {
    "authors": [
      "Loïc Joly"
    ],
    "title": "LWG 2139: What is a user-defined type?",
    "href": "https://cplusplus.github.io/LWG/issue2139",
    "date": "March 2012–June 2018"
  },
  "LWG3119": {
    "authors": [
      "Hubert Tong"
    ],
    "title": "LWG 3119: Program-definedness of closure types",
    "href": "https://cplusplus.github.io/LWG/issue3119",
    "date": "June 2018—"
  },
  "N1377": {
    "authors": [
      "Howard Hinnant",
      "Peter Dimov",
      "Dave Abrahams"
    ],
    "title": "N1377: A Proposal to Add Move Semantics Support to the C++ Language",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm",
    "date": "September 2002"
  },
  "N4158": {
    "authors": [
      "Pablo Halpern"
    ],
    "title": "N4158: Destructive Move (Rev 1)",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf",
    "date": "October 2014"
  },
  "N4750": {
    "authors": [
      "ISO/IEC JTC1/SC22/WG21 - The C++ Standards Committee",
      "Richard Smith"
    ],
    "title": "N4750: Working Draft, Standard for Programming Language C++",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf",
    "date": "May 2018"
  },
  "P1029R0": {
    "authors": [
      "Niall Douglas"
    ],
    "title": "P1029R0: SG14 `[[move_relocates]]`",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1029r0.pdf",
    "date": "May 2018"
  },
  "Sane": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Thoughts on \"sanely move-assignable\"",
    "href": "https://quuxplusone.github.io/blog/2018/07/06/thoughts-on-sanely-move-assignable/",
    "date": "July 2018"
  },
  "TCF": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Trivially-constructible-from",
    "href": "https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/",
    "date": "July 2018"
  },
  "Wang": {
    "authors": [
      "Mingxin Wang"
    ],
    "title": "Better Performance in Polymorphic Programming: Trivially Swappable",
    "href": "https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ",
    "date": "June 2018"
  }
}
</pre>
