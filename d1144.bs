<pre class='metadata'>
Title: Object relocation in terms of move plus destroy
Shortname: D1144
Revision: 0
Audience: LEWG, EWG
Status: D
Group: WG21
URL:
!Current Source: <a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d1144.bs">github.com/Quuxplusone/draft/blob/gh-pages/d1144.bs</a>
!Current: <a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d1144.html">rawgit.com/Quuxplusone/draft/gh-pages/d1144.html</a>
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Editor: Mingxin Wang, wmx16835vv@163.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  We define a new algorithm "relocate" which is tantamount to a move and a destroy,
  analogous to the existing algorithm "swap" which is tantamount to a move, two move-assignments, and a destroy.
  For most (but not all) C++ types, the "relocate" operation is equivalent to a single <code>memcpy</code>.
  For the benefit of library writers, we provide a standard type trait to detect types whose "relocate" is known to be equivalent to <code>memcpy</code>.
  Finally, we provide a portable way for any user-defined type (such as <code>boost::shared_ptr</code>) to warrant to the implementation that its "relocate" is equivalent to <code>memcpy</code>, thus gaining the same performance benefits as the standard library types.
Date: 2018-07-06
</pre>

<style>
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>

# Revision History # {#changelog}

## Revision 0 ## {#changelog-r0}

    Initial revision.

# Introduction and motivation # {#intro}

If you are reading this paper, and you have not yet watched Arthur's session from C++Now 2018
on [[Best|"The Best Type Traits C++ Doesn't Have,"]] it will help if you immediately stop reading and
<a href="https://www.youtube.com/watch?v=MWBfmmg8-Yo">go watch</a>
the first 30 minutes of that video at 2x speed with the captions turned on.
It's going to be worth your 15 minutes. I'll wait.

In the video, besides showing implementation techniques and benchmark results, we defined our
terms. These terms are summarized briefly below.

C++17 knows the verbs "move," "copy," "destroy," and "swap," where "swap" is a higher-level operation
composed of several lower-level operations. To this list we propose to add the verb "relocate,"
which is a higher-level operation composed of exactly two lower-level operations.
Given an object type `T` and memory addresses `src` and `dst`,
the phrase "<dfn dfn-type="abstract-op">relocate</dfn> a `T` from `src` to `dst`" means no more and no
less than "*move-construct* `dst` from `src`, and then immediately
*destroy* the object at `src`."

Just as the verb "swap" produces the adjective "swappable," the verb "relocate" produces the adjective
"relocatable." Any type which is both move-constructible and
destructible is <dfn dfn-type="abstract-op">relocatable</dfn>. The notion can be modified by adverbs: we say that a type
is <dfn dfn-type="abstract-op">nothrow relocatable</dfn> if its relocation operation is noexcept, and we say that a type
is <dfn dfn-type="abstract-op">trivially relocatable</dfn> if its relocation operation is trivial (which, just like trivial move-construction
and trivial copy-construction, means "the operation is tantamount to a `memcpy`").

Almost all relocatable types are trivially relocatable: `std::unique_ptr<int>`,
`std::vector<int>`, `std::string`, `std::any`. Non-trivially relocatable
types exist but are rare: `boost::interprocess::offset_ptr<int>`, for example.

Issue:
Can we come up with a second realistic example of a non-trivially relocatable type?

Arthur has established (via [[Bench|benchmarks]] such as those shown in the video)
that if standard library code had a reliable way of detecting "trivial relocatability," we could optimize
that case and get a speed boost of up to 3x on routines that perform reallocation, such as

```
    std::vector<R>::resize
    std::vector<R>::reserve
    std::vector<R>::emplace_back
    std::vector<R>::push_back
```

Furthermore, Mingxin Wang points out that we can use the same "trivially relocatability" property to shrink the code
generated by small-buffer-optimized (SBO) type-erasing wrappers such as `std::function` and `std::any`.
For these types, a *move* of the wrapper object is implemented in terms of a
*relocation* of the contained object. (See for example [[Any|libc++'s std::any]],
where the function that performs the relocation operation is confusingly named `__move`.)
In general, the *relocate* operation for a contained type `C` involves calls to `C`'s
move constructor and destructor, which must be uniquely codegenned for each different `C`; the
number of instantiations of *relocate* scales linearly with the count of distinct types `C`
in the program.
But for any trivially relocatable `C`, its *relocate* operation depends only on the number of
bytes being `memcpy`ed, and so the number of instantiations of *relocate* scales linearly with the count
of distinct *sizes* of `C` being used in the program; or indeed, linearly with the count
of distinct *sizes of SBO buffer* being used in the program.

A smaller number of instantiations means faster compile times, a smaller text section, and perhaps
"hotter" code (because a relatively higher proportion of your code now fits in icache).

In between these two scenarios, we also find the move-constructor of `fixed_capacity_vector<R,N>`,
which can be implemented as an element-by-element *move* (leaving the source vector's elements in their
moved-from state), or can be implemented more efficiently as an element-by-element *relocate* (leaving
the source vector empty).

Note:
The name `fixed_capacity_vector` is my preferred name for the type
that Boost.Container calls `static_vector`.
`boost::container::static_vector<R,N>` implements the
less efficient element-by-element-move strategy. Moving-out-of a
`boost::container::static_vector` will not make the source vector
`empty()`.


# Design goals # {#design-goals}

Every C++ type already *is* or *is not* trivially relocatable. This proposal is not about
"making more types trivially relocatable."

The optimizations discussed above are purely in the domain of library vendors. If you're writing
a vector, and you detect that your element type `T` is trivially relocatable, then
whether you do any special optimization in that case is merely a Quality of Implementation (QoI) issue.
This proposal is not about "standardizing certain library optimizations."

What C++ lacks is a standard way for library vendors to *detect* the (existing) trivial relocatability
of a type `T`, so that they can reliably apply their (existing) optimizations.
All we really need is to add *detection*, and then all the optimizations described above will naturally
emerge without any further special effort by WG21.

Today we can detect the trivial relocatability of several of these categories, via the following definition.
We'll take this as our starting point.

```c++
    #include <type_traits>
    template<class T>
    struct is_trivially_relocatable : bool_constant<
        is_trivially_move_constructible_v<T> and
        is_trivially_destructible_v<T>
    > {};

    auto lam = [x=42]{};
    static_assert(is_trivially_relocatable< int >::value);
    static_assert(is_trivially_relocatable< decltype(lam) >::value);
```

## Standard library types such as `std::string` ## {#use1}

In order to optimize `std::vector<std::string>::resize`, we must come up with a way to achieve
```c++
    #include <string>
    static_assert(is_trivially_relocatable< std::string >::value);
```
This could be done unilaterally by the library vendor, via a non-standard attribute
(`[[clang::trivially_relocatable]]`), or a member typedef with a reserved name
(`using __is_triv_relocatable = void`), or simply a vendor-provided specialization
of `std::is_trivially_relocatable<std::string>`.

That is, we can solve this use-case with "magic" that is confined to the headers of the implementation itself.
The programmer doesn't have to learn anything new, so far.


## Program-defined types with defaulted special members ## {#use2}

Note: The term "program-defined types" is defined in [[LWG2139]] and [[LWG3119]].

In order to optimize the SBO `std::function` in any meaningful sense,
we must come up with a way to achieve
```c++
    #include <string>
    auto lam2 = [x=std::string("hello")]{};
    static_assert(is_trivially_relocatable< decltype(lam2) >::value);
```
Lambdas are not a special case in C++; they are simply class types with all their special members defaulted.
Therefore, presumably we should be able to use the same solution for lambdas as for
```c++
    #include <string>
    struct A {
        std::string s;
    };
    static_assert(is_trivially_relocatable< A >::value);
```
Here `struct A` follows the Rule of Zero: its move-constructor and destructor are both defaulted.
If they were also *trivial*, then we'd be done. In fact they are non-trivial; and yet, because the type's
bases and members are all of trivially relocatable types, the type as a whole *is* trivially relocatable.

This use-case asks specifically that we achieve the program above without breaking the "Rule of Zero."
We do not want to require the programmer to annotate `struct A` with a special attribute, or
a special member typedef, or anything like that. We want it to Just Work. Even for lambda types.
This is a much uglier problem than use-case #1. It requires core-language support.


## Program-defined types with non-defaulted special members ## {#use3}

In order to optimize `std::vector<boost::shared_ptr<T>>::resize`,
we must come up with a way to achieve
```c++
    struct B {
        B(B&&);  // non-trivial
        ~B();  // non-trivial
    };
    static_assert(is_trivially_relocatable< B >::value);
```
via some kind of programmer-provided annotation.

Note:
We cannot possibly do it without annotation, because there exist
examples of types that look just like `B` and *are* trivially relocatable (for example,
`boost::unique_ptr<int>`) and there exist types that look just like `B` and are
*not* trivially relocatable (for example, `boost::interprocess::offset_ptr<int>`).
The compiler cannot "crack open" the definitions of `B(B&&)` and `~B()` to see if
they combine to form a trivial operation. One, that's the Halting Problem. Two,
the definitions of `B(B&&)` and `~B()` might not be available in this translation
unit. Three, the definitions might actually be
available and "crackable" in *this* translation unit, but unavailable in some other translation unit!
This would lead to ODR violations and generally really bad stuff. So we cannot achieve
our goal by avoiding annotation.

This use-case is the only one that requires us to design the "opt-in" syntax.
In [[#use1]], any special syntax is hidden inside the
implementation's own headers. In [[#use2]], our design goal is to *avoid* special syntax.
In [[#use3]], WG21 must actually design user-facing syntax.

Therefore, I believe it would be acceptable to punt on use-case #3 and come back to it later.
We say, "Sure, that would be nice, but there's no syntax for it. Be glad that it works for
core-language and library types. Ask again in three years."  And as long as we leave the design
space open, I believe we wouldn't lose anything by delaying a solution to use-case #3.

This paper does propose a standard syntax for use-case #3 — which in turn provides a
*simple and portable* solution to use-case #1 for library vendors. However, this
solution is severable from the rest of this paper.


# Proposed language and library features # {#proposal}

This paper proposes five separate additions to the C++ Standard. These additions introduce
"relocate" as a well-supported C++ notion on par with "swap," and furthermore, successfully
communicate trivial relocatability in each of the three use-cases above.

  - A new standard algorithm, `uninitialized_relocate(first, last, d_first)`,
    in the `<memory>` header.

  - Additional type traits, `is_relocatable<T>` and `is_nothrow_relocatable<T>`,
    in the `<type_traits>` header.

  - A new type trait, `is_trivially_relocatable<T>`, in the `<type_traits>`
    header. This is the *detection* mechanism.

  - A new core-language rule by which a class type's "trivial relocatability"
    is inherited according to the Rule of Zero.

  - A new attribute, `[[trivially_relocatable]]`, in the core language.
    This is the *opt-in* mechanism for program-defined types.

These five bullet points are severable to a certain degree. For example, if the `[[trivially_relocatable]]`
attribute (points 4 and 5) is adopted, library vendors will certainly use it in their implementations;
but if the attribute is rejected, library vendors could still indicate the trivial relocatability
for certain standard library types by providing library specializations of `is_trivially_relocatable`
(point 3).

Points 1 and 2 are completely severable from points 3, 4, and 5;
but we believe these algorithms should be provided for symmetry with the
other uninitialized-memory algorithms in the `<memory>` header
(`uninitialized_copy`, `uninitialized_move`, and `destroy`)
and the other trios of type-traits in the `<type_traits>` header
(one such trio being `is_destructible`, `is_nothrow_destructible`,
`is_trivially_destructible`). I do not expect these templates to be frequently useful,
but I believe they must be provided, so as not to unpleasantly surprise the programmer
by their absence.

Points 3 and 4 together motivate point 5. In order to achieve the goal of [[#use2]],
we *must* define a core-language mechanism by which we can "inherit" trivial relocatability.
This is especially important for the template case.
```c++
    template<class T>
    struct D {
        T t;
    };

    // class C comes in from outside, already marked, via whatever mechanism
    constexpr bool c = is_trivially_relocatable< C >::value;
    constexpr bool dc = is_trivially_relocatable< D<C> >::value;
    static_assert(dc == c);
```
We propose that `std::is_trivially_relocatable<T>` should be just a plain old
class template, exactly like `std::is_trivially_destructible<T>` and so on.
The core language *[[Contra|should not know or care]]* that the class template
`is_trivially_relocatable` exists, any more than it knows that the class template
`is_trivially_destructible` exists.

We expect that the library vendor will implement `std::is_trivially_relocatable`,
just like `std::is_trivially_destructible`, in terms of a non-standard compiler
builtin whose natural spelling is `__is_trivially_relocatable(T)`. The compiler
computes the value of `__is_trivially_relocatable(T)` by inspecting the
definition of `T` (and the definitions of its base classes and members,
recursively, in the case that both of its special members are defaulted). This
recursive process "bottoms out" at primitive types, or at any type with a user-provided
move or destroy operation. Classes with user-provided move or destroy operations must
conservatively be assumed *not* to be trivially relocatable. To achieve the goal
of [[#use3]], we must provide a way for such a class to "opt in" and warrant to the
implementation that it is in fact trivially relocatable (despite being non-trivially
move-constructible and/or non-trivially destructible).

In point 5 we propose that the opt-in mechanism should be an attribute. The programmer
of a trivially relocatable but non-trivially destructible class `C` will mark it for
the compiler using the attribute:
```c++
    struct [[trivially_relocatable]] C {
        C(C&&);  // defined elsewhere
        ~C(); // defined elsewhere
    };
    static_assert(is_trivially_relocatable< C >::value);
```
The attribute overrides the compiler's usual computation. An example of a "conditionally"
trivially relocatable class is shown in [[#sample-conditional]].


# Proposed wording for C++20 # {#wording}

The wording in this section is relative to [[N4750|WG21 draft N4750]],
that is, the current draft of the C++17 standard.

Issue:
there is no wording here


# Further considerations and directions # {#further}

## Trivially swappable types ## {#trivially-swappable}

[[Wang|Mingxin Wang has proposed]] that "swap"
could be expressed in terms of "relocate". `std::swap` today is
typically implemented in terms of one move-construction, two move-assignments,
and one destruction; but there is nothing in the Standard that prevents a library
vendor from implementing it as three relocations, which in the trivially-relocatable
case (the usual case for most types) could be optimized into three calls to
`memcpy`.

For reasons [[Sane|described elsewhere]], it seems reasonable
to claim that move-assignment must always "do the sane thing," and therefore we
might propose to define
```c++
    template<class T>
    struct is_trivially_swappable : bool_constant<
        is_trivially_relocatable_v<T> and
        is_move_assignable_v<T>
    > {};
```
thus completing the currently-incomplete trio with
`is_swappable` and `is_nothrow_swappable`.

However, we do not propose "trivially swappable" at the present time.
It can easily be added in a later paper.


## Heterogeneous relocation ## {#hetero}

Consider that `is_relocatable_v<T>` means
`is_constructible_v<T,T&&> and is_destructible_v<T>`.
We have access to a heterogeneous `is_constructible<T,Us...>`,
and we have the precedent of a heterogeneous `is_swappable_with<T,U>`.
So, should we add a heterogeneous `is_relocatable_from`?

Notice that `uninitialized_copy` and `uninitialized_move`
are already heterogeneous.
Here is what a heterogeneous `uninitialized_relocate` would look like.
```c++
template<class FwdIt, class OutIt>
void uninitialized_relocate(FwdIt first, FwdIt last, OutIt d_first) {
    using SrcT = remove_cvref_t<decltype(*first)>;
    using DstT = remove_cvref_t<decltype(*d_first)>;
    static_assert(is_relocatable_from_v<DstT, SrcT>);
    if constexpr (is_trivially_relocatable_from_v<DstT, SrcT>) {
        static_assert(sizeof (SrcT) == sizeof(DstT));
        if constexpr (is_pointer_v<FwdIt> && is_pointer_v<OutIt>) {
            // Trivial relocation + contiguous iterators = memcpy
            size_t n = last - first;
            if (n) memcpy(d_first, first, n * sizeof (SrcT));
            d_first += n;
        } else {
            while (first != last) {
                memcpy(addressof(*d_first), addressof(*first), sizeof (SrcT));
                ++d_first; ++first;
            }
        }
    } else {
        while (first != last) {
            ::new ((void*)addressof(*d_first)) DstT(move(*first));
            (*first).~SrcT();
            ++d_first; ++first;
        }
    }
    return d_first;
}
```
This implementation could be used to quickly relocate an array of
`int*` into an array of `unique_ptr<int>`
(but not vice versa). It could also be used to quickly relocate an array of
`T` into an array of `tombstone::optional<T>`. (The concept of "tombstone optional"
is described in [[Best]].)
All we'd need is for somebody to set the value of `is_trivially_relocatable_from`
appropriately for each pair of types in the program.

I think this is a very intriguing idea. The detection syntax (`is_trivially_relocatable_from`)
is fairly obvious. But I don't see what the opt-in syntax
would look like on a program-defined class such as `tombstone::optional`.
Let's leave that problem alone for a few years and see what develops.

We could conceivably provide the detection trait `is_trivially_relocatable_from` today,
with deliberately curtailed semantics, e.g.:
```c++
    template<class T, class U>
    struct is_trivially_relocatable_from : bool_constant<
        is_trivially_relocatable_v<T> and
        is_same_v<U, remove_cvref_t<T>>
    > {};
    template<class T, class U>
    struct is_trivially_relocatable_from<T, U&> : is_trivially_relocatable_from<T, U> {};
    template<class T, class U>
    struct is_trivially_relocatable_from<T, U&&> : is_trivially_relocatable_from<T, U> {};
```
plus permission for vendors to extend the trait via partial specializations on
a QoI basis:
```c++
    template<class T>
    struct is_trivially_relocatable_from<unique_ptr<T>, T*> : true_type {};
    template<class T>
    struct is_trivially_relocatable_from<const T*, T*> : true_type {};
    struct is_trivially_relocatable_from<int, unsigned> : true_type {};
    // and so on
```
However, if we do this, we may soon find that programmers are adding specializations
of `is_trivially_relocatable_from` to their own programs, because they find it
makes their code run faster. It will become a de-facto customization point, and we will
never be able to "fix it right" for fear of breaking programmers' existing code.

Therefore, I believe that we should *not* pursue "heterogeneous" relocation
operations at the present time.

Note that vendors are already free to optimize heterogeneous operations inside
library algorithms, under the as-if rule. We lack a portable and generic detection
trait, but vendors are presumably well aware of specific special cases that they
*could* detect and optimize today —
for example, a `std::copy` from an array of `int*` into
an array of `const int*`, or from an array of 64-bit `long` into
an array of 64-bit `long long` (see [[TCF]]).
Today vendors generally choose not to perform these optimizations.


# Acknowledgements # {#acknowledgements}

Thanks to Elias Kosunen and Niall Douglas for their feedback on early drafts of this paper.


Appendix A: Straw polls requested {#polls}
==========

## Polls for LEWG ## {#lewg-polls}

<table class="def">
<tr><th style="width: 70%;"></th><th>**SF**</th><th>**F**</th><th>**N**</th><th>**A**</th><th>**SA**</th></tr>

<tr><th><small>The algorithm `uninitialized_relocate(first, last, d_first)` should be added to the `<memory>` header,
as proposed in this paper.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>The type trait `is_relocatable<T>` (and its `_v` version) should be added to the `<type_traits>` header, as proposed in this paper.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>If `is_relocatable<T>` *is* added, then we should also add `is_nothrow_relocatable<T>` (and its `_v` version), as proposed in this paper.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>The type trait `is_trivially_relocatable<T>` (and its `_v` version) should be added to the `<type_traits>` header, under that exact name, as proposed in this paper.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>We approve of a trait with the semantics of `is_trivially_relocatable<T>`, but not necessarily under that exact name. (For example, `is_bitwise_relocatable`.)</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>If `is_trivially_relocatable<T>` *is* added, under that exact name, then the type trait `is_trivially_swappable<T>` (and its `_v` version) should also be added to the `<type_traits>` header.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>
</table>


## Polls for EWG ## {#ewg-polls}

<table class="def">
<tr><th style="width: 70%;"></th><th>**SF**</th><th>**F**</th><th>**N**</th><th>**A**</th><th>**SA**</th></tr>

<tr><th><small>We approve of the general idea that user-defined classes should be able to warrant their own trivial relocatability.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>We approve of the general idea that user-defined classes which follow the Rule of Zero should inherit the trivial relocatability of their bases and members.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>Nobody should be able to warrant the trivial relocatability of `class C` except for `class C` itself (i.e., we do not want to see a customization point analogous to `std::hash`).</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>If a trait with the semantics of `is_trivially_relocatable<T>` is added to the `<type_traits>` header, the programmer should be permitted to specialize it for program-defined types (i.e., we want to see that trait itself become a customization point analogous to `std::hash`).</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>A class should be able to warrant its own trivial relocatability via the attribute `[[trivially_relocatable]]`, as proposed in this paper.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>A class should be able to warrant its own trivial relocatability via some attribute, but not necessarily under that exact name.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>

<tr><th><small>A class should be able to warrant its own trivial relocatability as proposed in this paper, but via a contextual keyword rather than an attribute.</th>
<th>_</th><th>_</th><th>_</th><th>_</th><th>_</th></tr>
</table>


Appendix B: Sample code {#samples}
======================

## Defining a trivially relocatable function object ## {#sample-deducing}

The following sample illustrates [[#use2]]. Here `A` is a program-defined type
following the Rule of Zero. Because all of its bases and members are warranted as
trivially relocatable, and its move-constructor and destructor are both defaulted,
the compiler concludes that `A` itself is trivially relocatable.
```
    #include <string>
    #include <type_traits>

    // Assume that the library vendor has taken care of this part.
    static_assert(std::is_trivially_relocatable_v< std::string >);

    struct A {
        std::string s;
        std::string operator()(std::string t) const { return s + t; }
    };

    static_assert(std::is_trivially_relocatable_v< A >);
```

The following sample, involving an implementation-defined closure type,
also illustrates [[#use2]].
```
    #include <string>
    #include <type_traits>

    // Assume that the library vendor has taken care of this part.
    static_assert(std::is_trivially_relocatable_v< std::string >);

    auto a = [s = std::string("hello")](std::string t) {
        return s + t;
    };

    static_assert(std::is_trivially_relocatable_v< decltype(a) >);
```

## Warranting that a user-defined relocation operation is equivalent to `memcpy` ## {#sample-opting-in}

The following sample illustrates [[#use3]]. The rules proposed in this paper ensure
that any type with non-trivial user-defined move and destructor operations will be
considered non-trivially relocatable by default.
```
    #include <type_traits>

    struct C {
        const char *s = nullptr;
        C(const char *s) : s(s) {}
        C(C&& rhs) : s(rhs.s) { rhs.s = nullptr; }
        ~C() { delete s; }
    };

    static_assert(not std::is_trivially_relocatable_v< C >);

    struct D : C {};

    static_assert(not std::is_trivially_relocatable_v< D >);
```

The programmer may apply the `[[trivially_relocatable]]` attribute to override the compiler's default
behavior and warrant (under penalty of undefined behavior) that this type is in fact trivially relocatable.
```
    #include <type_traits>

    struct [[trivially_relocatable]] E {
        const char *s = nullptr;
        E(const char *s) : s(s) {}
        E(C&& rhs) : s(rhs.s) { rhs.s = nullptr; }
        ~E() { delete s; }
    };

    static_assert(std::is_trivially_relocatable_v< E >);

    struct F : E {};

    static_assert(std::is_trivially_relocatable_v< F >);
```


## Reference implementation of `std::uninitialized_relocate` ## {#sample-uninit-relocate}

Issue: there is no sample code here yet


## Conditionally trivial relocation (`std::optional`) ## {#sample-conditional}

Issue: there is no sample code here yet


<pre class=biblio>
{
  "Any": {
    "authors": [
      "Eric Fiselier"
    ],
    "title": "libc++ implementation of <code>std::any</code>",
    "href": "https://github.com/llvm-mirror/libcxx/blob/8fdc491860efbccb65ab2f01ec25e13b024da538/include/any#L389-L394",
    "date": "July 2016"
  },
  "SV": {
    "authors": [
      "Microsoft"
    ],
    "title": "CComPtr::operator& Operator",
    "href": "https://msdn.microsoft.com/en-us/library/31k6d0k7.aspx",
    "date": "2015"
  },
  "Best": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "The Best Type Traits C++ Doesn't Have (video)",
    "href": "https://www.youtube.com/watch?v=MWBfmmg8-Yo",
    "date": "April 2018"
  },
  "Bench": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Benchmark code from \"The Best Type Traits C++ Doesn't Have\"",
    "href": "https://github.com/Quuxplusone/from-scratch/blob/095b246d4dc9b88fbdbb6c38771866c0a25289db/cppnow2018/benchmark-relocatable.cc",
    "date": "April 2018"
  },
  "Contra": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "<i>Contra</i> built-in library types",
    "href": "https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/",
    "date": "April 2018"
  },
  "LWG2139": {
    "authors": [
      "Loïc Joly"
    ],
    "title": "LWG 2139: What is a user-defined type?",
    "href": "https://cplusplus.github.io/LWG/issue2139",
    "date": "March 2012–June 2018"
  },
  "LWG3119": {
    "authors": [
      "Hubert Tong"
    ],
    "title": "LWG 3119: Program-definedness of closure types",
    "href": "https://cplusplus.github.io/LWG/issue3119",
    "date": "June 2018—"
  },
  "N4750": {
    "authors": [
      "ISO/IEC JTC1/SC22/WG21 - The C++ Standards Committee",
      "Richard Smith"
    ],
    "title": "N4750: Working Draft, Standard for Programming Language C++",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf",
    "date": "May 2018"
  },
  "P1029R0": {
    "authors": [
      "Niall Douglas"
    ],
    "title": "P1029R0: SG14 `[[move_relocates]]`",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1029r0.pdf",
    "date": "May 2018"
  },
  "Sane": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Thoughts on \"sanely move-assignable\"",
    "href": "https://quuxplusone.github.io/blog/2018/07/06/thoughts-on-sanely-move-assignable/",
    "date": "July 2018"
  },
  "TCF": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Trivially-constructible-from",
    "href": "https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/",
    "date": "July 2018"
  },
  "Wang": {
    "authors": [
      "Mingxin Wang"
    ],
    "title": "Better Performance in Polymorphic Programming: Trivially Swappable",
    "href": "https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ",
    "date": "June 2018"
  }
}
</pre>
