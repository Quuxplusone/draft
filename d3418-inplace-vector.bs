<pre class='metadata'>
Title: Wording for P3160R2 <code>inplace_vector</code>'s "construct/destroy" alternative
Shortname: D3418
Revision: 0
!Draft Revision: 15
Audience: LEWG
Status: D
Group: WG21
URL:
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  P3160R2 proposes to make `inplace_vector` an allocator-aware container.
  It offers two design alternatives, nicknamed "uses-allocator" and "construct/destroy,"
  and presents wording for the "uses-allocator" alternative.
  This paper (P3418) provides wording for the "construct/destroy" alternative.
  This paper also provides additional motivation for allocator-awareness.
Date: 2024-10-10
</pre>

<style>
hilite  {background-color: #FFFF00; font-weight: bold;}
ins     {background-color: #CCFFCC; text-decoration: underline;}
insarthur  {background-color: #FFFFCC; text-decoration: underline;}
inspablo   {background-color: #DDDDFF; text-decoration: underline;}
del     {background-color: #FFCACA; text-decoration: line-through;}
p       {-moz-hyphens: none; -ms-hyphens: none; -webkit-hyphens: none; hyphens: none;}
p.p     {margin: 0em 2em 0.5em 2em;}
</style>

# Changelog # {#changelog}

- R0:

    - Wording drafted by Arthur O'Dwyer.
    - Added discussion of freestanding, `noexcept`, and preconditions.


# Motivation and proposal # {#proposal}

[[P0843]] introduced `inplace_vector<T, N>` to the C++26 working draft.
[[P3160R1]] proposes that `inplace_vector` should support an allocator parameter, thus allowing it
to use that allocator's `construct` and `destroy` members, even though it never needs to `allocate`.

(1) This permits `inplace_vector` to interoperate with allocator-extended client code, thus
making it a better drop-in replacement for `vector`. For example:

<table>
<tr>
<td colspan="2">
```cpp
template<class Ctr, class... Args>
Ctr f(Args... args) {
  using Alloc = typename Ctr::allocator_type;
  Alloc alloc(args...);
  return Ctr(alloc);
}
```
</td>
</tr>
<tr>
<td>
<pre>
auto v1 = f&lt;std::vector&lt;int>>();
&nbsp;
auto v3 = f&lt;std::pmr::vector&lt;int>>(&amp;mr);
</pre>
</td>
<td>
<pre>
auto v1 = f&lt;std::vector&lt;int>>();
<ins>auto v2 = f&lt;std::inplace_vector&lt;int, 3>>();</ins>
auto v3 = f&lt;std::pmr::vector&lt;int>>(&amp;mr);
</pre>
</td>
</tr>
</table>

(2) This permits using `inplace_vector` with a PMR allocator. The vector's elements are still
allocated directly in-place inside the memory footprint of the `inplace_vector` object, but
the elements *in turn* are constructed with allocator-extended construction.
Without allocator-awareness, the code is cumbersome and error-prone. Notice that neither
snippet below ever allocates from the global heap.

<table>
<tr>
<td colspan="2">
<pre>
std::pmr::set_default_resource(nullptr);
char buf[10'000];
std::pmr::monotonic_buffer_resource mr(buf, 10'000);
</pre>
</td>
</tr>
<tr>
<td>
<pre>
std::inplace_vector&lt;std::pmr::string, 5> pv;
const char *contents[] = {
  "A string so long that it requires heap allocation",
  "A short string",
};
<del>for (const char *p : contents) {</del>
  <del>pv.emplace_back(p, &amp;mr);</del>
<del>}</del>
pv.emplace_back("A string so long that it requires heap allocation", <del>&amp;mr</del>);
</pre>
</td>
<td>
<pre>
std::pmr::inplace_vector&lt;std::pmr::string, 5> pv(&amp;mr);
const char *contents[] = {
  "A string so long that it requires heap allocation",
  "A short string",
};
<ins>pv.insert(contents.begin(), contents.end());</ins>
pv.emplace_back("A string so long that it requires heap allocation");
</pre>
</td>
</tr>
</table>

(3) This permits using `inplace_vector` with a Boost.Interprocess allocator,
with the same benefits as the PMR example above: less code to write, and
fewer chances to write bugs by accident.
See <a href="https://quuxplusone.github.io/blog/2024/08/23/boost-interprocess-tutorial/">"Boost.Interprocess, and `sg14::inplace_vector`"</a> (2024-08-23).

<table>
<tr>
<td colspan="2">
<pre>
namespace bip = boost::interprocess;
namespace shm {
  template&lt;class T> using allocator = std::scoped_allocator_adaptor&lt;bip::allocator&lt;T, bip::managed_shared_memory::segment_manager>>;
  template&lt;class T> using vector = std::vector&lt;T, shm::allocator&lt;T>>;
  using string = boost::container::basic_string&lt;char, std::char_traits&lt;char>, shm::allocator&lt;char>>;
}
auto segment = bip::managed_shared_memory(bip::create_only, SHM_SEGMENT_NAME, 10'000);
auto alloc = shm::allocator&lt;int>(segment.get_segment_manager());
</pre>
</td></tr>
<tr><td>
<pre>
namespace shm {
  template&lt;class T>
  using vector = std::vector&lt;T, shm::allocator&lt;T>>;
}
using VecOfStrings = shm::vector&lt;shm::string>;
auto *p = segment.construct&lt;VecOfStrings>("S")(argv+2, argv+argc, alloc);
</pre>
</td><td>
<pre>
namespace shm {
  template&lt;class T, size_t N>
  using inplace_vector = std::inplace_vector&lt;T, N, shm::allocator&lt;T>>;
}
using IPVOfStrings = shm::inplace_vector&lt;shm::string, 5>;
auto *p = segment.construct&lt;IPVOfStrings>("S")(argv+2, argv+argc, alloc);
</pre>
</td></tr>
<tr><td>
<pre>
using IPVOfStrings = <del>std</del>::inplace_vector&lt;shm::string, 5>;
<del>auto *p = segment.construct&lt;IPVOfStrings>("S")();</del>
<del>for (int i = 2; i &lt; argc; ++i) {</del>
  <del>p->emplace_back(argv[i], alloc);</del>
<del>}</del>
</pre>
</td><td>
<pre>
using IPVOfStrings = <ins>shm</ins>::inplace_vector&lt;shm::string, 5>;
<ins>auto *p = segment.construct&lt;IPVOfStrings>("S")(argv+2, argv+argc, alloc);</ins>
&nbsp;
&nbsp;
&nbsp;
</pre>
</td></tr>
</table>

(4) This gives the programmer control over the `size_type` and `difference_type` members
of `inplace_vector`, permitting a predictably smaller (or larger) memory footprint.
Now, STL vendors *could* implement memory-footprint optimizations to store the `size` member
in fewer bits when `N` was small; but we have seen from our experience with `variant`
that vendors do not do such optimizations in practice, and then get locked out of them
forever by ABI. Giving control to the programmer is more general *and* reduces the
STL vendor's own workload. (<a href="https://godbolt.org/z/78rf9dvnz">Godbolt.</a>)

<table>
<tr>
<td>
<pre>
<br><br><br><br><br><br><br><br><br><br>
static_assert(sizeof(std::inplace_vector&lt;char, 3>) == 16);
</pre>
</td>
<td>
<pre>
namespace Tiny {
  template&lt;class T>
  struct Alloc {
    using value_type = T;
    using size_type = uint8_t;
    static T* allocate(size_t) { assert(false); }
    static void deallocate(T*) { assert(false); }
  };
  template&lt;class T, size_t N>
  using inplace_vector = std::inplace_vector&lt;T, N, Tiny::Alloc&lt;T>>;
}
static_assert(sizeof(std::inplace_vector&lt;char, 3>) == 16);
<ins>static_assert(sizeof(Tiny::inplace_vector&lt;char, 3>) == 4);</ins>
</pre>
</td>
</tr>
</table>

Note: Mital Ashok's draft implementation of `inplace_vector` for libc++ ([[Mital]]) does store the `size` in a reduced footprint,
based on the absolute value of `N`. That is, we have "reduced the STL vendor's workload" in an area where libc++
has already done that work! libc++ also uses a reduced footprint for `variant`'s index in its "unstable ABI" mode.
This proposal doesn't forbid an implementation like Mital's; libc++ is free to continue using a reduced footprint even after this proposal.
But certainly argument (4) in favor is weak: the space-saving is superfluous (in libc++'s case) and non-portable
(since different STL vendors may continue to choose different types for the `size` data member regardless of
`Allocator::size_type`). From the user-programmer's point of view, it matters only that there is *some* way to
store the `size` member in fewer than eight bytes: either every STL vendor commits to store `size` in the minimum possible number of bytes,
or this proposal is adopted and every STL vendor commits to store `size` in a type no larger than `Allocator::size_type`.

## Notes on freestanding ## {#freestanding}

`inplace_vector<T, N>` is freestanding. We don't propose to change that.
But now it's a synonym for `inplace_vector<T, N, allocator<T>>`.
So, `allocator<T>` needs to become freestanding.
Freestanding implementations lack a heap, so `allocator<T>::allocate` becomes
a <i>freestanding-deleted</i> member function (<a href="https://eel.is/c++draft/library#freestanding.item-3">[freestanding.item]/3</a>),
which means that it may be `=delete`'d if not provided by a freestanding implementation.
This is fine because `inplace_vector` doesn't use `allocate` or `deallocate`.

`allocator_traits` is already freestanding in C++23, thanks to Ben Craig's [[P1642]].
But it is UB to instantiate `allocator_traits<A>` unless `A` meets
the allocator requirements (<a href="https://eel.is/c++draft/library#allocator.requirements.general-3.sentence-2">[allocator.requirements]/3</a>),
and the allocator requirements require that `A::allocate` must be present!

We could solve this conundrum in any of the following ways:

- Declare by fiat: "All specializations of `allocator` meet the allocator requirements,
    regardless of whether they provide `allocate` and `deallocate` member functions."
    (But what about program-defined types that derive from `allocator`?)

- Change the effects of `allocator<T>::allocate` to permit it to Do Something Else on
    freestanding implementations. (But this makes it untrustworthy. This is a bad idea.)

- Change the allocator requirements to permit `allocate` and `deallocate` to be missing
    on freestanding implementations (only).

Arthur drafted wording for the third option, but Pablo suggests taking a variation on
that approach that basically anticipates Ben Craig's [[P3295]] — marking `allocate` and `deallocate`
with a new "freestanding-consteval" category — except that instead of copying large
portions of [[P3295]] into this paper, we simply achieve the same effect with a <i>Note</i>.
If [[P3295]] is adopted, we can easily update our <i>Note</i> to use the <i>freestanding-consteval</i> markup instead.


## Notes on feature-test macros ## {#wording-ftm}

For the non-freestanding case, it's easy: vendors just bump `__cpp_lib_inplace_vector` and are done.
This subsection exists only because the freestanding situation is messier than that,
because we are making `allocator` partially freestanding.

This situation falls under [[P2198]]'s subsection labeled "Detect C++20 (or older) feature that is now partially required in freestanding."
Ben Craig, in email, suggests this four-macro design.

<table>
<tr><th>Macro</th><th>Meaning</th></tr>
<tr><td>`__cpp_lib_inplace_vector`&nbsp;(exists)</td><td>If `202406L`, P0843 is fully implemented; if `YYYYMML`, allocator-aware `inplace_vector` is fully implemented</td></tr>
<tr><td>`__cpp_lib_freestanding_inplace_vector`&nbsp;(new)</td><td>At least the freestanding subset of `inplace_vector` is available (but e.g. the <i>freestanding-deleted</i> iterator-pair constructor might be `=delete`d)</td></tr>
<tr><td>`__cpp_lib_allocator`&nbsp;(new)</td><td>`std::allocator` is fully implemented (including `allocate` and `deallocate`)</td></tr>
<tr><td>`__cpp_lib_freestanding_allocator`&nbsp;(new)</td><td>At least the freestanding subset of `std::allocator` is available (but e.g. `allocate` might be `=delete`d)</td></tr>
</table>

Note: The freestanding-deleted members, such as the
iterator-pair constructor, are freestanding-deleted not because they *allocate* (they don't) but because they *throw.*

The existing feature-test macros related to allocator support on freestanding are C++23's `__cpp_lib_allocate_at_least` (the last major
change to `allocator`/`allocator_traits`), C++26's `__cpp_lib_freestanding_memory`, and C++26's `__cpp_lib_freestanding_operator_new`
(effectively indicates whether heap allocation is available).

## Notes on allocator propagation ## {#pocma}

The STL uses allocators both for allocation/deallocation and for construction/destruction. So the happy path
for STL containers is when the allocator sticks alongside both the value of the data pointer (which must be deallocated)
and the lifetimes of the element objects (which must be destroyed).

Containers that store their elements on the heap want POCCA/POCMA/POCS to be `true`: they'll
simply swap the allocator alongside the data pointer.
When POCCA/POCMA/POCS is `false`, those containers are unhappy: their constant-time move operations
become linear-time and throwing, and their `swap` (which refuses to become throwing) requires that the two
allocators be equal, on pain of UB.

`inplace_vector` wants POCCA/POCMA/POCS to be `false`!
Each element of `v1` is itself an object that was constructed via `allocator_traits<A>::construct(a1, ...)`
and must eventually be destroyed by `allocator_traits<A>::destroy(a1, ...)`. Therefore, as long as `v1` has
any elements, `v1` must never forget about `a1`. When POCCA/POCMA/POCS is `false`, this is easy and natural.
When POCCA/POCMA/POCS is `true`, `inplace_vector` is unhappy: its copy-assignment, move-assignment, and `swap`
require for correctness that the two allocators be equal, on pain of UB.

For an example involving `CountingAlloc<T>`, see <a href="https://godbolt.org/z/v9xvEPdaG">this Godbolt</a>.

<table>
<tr><th>Operation</th><th>Heap-storage `vector`</th><th>`inplace_vector`</th></tr>
<tr><th>Move construction</th><td>
  Non-allocating and O(1)
</td><td>
  Non-allocating and O(n)
</td></tr>
<tr><th>Copy construction</th><td>
  O(n)
</td><td>
  non-allocating and O(n)
</td></tr>
<tr><th>Move assignment</th><td>
  Non-allocating and O(1) by default.
  If `!POCMA` and `!is_always_equal`, it becomes allocating and O(n)
</td><td>
  Non-allocating and O(n).
  If `POCMA` and `!is_always_equal`, it may have UB
</td></tr>
<tr><th>Copy assignment</th><td>
  O(n)
</td><td>
  Non-allocating and O(n).
  If `POCCA` and `!is_always_equal`, it may have UB
</td></tr>
<tr><th>Swap</th><td>
  Non-allocating, `noexcept`, and O(1).
  If `!POCS` and `!is_always_equal`, it may have UB
</td><td>
  Non-allocating and O(n).
  If `POCS` and `!is_always_equal`, it may have UB
</td></tr>
</table>

We follow the Lakos rule and make each special member function `noexcept(false)` whenever
it may have UB.

Theoretically, we could special-case the preconditions to make it *not* UB to swap/assign two vectors
with unequal propagating allocators *if* either vector is empty — because then
there's no insurmountable physical difficulty with `CountingAlloc`.
However, that idea would complicate the spec, make more work for vendors, and make the UB condition
less legible to users. So we don't do that.

### Notes on preconditions ### {#pocs-ub}

For `swap` in particular, even if we assume the "construct/destroy" model instead of the "uses-allocator" model,
Arthur and Pablo disagree as to what would be the appropriate precondition w.r.t. allocator equality.
Arthur's proposed wording is as follows.
The first part of the <i>Precondition</i> element is modeled on <a href="https://eel.is/c++draft/alg.swap#2">[alg.swap]/2</a>
(as used by <a href="https://eel.is/c++draft/array#members-4">`array::swap`</a>), and the second part (the part
dealing with allocators) is modeled
on <a href="https://eel.is/c++draft/container.requirements#container.reqmts-65">[container.reqmts]/65</a>.

<small><blockquote>
<p><pre><ins>constexpr void swap(inplace_vector& x) noexcept(<i>see below</i>);</ins>
</pre>
<p class="p"><ins>x․ *Preconditions:* Let *M* be `min(size(), x.size())`.
For each non-negative integer *n* &lt; *M*, `(*this)[n]` is swappable with ([swappable.requirements]) `x[n]`.
If `allocator_traits<allocator_type>::propagate_on_container_swap::value` is `true`, then
`allocator_type` meets the <i>`Cpp17Swappable`</i> requirements and `get_allocator() == x.get_allocator()`.</ins>
<p class="p"><ins>x․ *Effects:*</ins> [...]
</blockquote></small>

Pablo would prefer something more like this:

<small><blockquote>
<p><pre><ins>constexpr void swap(inplace_vector& x) noexcept(<i>see below</i>);</ins>
</pre>
<p class="p"><ins>x․ *Preconditions:* Let `a1` and `a2` be `get_allocator()` and `x.get_allocator()`, respectively; `p1` and `p2` be pointers of type `T*` to
storage suitable to hold an object of type `T`;
and `args1` and `args2` be function parameter packs such that `T(args1...)` and `T(args2...)` are well-formed and well-defined.
The following shall be well-formed and well-defined:</ins>
<div style="margin: 0.5em 2em;"><pre>
<ins>allocator_traits&lt;allocator_type>::construct(a1, p1, args1...);</ins>
<ins>allocator_traits&lt;allocator_type>::construct(a2, p2, args2...);</ins>
<ins>using std::swap;</ins>
<ins>swap(*p1, *p2);</ins>
<ins>if constexpr (allocator_traits&lt;allocator_type>::propagate_on_container_swap::value)</ins>
  <ins>swap(a1, a2);</ins>
<ins>allocator_traits&lt;allocator_type>::destroy(a1, p1);</ins>
<ins>allocator_traits&lt;allocator_type>::destroy(a2, p2);</ins>
</pre></div>
<p class="p"><ins>[<i>Note:</i> In other words, when `propagate_on_container_swap::value` is `false`, it must be valid to swap the individual elements even when the allocators do not compare equal.
Conversely, when `propagate_on_container_swap::value` is `true`, it must be valid to destroy the swapped elements using the swapped allocators, even though the call to `destroy`
uses a different allocator than the corresponding call to `construct`. <i>—end note</i>]</ins>
<p class="p"><ins>x․ *Effects:*</ins> [...]
</blockquote></small>

We encourage discussion as to which direction LEWG prefers.

Arthur's precondition has the benefit of being checkable at runtime,
because it involves the values of computable expressions like `get_allocator() == x.get_allocator()`.
An implementation would be allowed to assert-fail if the precondition was violated, using something like
SG14's `SG14_INPLACE_VECTOR_ASSERT_PRECONDITION` macro or libc++'s `_LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR` macro.

Pablo's precondition is not checkable at runtime, but has the benefit of being looser: it permits the user to swap
`inplace_vector`s with allocators that are "unequal, yet functionally interchangeable." The `inplace_vector`
implementation would be forbidden to assert-fail inside `operator=` or `swap`.

It is not possible to violate either precondition with `std::allocator` (which is always equal) nor with
`std::pmr::polymorphic_allocator` (which doesn't propagate).

[[LWG4151]] is related: `inplace_vector::swap` is already missing a precondition today.
Both of the above-proposed preconditions are supersets of LWG4151's proposed resolution.


## Notes on noexceptness ## {#noexceptness}

We expect that in practice, STL vendors will take approximately the same approach to noexceptness
which `sg14::inplace_vector` has taken. This approach is:

```cpp
    static constexpr bool CopyCtorIsNoexcept =
        ((std::is_nothrow_copy_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, const T&>::value) || (N == 0)) &&
        sg14::aaipv::propagate_on_container_copy_construction<Alloc>::value;

    static constexpr bool MoveCtorIsNoexcept =
        ((std::is_nothrow_move_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value) || (N == 0));

    static constexpr bool CopyAssignIsNoexcept =
        ((std::is_nothrow_copy_constructible_v<T> &&
          std::is_nothrow_copy_assignable_v<T> &&
          std::is_nothrow_destructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, const T&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
        (std::allocator_traits<Alloc>::is_always_equal::value || !std::allocator_traits<Alloc>::propagate_on_container_copy_assignment::value);

    static constexpr bool MoveAssignIsNoexcept =
        ((std::is_nothrow_move_constructible_v<T> &&
          std::is_nothrow_move_assignable_v<T> &&
          std::is_nothrow_destructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
        (std::allocator_traits<Alloc>::is_always_equal::value || !std::allocator_traits<Alloc>::propagate_on_container_move_assignment::value);

    static constexpr bool SwapIsNoexcept =
        ((std::is_nothrow_swappable_v<T> &&
          std::is_nothrow_move_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
         (std::allocator_traits<Alloc>::is_always_equal::value || !std::allocator_traits<Alloc>::propagate_on_container_swap::value);
```

Here `sg14::aaipv::propagate_on_container_copy_construction<Alloc>` is `true` iff
`select_on_container_copy_construction` is defaulted to simply copy the allocator (which cannot throw);
`sg14::aaipv::has_trivial_construct<Alloc, T, Args...>` is `true` iff `construct(p, args...)` is defaulted
to simply call `std::construct(p, args...)`; and `sg14::aaipv::has_trivial_destroy<Alloc, T>` is `true` iff `destroy(p)` is
defaulted to simply call `std::destroy_at(p)`. STL vendors might reasonably choose to further specialize these
helpers for `std::allocator` and `std::pmr::polymorphic_allocator`.

However, for wording purposes, we can't use these helpers because they aren't standardized: we don't have any
easy way to invoke them in the wording. So our proposed wording is written as if each helper trait always yields `false`,
but in a way that (we intend) permits the STL vendor to strengthen the noexcept guarantee — and we hope that they will do so!

Note: <a href="https://eel.is/c++draft/res.on.exception.handling#5">[res.on.exception.handling]/5</a> permits STL vendors
only to add `noexcept` to function signatures that completely lack it; it doesn't permit vendors to strengthen `noexcept(A)`
into `noexcept(A || B)`. This is unfortunate.

Our exception-specifications don't mention the copy/move/equality operations on `Alloc` itself,
because <a href="https://eel.is/c++draft/allocator.requirements">[allocator.requirements]</a> forbids these
operations to throw (on pain of UB).


# Implementation experience # {#experience}

Arthur has implemented [[#wording]] in [[QuuxplusoneSG14]] (see <a href="https://godbolt.org/z/c9W44Kr1v">Godbolt</a>).
This includes extensive unit tests verifying that:

- The proposed `inplace_vector<T, N, std::allocator<T>>` is an exact drop-in replacement
    for the original `inplace_vector<T, N>`, with the same
    sizeof, alignof, triviality, and noexcept.

- The proposed `inplace_vector<T, N, Alloc>` works correctly with `std::pmr`.

- The proposed `inplace_vector<T, N, Alloc>` works correctly with Boost.Interprocess.

- The proposed `inplace_vector<T, N, Alloc>` works correctly with the `Tiny::Alloc<T>` depicted above.


# Acknowledgments # {#acknowledgments}

Thanks to Pablo Halpern for [[P3160R1]] and [[P3160R2]].
Thanks to Ben Craig for his design of the feature-test macros and for discussion of the approach
to "freestanding `allocator`." Thanks to Gonzalo Brito and Mital Ashok for their review of this design and wording.
Thanks to Casey Carter for his review of this wording.


# Proposed wording # {#wording}

In this section, wording in <del>strikethrough</del> is to be deleted; wording in <ins>green</ins> is to be added
no matter which alternative we go with;
wording in <insarthur>yellow</insarthur> is to be added only in the "construct/destroy alternative";
wording in <inspablo>blue</inspablo> is to be added only in the "uses-allocator alternative."

## [version.syn] ## {#wording-version.syn}

Modify <a href="https://eel.is/c++draft/version.syn">[version.syn]</a> as follows,
inserting these macros into the list in the proper alphabetical positions:

<small><blockquote>
<pre>
<ins>#define __cpp_lib_allocator                    YYYYMML // also in &lt;memory></ins>
<ins>#define __cpp_lib_freestanding_allocator       YYYYMML // freestanding, also in &lt;memory></ins>
<del>#define __cpp_lib_inplace_vector               202406L // also in &lt;inplace_vector></del>
<ins>#define __cpp_lib_inplace_vector               YYYYMML // also in &lt;inplace_vector></ins>
<ins>#define __cpp_lib_freestanding_inplace_vector  YYYYMML // freestanding, also in &lt;inplace_vector></ins>
</pre>
</blockquote></small>

## [memory.syn] ## {#wording-memory.syn}

Modify <a href="https://eel.is/c++draft/memory.syn">[memory.syn]</a> as follows:

<small><blockquote>
<pre>
<i>// [default.allocator], the default allocator</i>
template&lt;class T> class allocator;                                              <ins>// partially freestanding</ins>
template&lt;class T, class U>
  constexpr bool operator==(const allocator&lt;T>&, const allocator&lt;U>&) noexcept; <ins>// freestanding</ins>
</pre>
</blockquote></small>

## [default.allocator] ## {#wording-default.allocator}

Modify <a href="https://eel.is/c++draft/default.allocator">[default.allocator]</a> as follows:

<small><blockquote>
<pre>
namespace std {
  template&lt;class T> class allocator {
  public:
    using value_type                             = T;
    using size_type                              = size_t;
    using difference_type                        = ptrdiff_t;
    using propagate_on_container_move_assignment = true_type;

    constexpr allocator() noexcept;
    constexpr allocator(const allocator&) noexcept;
    template&lt;class U> constexpr allocator(const allocator&lt;U>&) noexcept;
    constexpr ~allocator();
    constexpr allocator& operator=(const allocator&) = default;

    constexpr T* allocate(size_t n);                              <ins>// Note 1</ins>
    constexpr allocation_result&lt;T*> allocate_at_least(size_t n);  <ins>// Note 1</ins>
    constexpr void deallocate(T* p, size_t n);                    <ins>// Note 1</ins>
  };
}
</pre>

<p><ins>x․ [<i>Note</i>: For a freestanding implementation, it is implementation-defined
whether `allocate`, `allocate_at_least`, and `deallocate` are `consteval` rather than `constexpr`. —<i>end note</i>]</ins>

<p>2․ `allocator_traits<allocator<T>>::is_always_equal::value` is `true` for any `T`.
</blockquote></small>

## [container.alloc.reqmts] ## {#wording-container.alloc.reqmts}

Modify <a href="https://eel.is/c++draft/container.requirements#container.alloc.reqmts">[container.alloc.reqmts]</a> as follows:

<small><blockquote>
<p>1․ Except for `array` <del>and `inplace_vector`</del>, all of the containers defined in [containers], [stacktrace.basic],
[basic.string], and [re.results] meet the additional requirements of an <i>allocator-aware container</i>, as described below.
<p>2․ Given an allocator type `A` and given a container type `X` having a `value_type` identical to `T` and
an `allocator_type` identical to `allocator_traits<A>::rebind_alloc<T>` and given an lvalue `m` of type `A`,
a pointer `p` of type `T*`, an expression `v` that denotes an lvalue of type `T` or `const T` or an rvalue of type `const T`,
and an rvalue `rv` of type `T`, the following terms are defined.
<inspablo>If `X` is a specialization of `inplace_vector`, the terms below are defined
as if `A` were `scoped_allocator_adaptor<allocator<T>, allocator_type>`.</inspablo>
If `X` is not allocator-aware or is a specialization of `basic_string`, the terms below are defined
as if `A` were `allocator<T>` — no allocator object needs to be created
and user specializations of `allocator<T>` are not instantiated:

<p>(2.1) — `T` is <i>Cpp17DefaultInsertable into `X`</i> means that the following expression is well-formed:
<p><pre>
allocator_traits&lt;A>::construct(m, p)
</pre>
<p>(2.2) — An element of `X` is *default-inserted* if it is initialized by evaluation of the expression
<p><pre>
allocator_traits&lt;A>::construct(m, p)
</pre>
where `p` is the address of the uninitialized storage for the element allocated within `X`.
<p>(2.3) — `T` is <i>Cpp17MoveInsertable into `X`</i> means that the following expression is well-formed:
<p><pre>
allocator_traits&lt;A>::construct(m, p, rv)
</pre>
and its evaluation causes the following postcondition to hold: The value of `*p` is equivalent to the value of `rv` before the evaluation.
[*Note:* `rv` remains a valid object. Its state is unspecified. *—end note*]
<p>(2.4) — `T` is <i>Cpp17CopyInsertable into `X`</i> means that, in addition to `T` being *Cpp17MoveInsertable* into `X`, the following expression is well-formed:
<p><pre>
allocator_traits&lt;A>::construct(m, p, v)
</pre>
and its evaluation causes the following postcondition to hold: The value of `v` is unchanged and is equivalent to `*p`.
<p>(2.5) — `T` is <i>Cpp17EmplaceConstructible into `X` from `args`</i>, for zero or more arguments `args`, means that the following expression is well-formed:
<p><pre>
allocator_traits&lt;A>::construct(m, p, args)
</pre>
<p>(2.6) — `T` is <i>Cpp17Erasable from `X`</i> means that the following expression is well-formed:
<p><pre>
allocator_traits&lt;A>::destroy(m, p)
</pre>
[<i>Note:</i> A container calls `allocator_traits<A>::construct(m, p, args)` to construct an element at `p` using `args`,
with `m == get_allocator()`
<inspablo>(or `m == A(allocator<T>(), get_allocator())` in the case of `inplace_vector`)</inspablo>.
The default `construct` in `allocator` will call `::new((void*)p) T(args)`, but
specialized allocators can choose a different definition. <i>—end note</i>]

<p>[...]

<p class="p">A type `X` meets the allocator-aware container requirements if `X` meets the container requirements
and the following types, statements, and expressions are well-formed and have the specified semantics.
<p><pre>
typename X::allocator_type
</pre>
<p class="p">4․ *Result:* `A`
<p class="p">5․ *Mandates:* `allocator_type::value_type` is the same as `X::value_type`.
<p><pre>
c.get_allocator()
</pre>
<p class="p">6․ *Result:* `A`
<p class="p">7․ *Complexity:* Constant.
<p><pre>
X u;
X u = X();
</pre>
<p class="p">8․ *Preconditions:* `A` meets the *Cpp17DefaultConstructible* requirements.
<p class="p">9․ *Postconditions:* `u.empty()` returns `true`, `u.get_allocator() == A()`.
<p class="p">10․ *Complexity:* Constant.
<p><pre>
X u(m);
</pre>
<p class="p">11․ *Postconditions:* `u.empty()` returns `true`, `u.get_allocator() == m`.
<p class="p">12․ *Complexity:* Constant.
<p><pre>
X u(t, m);
</pre>
<p class="p">13․ *Preconditions:* `T` is *Cpp17CopyInsertable* into `X`.
<p class="p">14․ *Postconditions:* `u == t`, `u.get_allocator() == m`
<p class="p">15․ *Complexity:* Linear.
<p><pre>
X u(rv);
</pre>
<p class="p">16․ *Postconditions:* `u` has the same elements as `rv` had before this construction;
the value of `u.get_allocator()` is the same as the value of `rv.get_allocator()` before this construction.
<p class="p">17․ *Complexity:* Constant.
<p><pre>
X u(rv, m);
</pre>
<p class="p">18․ *Preconditions:* `T` is *Cpp17MoveInsertable* into `X`.
<p class="p">19․ *Postconditions:* `u` has the same elements, or copies of the elements, that `rv` had before this construction, `u.get_allocator() == m`.
<p class="p">20․ *Complexity:* Constant if `m == rv.get_allocator()`, otherwise linear.
<p><pre>
a = t
</pre>
<p class="p">21․ *Result:* `X&`.
<p class="p">22․ *Preconditions:* `T` is *Cpp17CopyInsertable* into `X` and *Cpp17CopyAssignable*.
<p class="p">23․ *Postconditions:* `a == t` is true.
<p class="p">24․ *Complexity:* Linear.
<p><pre>
a = rv
</pre>
<p class="p">25․ *Result:* X&.
<p class="p">26․ *Preconditions:* If `allocator_traits<allocator_type>::propagate_on_container_move_assignment::value` is `false`, `T` is *Cpp17MoveInsertable* into `X` and *Cpp17MoveAssignable*.
<p class="p">27․ *Effects:* All existing elements of `a` are either move assigned to or destroyed.
<p class="p">28․ *Postconditions:* If `a` and `rv` do not refer to the same object, `a` is equal to the value that `rv` had before this assignment.
<p class="p">29․ *Complexity:* Linear.
<p><pre>
a.swap(b)
</pre>
<p class="p">30․ *Result:* `void`
<p class="p">31․ *Effects:* Exchanges the contents of `a` and `b`.
<p class="p">32․ *Complexity:* Constant.
</blockquote></small>

## [inplace.vector.syn] ## {#wording-inplace.vector.syn}

Modify <a href="https://eel.is/c++draft/inplace.vector.syn">[inplace.vector.syn]</a> as follows:

<small><blockquote>
<p><b>24.3.7 Header `<inplace_vector>` synopsis [inplace.vector.syn]</b>
<p><pre>
<i>// mostly freestanding</i>
#include &lt;compare>              <i>// see [compare.syn]</i>
#include &lt;initializer_list>     <i>// see [initializer.list.syn]</i>
&nbsp;
namespace std {

  <inspablo><i>// exposition-only type traits</i></inspablo>
  <inspablo>template&lt;class T, class A, class... X></inspablo>
    <inspablo>constexpr bool <i>is-nothrow-ua-constructible-v</i> = <i>see below</i>; <i>// exposition only</i></inspablo>

  <i>// [inplace.vector], class template inplace_vector</i>
  template&lt;class T, size_t N<ins>, class Allocator</ins>> class inplace_vector; <i>// partially freestanding</i>
&nbsp;
  <i>// [inplace.vector.erasure], erasure</i>
  template&lt;class T, size_t N, <ins>class Allocator,</ins> class U = T>
    constexpr typename inplace_vector&lt;T, N<ins>, Allocator</ins>>::size_type
      erase(inplace_vector&lt;T, N<ins>, Allocator</ins>>& c, const U& value);
  template&lt;class T, size_t N, <ins>class Allocator,</ins> class Predicate>
    constexpr typename inplace_vector&lt;T, N<ins>, Allocator</ins>>::size_type
      erase_if(inplace_vector&lt;T, N<ins>, Allocator</ins>>& c, Predicate pred);
&nbsp;
  <ins>namespace pmr {</ins>
    <ins>template&lt;class T, size_t N></ins>
      <ins>using inplace_vector = std::inplace_vector&lt;T, N, polymorphic_allocator&lt;T>>;</ins>
  <ins>}</ins>
}
</pre>
</blockquote></small>

## [inplace.vector] ## {#wording-inplace.vector}

Modify <a href="https://eel.is/c++draft/inplace.vector">[inplace.vector]</a> as follows:

<small><blockquote>
<p><b>24.3.14 Class template `inplace_vector` [inplace.vector]</b>
<p><b>24.3.14.1 Overview [inplace.vector.overview]</b>
<p>1․ An `inplace_vector` is a contiguous container. Its capacity is fixed and its elements are stored within the `inplace_vector` object itself.
<ins>[<i>Note:</i> Although it is an allocator-aware container, `inplace_vector` uses its allocator
only to construct and destroy <inspablo>allocator-aware</inspablo> elements;
it never directly instantiates the `allocate` or `deallocate` member functions of its `allocator_type`.<i>— end note</i>]</ins>
<p>2․ An `inplace_vector` meets all of the requirements of a container ([container.reqmts]), of a reversible container ([container.rev.reqmts]),
<ins>of an allocator-aware container ([container.alloc.reqmts]),</ins>
of a contiguous container, and of a sequence container, including most of the optional sequence container requirements ([sequence.reqmts]).
The exceptions are the `push_front`, `prepend_range`, `pop_front`, and `emplace_front` member functions, which are not provided.
Descriptions are provided here only for operations on `inplace_vector` that are not described in one of these tables or for operations where there is additional semantic information.
<p>3․ For any `N`, <code>inplace_vector&lt;T, N<ins>, allocator&lt;T></ins>>::iterator</code> and <code>inplace_vector&lt;T, N<ins>, allocator&lt;T></ins>>::const_iterator</code>
meet the constexpr iterator requirements.
<p>4․ For any `N` > 0 <ins>and any `Allocator`</ins>, if `is_trivial_v<T>` is `false`,
then no <code>inplace_vector&lt;T, N<ins>, Allocator</ins>></code> member functions are usable in constant expressions.
<p>5․ Any member function of <code>inplace_vector&lt;T, N<ins>, Allocator</ins>></code> that would cause the size to exceed `N` throws an exception of type `bad_alloc`.
<p>6․ Let `IV` denote a specialization <del>of <code>inplace_vector&lt;T, N></code></del> <insarthur><code>inplace_vector&lt;T, N, allocator&lt;T>></code></insarthur>
<inspablo>inplace_vector&lt;T, N, A></inspablo>. If `N` is zero, then `IV` is <inspablo>empty.
If `N` is zero and either `is_trivial_v<A>` is `true` or `A` is a specialization of `allocator`,
then `IV` is</inspablo> both trivial and empty. Otherwise:
<ul>
  <li>(6.1) If <code>is_trivially_copy_constructible_v&lt;T> <inspablo>&& is_trivially_copy_constructible_v&lt;A></inspablo></code> is `true`
            <inspablo>and `A::select_on_container_copy_construction` does not exist</inspablo>,
            then `IV` has a trivial copy constructor.</li>
  <li>(6.2) If <code>is_trivially_move_constructible_v&lt;T> <inspablo>&& is_trivially_move_constructible_v&lt;A></inspablo></code> is `true`,
            then `IV` has a trivial move constructor.</li>
  <li>(6.3) If `is_trivially_destructible_v<T>` is `true`, then:
  <ul>
    <li>(6.3.1) <inspablo>If `is_trivially_destructible_v<A>` is `true`, then</inspablo> `IV` has a trivial destructor.</li>
    <li>(6.3.2) If <code>is_trivially_copy_constructible_v&lt;T> && is_trivially_copy_assignable_v&lt;T>
                <inspablo>&& is_trivially_copy_assignable_v&lt;A> && (allocator_traits&lt;A>::propagate_on_container_copy_assignment::value ||
                allocator_traits&lt;A>::is_always_equal::value)</inspablo></code> is `true`, then `IV` has a trivial copy assignment operator.</li>
    <li>(6.3.3) If <code>is_trivially_move_constructible_v&lt;T> && is_trivially_move_assignable_v&lt;T>
                <inspablo>&& is_trivially_move_assignable_v&lt;A> && (allocator_traits&lt;A>::propagate_on_container_move_assignment::value ||
                allocator_traits&lt;A>::is_always_equal::value)</inspablo></code> is `true`, then `IV` has a trivial move assignment operator.</li>
  </ul></li>
</ul>
<ul>
<p><inspablo>7․ The exposition-only trait <code><i>is-nothrow-ua-constructible-v</i>&lt;T, A, X...></code> is true if
<i>uses-allocator construction</i> with an allocator of type `A` and constructor arguments of types specified by `X...` ([allocator.uses.construction])
is known to be a non-throwing operation. [*Note:* This trait can be implemented by instantiating `is_nothrow_constructible_v<T, Y...>`,
where `Y...` is the set of tuple arguments deduced by `uses_allocator_construction_args`. *—end note*]</inspablo>

<p><pre>
namespace std {
  template&lt;class T, size_t N<ins>, class Allocator = allocator&lt;T></ins>>
  class inplace_vector {
  public:
    <i>// types:</i>
    using value_type             = T;
    <ins>using allocator_type         = Allocator;</ins>
    using pointer                = <del>T*</del> <insarthur>typename allocator_traits&lt;Allocator>::pointer</insarthur>;
    using const_pointer          = <del>const T*</del> <insarthur>typename allocator_traits&lt;Allocator>::const_pointer</insarthur>;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = <del>size_t</del> <insarthur><i>implementation-defined</i></insarthur>; <insarthur><i>// see [container.requirements]</i></insarthur>
    using difference_type        = <del>ptrdiff_t</del> <insarthur><i>implementation-defined</i></insarthur>; <insarthur><i>// see [container.requirements]</i></insarthur>
    using iterator               = <i>implementation-defined</i>; <i>// see [container.requirements]</i>
    using const_iterator         = <i>implementation-defined</i>; <i>// see [container.requirements]</i>
    using reverse_iterator       = std::reverse_iterator&lt;iterator>;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator>;
&nbsp;
    <i>// [inplace.vector.cons], construct/copy/destroy</i>
    constexpr inplace_vector() noexcept<ins>(noexcept(Allocator())) : inplace_vector(Allocator()) { }</ins><del>;</del>
    <ins>constexpr explicit inplace_vector(const Allocator&) noexcept;</ins>
    constexpr explicit inplace_vector(size_type n<ins>,</ins>
                                      <ins>const Allocator& = Allocator()</ins>);      // freestanding-deleted
    constexpr inplace_vector(size_type n, const T& value<ins>,</ins>
                             <ins>const Allocator& = Allocator()</ins>);               // freestanding-deleted
    template&lt;class InputIterator>
      constexpr inplace_vector(InputIterator first, InputIterator last<ins>,</ins>
                               <ins>const Allocator& = Allocator()</ins>);             // freestanding-deleted
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr inplace_vector(from_range_t, R&& rg<ins>,</ins>
                               <ins>const Allocator& = Allocator()</ins>);             // freestanding-deleted
    constexpr inplace_vector(const inplace_vector&);
    constexpr inplace_vector(inplace_vector&&)
      <del>noexcept(N == 0 || is_nothrow_move_constructible_v&lt;T>)</del>
      <inspablo>noexcept(N == 0 || <i>is-nothrow-ua-constructible-v</i>&lt;T, Allocator, T&&>)</inspablo>
      <insarthur>noexcept(<i>see below</i>)</insarthur>;
    <ins>constexpr inplace_vector(const inplace_vector& rhs, const type_identity_t&lt;Allocator>&);</ins>
    <ins>constexpr inplace_vector(inplace_vector&& rhs, const type_identity_t&lt;Allocator>&);</ins>
    constexpr inplace_vector(initializer_list&lt;T> <del>il</del><ins>,</ins>
                             <ins>const Allocator& = Allocator()</ins>);               // freestanding-deleted
    constexpr ~inplace_vector();
    constexpr inplace_vector& operator=(const inplace_vector& <del>other</del> <ins>rhs</ins>);
    constexpr inplace_vector& operator=(inplace_vector&& <del>other</del> <ins>rhs</ins>)
      <del>noexcept(N == 0 || (is_nothrow_move_assignable_v&lt;T> &&</del>
                          <del>is_nothrow_move_constructible_v&lt;T>))</del>
      <inspablo>noexcept(N == 0 || (is_nothrow_move_assignable_v&lt;T> &&</inspablo>
                          <inspablo><i>is-nothrow-ua-constructible-v</i>&lt;T, Allocator, T&&>))</inspablo>
      <insarthur>noexcept(<i>see below</i>)</insarthur>;
    constexpr inplace_vector& operator=(initializer_list&lt;T>);               // freestanding-deleted
    template&lt;class InputIterator>
      constexpr void assign(InputIterator first, InputIterator last);       // freestanding-deleted
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr void assign_range(R&& rg);                                  // freestanding-deleted
    constexpr void assign(size_type n, const T& u);                         // freestanding-deleted
    constexpr void assign(initializer_list&lt;T> il);                          // freestanding-deleted
    <ins>constexpr allocator_type get_allocator() const noexcept;</ins>
&nbsp;
    <i>// iterators</i>
    constexpr iterator               begin()         noexcept;
    constexpr const_iterator         begin()   const noexcept;
    constexpr iterator               end()           noexcept;
    constexpr const_iterator         end()     const noexcept;
    constexpr reverse_iterator       rbegin()        noexcept;
    constexpr const_reverse_iterator rbegin()  const noexcept;
    constexpr reverse_iterator       rend()          noexcept;
    constexpr const_reverse_iterator rend()    const noexcept;
&nbsp;
    constexpr const_iterator         cbegin()  const noexcept;
    constexpr const_iterator         cend()    const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend()   const noexcept;
&nbsp;
    <i>// [inplace.vector.capacity] size/capacity</i>
    constexpr bool empty() const noexcept;
    constexpr size_type size() const noexcept;
    static constexpr size_type max_size() noexcept;
    static constexpr size_type capacity() noexcept;
    constexpr void resize(size_type sz);                                    // freestanding-deleted
    constexpr void resize(size_type sz, const T& c);                        // freestanding-deleted
    static constexpr void reserve(size_type n);                             // freestanding-deleted
    static constexpr void shrink_to_fit() noexcept;
&nbsp;
    <i>// element access</i>
    constexpr reference       operator[](size_type n);
    constexpr const_reference operator[](size_type n) const;
    constexpr reference       at(size_type n);                              // freestanding-deleted
    constexpr const_reference at(size_type n) const;                        // freestanding-deleted
    constexpr reference       front();
    constexpr const_reference front() const;
    constexpr reference       back();
    constexpr const_reference back() const;
&nbsp;
    <i>// [inplace.vector.data], data access</i>
    constexpr       T* data()       noexcept;
    constexpr const T* data() const noexcept;
&nbsp;
    <i>// [inplace.vector.modifiers], modifiers</i>
    template&lt;class... Args>
      constexpr reference emplace_back(Args&&... args);                     // freestanding-deleted
    constexpr reference push_back(const T& x);                              // freestanding-deleted
    constexpr reference push_back(T&& x);                                   // freestanding-deleted
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr void append_range(R&& rg);                                  // freestanding-deleted
    constexpr void pop_back();
&nbsp;
    template&lt;class... Args>
      constexpr <del>pointer</del> <ins>T*</ins> try_emplace_back(Args&&... args);
    constexpr <del>pointer</del> <ins>T*</ins> try_push_back(const T& x);
    constexpr <del>pointer</del> <ins>T*</ins> try_push_back(T&& x);
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr ranges::borrowed_iterator_t&lt;R> try_append_range(R&& rg);
&nbsp;
    template&lt;class... Args>
      constexpr reference unchecked_emplace_back(Args&&... args);
    constexpr reference unchecked_push_back(const T& x);
    constexpr reference unchecked_push_back(T&& x);
&nbsp;
    template&lt;class... Args>
      constexpr iterator emplace(const_iterator position, Args&&... args);  // freestanding-deleted
    constexpr iterator insert(const_iterator position, const T& x);         // freestanding-deleted
    constexpr iterator insert(const_iterator position, T&& x);              // freestanding-deleted
    constexpr iterator insert(const_iterator position, size_type n,         // freestanding-deleted
                              const T& x);
    template&lt;class InputIterator>
      constexpr iterator insert(const_iterator position,                    // freestanding-deleted
                                InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr iterator insert_range(const_iterator position, R&& rg);     // freestanding-deleted
    constexpr iterator insert(const_iterator position,                      // freestanding-deleted
                              initializer_list&lt;T> il);
    constexpr iterator erase(const_iterator position);
    constexpr iterator erase(const_iterator first, const_iterator last);
    constexpr void swap(inplace_vector& x)
      <del>noexcept(N == 0 || (is_nothrow_swappable_v&lt;T> &&</del>
                          <del>is_nothrow_move_constructible_v&lt;T>))</del>
      <inspablo>noexcept(N == 0 || (is_nothrow_swappable_v&lt;T> &&</inspablo>
                          <inspablo><i>is-nothrow-ua-constructible-v</i>&lt;T, Allocator, T&&>))</inspablo>
      <insarthur>noexcept(<i>see below</i>)</insarthur>;
    constexpr void clear() noexcept;
&nbsp;
    constexpr friend bool operator==(const inplace_vector& x,
                                     const inplace_vector& y);
    constexpr friend <i>synth-three-way-result</i>&lt;T>
      operator&lt;=>(const inplace_vector& x, const inplace_vector& y);
    constexpr friend void swap(inplace_vector& x, inplace_vector& y)
      <del>noexcept(N == 0 || (is_nothrow_swappable_v&lt;T> &&</del>
                          <del>is_nothrow_move_constructible_v&lt;T>))</del>
      <ins>noexcept(noexcept(x.swap(y)))</ins>
      { x.swap(y); }
  };
};
</pre>

<p><b>24.3.14.2. Constructors [inplace.vector.cons]</b>

<p class="note"><b>DRAFTING NOTE:</b>
The use of `explicit` on `inplace_vector(n, alloc)` is consistent with the other STL containers
(e.g. <a href="https://eel.is/c++draft/vector#cons">`vector`</a>
and <a href="https://eel.is/c++draft/list#cons">`list`</a>).

<p><pre>
<ins>constexpr explicit vector(const Allocator&);</ins>
</pre>
<p class="p"><ins>x․ *Effects:* Constructs an empty `inplace_vector`, using the specified allocator.</ins>
<p class="p"><ins>x․ *Complexity:* Constant.</ins>

<p><pre>
constexpr explicit inplace_vector(size_type n<ins>, const Allocator& = Allocator()</ins>);
</pre>
<p class="p">1․ *Preconditions:* `T` is <i>`Cpp17DefaultInsertable`</i> into `inplace_vector`.
<p class="p">2․ *Effects:* Constructs an `inplace_vector` with `n` default-inserted elements<ins>, using the specified allocator</ins>.
<p class="p">3․ *Complexity:* Linear in `n`.
<p><pre>
constexpr inplace_vector(size_type n, const T& value<ins>,</ins>
                         <ins>const Allocator& = Allocator()</ins>);
</pre>
<p class="p">4․ *Preconditions:* `T` is <i>`Cpp17CopyInsertable`</i> into `inplace_vector`.
<p class="p">5․ *Effects:* Constructs an `inplace_vector` with `n` copies of `value`<ins>, using the specified allocator</ins>.
<p class="p">6․ *Complexity:* Linear in `n`.
<p><pre>
template&lt;class InputIterator>
  constexpr inplace_vector(InputIterator first, InputIterator last<ins>,</ins>
                           <ins>const Allocator& = Allocator()</ins>);
</pre>
<p class="p">7․ *Effects:* Constructs an `inplace_vector` equal to the range `[first, last)`<ins>, using the specified allocator</ins>.
<p class="p">8․ *Complexity:* Linear in `distance(first, last)`.
<p><pre>
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr inplace_vector(from_range_t, R&& rg<ins>, const Allocator& = Allocator()</ins>);
</pre>
<p class="p">9․ *Effects:* Constructs an `inplace_vector` object with the elements of the range `rg`<ins>, using the specified allocator</ins>.
<p class="p">10․ *Complexity:* Linear in `ranges::distance(rg)`.

<p><pre>
<ins>constexpr inplace_vector(inplace_vector&&)</ins>
  <inspablo>noexcept(N == 0 || <i>is-nothrow-ua-constructible-v</i>&lt;T, Allocator, T&&>);</inspablo>
  <insarthur>noexcept(<i>see below</i>);</insarthur>
</pre>
<p class="p"><ins>11․ *Preconditions:* `T` is *Cpp17MoveInsertable* into `inplace_vector`.</ins>
<p class="p"><ins>12․ *Complexity:* Linear.</ins>
<p class="p"><insarthur>13․ *Remarks:* When `allocator_type` is `allocator<value_type>`, the exception specification is equivalent to:</insarthur>
<div style="margin: 0.5em 2em;"><pre>
<insarthur>is_nothrow_move_constructible_v&lt;value_type></insarthur>
</pre></div>
<insarthur>Otherwise, the exception specification is unspecified.</insarthur>

<p><pre>
<insarthur>constexpr inplace_vector& operator=(const inplace_vector& rhs);</insarthur>
</pre>
<p class="p"><insarthur>14․ *Preconditions:* `allocator_traits<allocator_type>::propagate_on_container_copy_assignment::value` is `false`
or `rhs.get_allocator() == this->get_allocator()`. `T` is *Cpp17CopyInsertable* into `inplace_vector` and *Cpp17CopyAssignable*.</insarthur>

<p><pre>
<ins>constexpr inplace_vector& operator=(inplace_vector&& rhs)</ins>
  <inspablo>noexcept(N == 0 || (is_nothrow_move_assignable_v&lt;T> &&</inspablo>
                      <inspablo><i>is-nothrow-ua-constructible-v</i>&lt;T, Allocator, T&&>));</inspablo>
  <insarthur>noexcept(<i>see below</i>);</insarthur>
</pre>
<p class="p"><insarthur>15․ *Preconditions:* `allocator_traits<allocator_type>::propagate_on_container_move_assignment::value` is `false`
or `rhs.get_allocator() == this->get_allocator()`. `T` is *Cpp17MoveInsertable* into `inplace_vector` and *Cpp17MoveAssignable*.</insarthur>
<p class="p"><ins>16․ *Complexity:* Linear.</ins>
<p class="p"><insarthur>17․ *Remarks:* When `allocator_type` is `allocator<value_type>`, the exception specification is equivalent to:</insarthur>
<div style="margin: 0.5em 2em;"><pre>
<insarthur>is_nothrow_move_assignable_v&lt;value_type> && is_nothrow_move_constructible_v&lt;value_type></insarthur>
</pre></div>
<insarthur>Otherwise, the exception specification is unspecified.</insarthur>

<p class="note"><b>DRAFTING NOTE:</b>
`type_identity_t` below is consistent with the other STL containers.
CTAD needs it in order to handle this snippet: `std::pmr::inplace_vector<int,10> v; auto w = inplace_vector(v, &mr);`

<p><pre>
<ins>constexpr inplace_vector(const inplace_vector& rhs, const type_identity_t&lt;Allocator>&);</ins>
</pre>
<p class="p"><ins>1․ *Effects:* Constructs an `inplace_vector` with the elements of `rhs`, using the specified allocator.</ins>
<p class="p"><ins>2․ *Complexity:* Linear in `rhs.size()`.</ins>
<p><pre>
<ins>constexpr inplace_vector(inplace_vector&& rhs, const type_identity_t&lt;Allocator>&);</ins>
</pre>
<p class="p"><ins>3․ *Effects:* Constructs an `inplace_vector` with the elements that `rhs` had before the construction,
using the specified allocator.</ins>
<p class="p"><ins>4․ *Complexity:* Linear in `rhs.size()`.</ins>

<p><b>24.3.14.3 Size and capacity [inplace.vector.capacity]</b>
<p><pre>
static constexpr size_type capacity() noexcept;
static constexpr size_type max_size() noexcept;
</pre>
<p class="p">1․ *Returns:* `N`.
<p><pre>
constexpr void resize(size_type sz);
</pre>
<p class="p">2․ *Preconditions:* `T` is <i>`Cpp17DefaultInsertable`</i> into `inplace_vector`.
<p class="p">3․ *Effects:* If `sz < size()`, erases the last `size() - sz` elements from the sequence. Otherwise, appends `sz - size()` default-inserted elements to the sequence.
<p class="p">4․ *Remarks:* If an exception is thrown, there are no effects on `*this`.
<p><pre>
constexpr void resize(size_type sz, const T& c);
</pre>
<p class="p">5․ *Preconditions:* `T` is <i>`Cpp17CopyInsertable`</i> into `inplace_vector`.
<p class="p">6․ *Effects:* If `sz < size()`, erases the last `size() - sz` elements from the sequence. Otherwise, appends `sz - size()` copies of `c` to the sequence.
<p class="p">7․ *Remarks:* If an exception is thrown, there are no effects on `*this`.

<p><b>24.3.14.4 Data [inplace.vector.data]</b>
<p><pre>
constexpr       T* data()       noexcept;
constexpr const T* data() const noexcept;
</pre>
<p class="p">1․ *Returns:* A pointer such that [`data()`, `data() + size()`) is a valid range.
For a non-empty `inplace_vector`, <nobr>`data() == addressof(front())`</nobr> is `true`.
<p class="p">2․ *Complexity:* Constant time.

<p><b>24.3.14.5 Modifiers [inplace.vector.modifiers]</b>
<p><pre>
constexpr iterator insert(const_iterator position, const T& x);
constexpr iterator insert(const_iterator position, T&& x);
constexpr iterator insert(const_iterator position, size_type n, const T& x);
template&lt;class InputIterator>
  constexpr iterator insert(const_iterator position, InputIterator first, InputIterator last);
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr iterator insert_range(const_iterator position, R&& rg);
constexpr iterator insert(const_iterator position, initializer_list&lt;T> il);
&nbsp;
template&lt;class... Args>
  constexpr iterator emplace(const_iterator position, Args&&... args);
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr void append_range(R&& rg);
</pre>
<p class="p">1․ Let `n` be the value of `size()` before this call for the `append_range` overload, and `distance(begin, position)` otherwise.
<p class="p">2․ *Complexity:* Linear in the number of elements inserted plus the distance to the end of the vector.
<p class="p">3․ *Remarks:* If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or
move assignment operator of `T` or by any `InputIterator` operation, there are no effects.
Otherwise, if an exception is thrown, then `size()` ≥ `n` and elements in the range `begin()` + [`0`, `n`) are not modified.
<p><pre>
constexpr reference push_back(const T& x);
constexpr reference push_back(T&& x);
template&lt;class... Args>
  constexpr reference emplace_back(Args&&... args);
</pre>
<p class="p">4․ *Returns:* `back()`.
<p class="p">5․ *Throws:* `bad_alloc` or any exception thrown by the initialization of the inserted element.
<p class="p">6․ *Complexity:* Constant.
<p class="p">7․ *Remarks:* If an exception is thrown, there are no effects on `*this`.
<p><pre>
template&lt;class... Args>
  constexpr <del>pointer</del> <ins>T*</ins> try_emplace_back(Args&&... args);
constexpr <del>pointer</del> <ins>T*</ins> try_push_back(const T& x);
constexpr <del>pointer</del> <ins>T*</ins> try_push_back(T&& x);
</pre>
<p class="p"> 8․ Let `vals` denote a pack:
<ul>
  <li>(8.1) `std::forward<Args>(args)...` for the first overload,</li>
  <li>(8.2) `x` for the second overload,</li>
  <li>(8.3) `std::move(x)` for the third overload.</li>
</ul>
<p class="p">9․ *Preconditions:* `value_type` is <i>`Cpp17EmplaceConstructible`</i> into `inplace_vector` from `vals...`.
<p class="p">10․ *Effects:* If `size() < capacity()` is `true`, appends an object of type `T` direct-non-list-initialized with `vals...`. Otherwise, there are no effects.
<p class="p">11․ *Returns:* `nullptr` if `size() == capacity()` is `true`, otherwise `addressof(back())`.
<p class="p">12․ *Throws:* Nothing unless an exception is thrown by the initialization of the inserted element.
<p class="p">13․ *Complexity:* Constant.
<p class="p">14․ *Remarks:* If an exception is thrown, there are no effects on `*this`.
<p><pre>
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr ranges::borrowed_iterator_t&lt;R> try_append_range(R&& rg);
</pre>
<p class="p">15․ *Preconditions:* `value_type` is <i>`Cpp17EmplaceConstructible`</i> into `inplace_vector` from `*ranges::begin(rg)`.
<p class="p">16․ *Effects:* Appends copies of initial elements in `rg` before `end()`, until all elements are inserted or `size() == capacity() is true`.
Each iterator in the range `rg` is dereferenced at most once.
<p class="p">17․ *Returns:* An iterator pointing to the first element of `rg` that was not inserted into `*this`, or `ranges::end(rg)` if no such element exists.
<p class="p">18․ *Complexity:* Linear in the number of elements inserted.
<p class="p">19․ *Remarks:* Let `n` be the value of `size()` prior to this call. If an exception is thrown after the insertion of `k` elements, then `size()` equals `n+k`,
elements in the range `begin()` + [`0`, `n`) are not modified, and elements in the range `begin()` + [`n`, `n+k`) correspond to the inserted elements.
<p><pre>
template&lt;class... Args>
  constexpr reference unchecked_emplace_back(Args&&... args);
</pre>
<p class="p">20․ *Preconditions:* `size() < capacity()` is `true`.
<p class="p">21․ *Effects:* Equivalent to: `return *try_emplace_back(std::forward<Args>(args)...);`
<p><pre>
constexpr reference unchecked_push_back(const T& x);
constexpr reference unchecked_push_back(T&& x);
</pre>
<p class="p">22․ *Preconditions:* `size() < capacity()` is `true`.
<p class="p">23․ *Effects:* Equivalent to: `return *try_push_back(std::forward<decltype(x)>(x));`
<p><pre>
static constexpr void reserve(size_type n);
</pre>
<p class="p">24․ *Effects:* None.
<p class="p">25․ *Throws:* `bad_alloc` if `n > capacity()` is `true`.
<p><pre>
static constexpr void shrink_to_fit() noexcept;
</pre>
<p class="p">26․ *Effects:* None.
<p><pre>
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_back();
</pre>
<p class="p">27․ *Effects:* Invalidates iterators and references at or after the point of the erase.
<p class="p">28․ *Throws:* Nothing unless an exception is thrown by the assignment operator or move assignment operator of `T`.
<p class="p">29․ *Complexity:* The destructor of `T` is called the number of times equal to the number of the elements erased,
but the assignment operator of `T` is called the number of times equal to the number of elements after the erased elements.

<p><pre>
<inspablo>constexpr void swap(inplace_vector& x)</inspablo>
  <inspablo>noexcept(N == 0 || (is_nothrow_swappable_v&lt;T> &&</inspablo>
                      <inspablo><i>is-nothrow-ua-constructible-v</i>&lt;T, Allocator, T&&>));</inspablo>
</pre>
<p class="p"><inspablo>30․ *Effects:* If `allocator_traits<A>::propagate_on_container_swap::value && !allocator_traits<A>::always_compare_equal::value` is `true`,
swap the allocators of `*this` and `x`.
Then, swap the first `m` elements of `*this` and `x`, where `m` is the smaller of `this->size()` and `x.size()`.
Then, move-insert the remaining elements from the longer `inplace_vector` to the end of the shorter one,
then erase those elements from the longer `inplace_vector`.</inspablo>
<p class="p"><inspablo>32․ *Complexity:* Linear.</inspablo>

<p><pre>
<insarthur>constexpr void swap(inplace_vector& x) noexcept(<i>see below</i>);</insarthur>
</pre>
<p class="p"><insarthur>30․ *Preconditions:* Let *M* be `min(size(), x.size())`.
For each non-negative integer *n* &lt; *M*, `(*this)[n]` is swappable with ([swappable.requirements]) `x[n]`.
If `allocator_traits<allocator_type>::propagate_on_container_swap::value` is `true`, then
`allocator_type` meets the <i>`Cpp17Swappable`</i> requirements and `get_allocator() == x.get_allocator()`.</insarthur>
<p class="p"><insarthur>31․ *Effects:* Exchanges the contents of `*this` and `x`.</insarthur>
<p class="p"><insarthur>32․ *Complexity:* Linear.</insarthur>
<p class="p"><insarthur>33․ *Remarks:* When `allocator_type` is `allocator<value_type>`, the exception specification is equivalent to:</insarthur>
<div style="margin: 0.5em 2em;"><pre>
<insarthur>is_nothrow_swappable_v&lt;value_type> && is_nothrow_move_constructible_v&lt;value_type></insarthur>
</pre></div>
<insarthur>Otherwise, the exception specification is unspecified.</insarthur>

<p class="note"><b>DRAFTING NOTE:</b>
The exception specification above is modeled on <a href="https://eel.is/c++draft/optional.swap#5">[optional.swap]/5</a>.

<p><b>24.3.14.6 Erasure [inplace.vector.erasure]</b>
<p><pre>
template&lt;class T, size_t N, <ins>class Allocator,</ins> class U = T>
  constexpr <del>size_t</del> <ins>typename inplace_vector&lt;T, N, Allocator>::size_type</ins>
    erase(inplace_vector&lt;T, N<ins>, Allocator</ins>>& c, const U& value);
</pre>
<p class="p">1․ *Effects:* Equivalent to:
<div style="margin: 0.5em 2em;"><pre>
    auto it = remove(c.begin(), c.end(), value);
    auto r = distance(it, c.end());
    c.erase(it, c.end());
    return r;
</pre></div>
<p><pre>
template&lt;class T, size_t N, <ins>class Allocator,</ins> class Predicate>
  constexpr <del>size_t</del> <ins>typename inplace_vector&lt;T, N, Allocator>::size_type</ins>
    erase_if(inplace_vector&lt;T, N<ins>, Allocator</ins>>& c, Predicate pred);
</pre>
<p class="p">2․ *Effects:* Equivalent to:
<div style="margin: 0.5em 2em;"><pre>
    auto it = remove_if(c.begin(), c.end(), pred);
    auto r = distance(it, c.end());
    c.erase(it, c.end());
    return r;
</pre></div>
</blockquote>
</small>

<pre class=biblio>
{
  "LWG4151": {
    "title": "Precondition of inplace_vector::swap",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/LWG/issue4151",
    "date": "September 2024"
  },
  "Mital": {
    "title": "[libc++] Implement std::inplace_vector<T, N>",
    "authors": [
      "Mital Ashok"
    ],
    "href": "https://github.com/llvm/llvm-project/pull/105981",
    "date": "August 2024"
  },
  "P0843": {
    "title": "inplace_vector",
    "authors": [
      "Gonzalo Brito Gadeschi", "Timur Doumler", "Nevin Liber", "David Sankel"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0843r14.html",
    "date": "June 2024"
  },
  "P1642": {
    "title": "Freestanding Library: Easy [utilities], [ranges], and [iterators]",
    "authors": [
      "Ben Craig"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1642r11.html",
    "date": "July 2022"
  },
  "P2198": {
    "title": "Freestanding Feature-Test Macros and Implementation-Defined Extensions",
    "authors": [
      "Ben Craig"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2198r7.html",
    "date": "December 2022"
  },
  "P3160R1": {
    "title": "Allocator-aware inplace_vector",
    "authors": [
      "Pablo Halpern"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3160r1.html",
    "date": "March 2024"
  },
  "P3160R2": {
    "title": "Allocator-aware inplace_vector",
    "authors": [
      "Pablo Halpern"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3160r2.html",
    "date": "October 2024"
  },
  "P3295": {
    "title": "Freestanding constexpr containers and constexpr exception types",
    "authors": [
      "Ben Craig"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3295r0.html",
    "date": "May 2024"
  },
  "QuuxplusoneSG14": {
    "title": "Quuxplusone/SG14: Allocator-aware in-place vector (future > C++20)",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://github.com/Quuxplusone/SG14?tab=readme-ov-file#allocator-aware-in-place-vector-future--c20",
    "date": "August 2024"
  }
}
</pre>
