<pre class='metadata'>
Title: flat_map/flat_set omnibus
Shortname: D2767
Revision: 2
!Draft Revision: 20
Audience: LEWG, LWG
Status: D
Group: WG21
URL:
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  Issues and resolutions in C++23 <code>flat_set</code>
  and <code>flat_map</code>, based on libc++'s implementation experience.
Date: 2023-12-09
</pre>

<style>
hilite  {background-color: #FFFF00; font-weight: bold;}
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
src  {background-color: #FFDDFF; text-decoration: line-through;}
dst  {background-color: #CCFFEE; text-decoration: underline;}
</style>

# Changelog # {#changelog}

- R2 (post-LEWG-telecon, pre-Tokyo 2024):

    - Vastly reorder, and separate the sections into "LWG business" and "LEWG business."
          Combine all the subsections that would be resolved at once by [[#monolith]].

    - Replace many snippets with Tony Tables for clarity.

    - Wording nits.

    - Add [[#zero-initialization]].

- R1 (post-Varna 2023):

    - LWG approved §3 as editorial.

    - LWG reviewed §4,5,6,7. Update those sections' rationales and proposed wordings.

    - Split [[#heterogeneous-insert-multiset]] and [[#deceptive]] out of their respective sections.

- R0 (pre-Varna 2023):

    - Initial draft.

# Introduction # {#intro}

Arthur has implemented all of [[P0429]] `flat_map` and [[P1222]] `flat_set` for libc++.
As he implemented them, he and Louis Dionne collected issues that libc++ would like to see resolved
by LWG. This paper presents all of these issues together in one place, along with Arthur's proposed
solutions for each one.

Some of the proposed solutions are LEWG-level design changes. Contrariwise, some of the issues collected
here don't have "solutions" at all, but are recorded merely For Your Information (for other vendors/implementors)
to document the design choices libc++ has made.

# LWG business # {#lwg-business}

## Editorial (merged in R0) ## {#editorial-cons-alloc}

P2767R0's editorial change was reviewed by LWG in Varna (2023-06-16) and approved by a vote of 7–0–1
([minutes](https://wiki.edg.com/bin/view/Wg21varna/P2767-20230616-LM));
it is submitted as <a href="https://github.com/cplusplus/draft/pull/6274">#6274</a>.
Jonathan Wakely is on the hook to approve and merge it.

Once this editorial business is merged, the rest of the diffs presented in this paper will
apply cleanly.

## Accidentally explicit constructor ## {#explicit-oops}

STL style is that multi-argument constructors should be non-`explicit`; see [[P1163]].
This change is non-editorial, but non-controversial. LWG reviewed R0's wording in
Varna and expressed a preferred direction.
Zhihao Yuan found the precedent for "Let `comp` be..." in
<a href="https://eel.is/c++draft/list.ops#20">`list::unique`</a>.

### Wording ### {#wording-explicit-oops}

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.multiset.cons], constructors
    flat_multiset() : flat_multiset(key_compare()) { }

    explicit flat_multiset(const key_compare& comp)
      : c(), compare(comp) { }

    <del>explicit flat_multiset(container_type cont, const key_compare& comp = key_compare());</del>
    <ins>explicit flat_multiset(container_type cont);</ins>
    <ins>flat_multiset(container_type cont, const key_compare& comp);</ins>

    flat_multiset(sorted_equivalent_t, container_type cont,
                  const key_compare& comp = key_compare())
      : c(std::move(cont)), compare(comp) { }
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.cons">[flat.multiset.cons]</a> as follows:

<small><blockquote>
<pre>
<del>explicit flat_multiset(container_type cont, const key_compare& comp = key_compare());</del>
<ins>explicit flat_multiset(container_type cont);</ins>
<ins>flat_multiset(container_type cont, const key_compare& comp);</ins>
</pre>

<ins>x․ Let `comp` be `key_compare()` for the first overload.</ins>

1․ Effects: Initializes <i>`c`</i> with `std::move(cont)` and <i>`compare`</i> with `comp`,
and sorts the range [`begin()`, `end()`) with respect to <i>`compare`</i>.

2․ Complexity: Linear in <i>N</i> if `cont` is already sorted with respect to <i>`compare`</i>
and otherwise <i>N</i> log <i>N</i>, where <i>N</i> is the value of `cont.size()` before this call.
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.set.cons], constructors
    flat_set() : flat_set(key_compare()) { }

    explicit flat_set(const key_compare& comp)
      : c(), compare(comp) { }

    <del>explicit flat_set(container_type cont, const key_compare& comp = key_compare());</del>
    <ins>explicit flat_set(container_type cont);</ins>
    <ins>flat_set(container_type cont, const key_compare& comp);</ins>

    flat_set(sorted_unique_t, container_type cont, const key_compare& comp = key_compare())
      : c(std::move(cont)), compare(comp) { }
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.cons">[flat.set.cons]</a> as follows:

<small><blockquote>
<pre>
<del>explicit flat_set(container_type cont, const key_compare& comp = key_compare());</del>
<ins>explicit flat_set(container_type cont);</ins>
<ins>flat_set(container_type cont, const key_compare& comp);</ins>
</pre>

<ins>x․ Let `comp` be `key_compare()` for the first overload.</ins>

1․ Effects: Initializes <i>`c`</i> with `std::move(cont)` and <i>`compare`</i> with `comp`,
sorts the range [`begin()`, `end()`) with respect to <i>`compare`</i>,
and finally erases all but the first element from each group of consecutive equivalent elements.

2․ Complexity: Linear in <i>N</i> if `cont` is already sorted with respect to <i>`compare`</i>
and otherwise <i>N</i> log <i>N</i>, where <i>N</i> is the value of `cont.size()` before this call.
</blockquote></small>

## Add move semantics to `flat_set::insert_range` ## {#set-insert-range}

```c++
    std::flat_set<std::string> fs1;
    std::vector<std::string> v1 = {"hello", "world"};
    fs1.insert_range(std::views::as_rvalue(v1));
      // Before: Copies the strings.
      // After: Moves the strings.

    std::flat_set<std::unique_ptr<int>> fs2;
    std::vector<std::unique_ptr<int>> v2;
    fs2.insert_range(std::views::as_rvalue(v2));
      // Before: Ill-formed.
      // After: Moves the unique_ptrs.
```

Compare the current wording for
<a href="https://eel.is/c++draft/flat.set#lib:insert_range,flat_set">`flat_set.insert_range`</a> (added by
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf">P1222</a>) versus
<a href="https://eel.is/c++draft/priority.queue#lib:push_range,priority_queue">`priority_queue.push_range`</a>
(added in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1206r5.pdf">P1206R5</a> and tweaked in R6).
`priority_queue`'s wording is not only more robustly Rangified, but also more performant.

Arthur doesn't know why P1206R5/R6 chose to pass `forward<R>(rg)` to `append_range` but plain old lvalue `rg`
to `ranges::copy`; it seems like it should have forwarded in both places or else forwarded in neither place.
On 2023-07-17, Casey Carter concurred: "Let's assume it's just a mistake and change both places consistently."

### Wording ### {#wording-set-insert-range}

Change <a href="https://eel.is/c++draft/flat.set#modifiers-10">[flat.set.modifiers]/10</a> as follows:

<small><blockquote>
<pre>
template&lt;<i>container-compatible-range</i>&lt;value_type> R>
  void insert_range(R&& rg);
</pre>

10․ Effects: <del>Adds elements to <i>`c`</i> as if by:</del>
<pre>
<del>for (const auto& e : rg) {</del>
  <del>c.insert(c.end(), e);</del>
<del>}</del>
</pre>
<ins>Adds the elements of `rg` to <i>`c`</i> via `c.append_range(rg)`
if that is a valid expression, or `ranges::copy(rg, back_inserter(c))` otherwise.</ins> Then,
sorts the range of newly inserted elements with respect to <i>`compare`</i>;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases all but the first element from each group of consecutive equivalent elements.

11․ Complexity: <i>N</i> + <i>M</i> log <i>M</i>, where <i>N</i> is `size()` before the operation and <i>M</i> is `ranges::distance(rg)`.

12․ Remarks: Since this operation performs an in-place merge, it may allocate memory.
</blockquote></small>

Add a new section to <a href="https://eel.is/c++draft/flat.multiset#modifiers">[flat.multiset.modifiers]</a>
explaining the semantics of `flat_multiset::insert_range`.

<small><blockquote>
<pre>
<ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
  <ins>void insert_range(R&& rg);</ins>
</pre>

<p><ins>x․ Effects: Adds the elements of `rg` to <i>`c`</i> via `c.append_range(rg)`
if that is a valid expression, or `ranges::copy(rg, back_inserter(c))` otherwise.
Then, sorts the range of newly inserted elements with respect to <i>`compare`</i>, and
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range.

<p><ins>x․ Complexity: <i>N</i> + <i>M</i> log <i>M</i>, where <i>N</i> is `size()` before the operation and <i>M</i> is `ranges::distance(rg)`.

<p><ins>x․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</ins>
</blockquote></small>


## (LWG4000) Add move semantics to `flat_map::insert_range` ## {#map-insert-range}

Note: This resolves [[LWG4000]].

`flat_map`'s `insert_range` has the same issue as `flat_set`'s, at least on paper.

```c++
    std::flat_map<int, std::unique_ptr<int>> fs2;
    std::vector<std::pair<int, std::unique_ptr<int>>> v2;
    fs2.insert_range(std::views::as_rvalue(v2));
      // Before: Ill-formed.
      // After: Moves the unique_ptrs.
```

The `insert_range` method is constrained on <i>`container-compatible-range`</i>`<value_type>`,
i.e. `convertible_to<range_reference_t<R>, value_type>`.
But in fact the current spec's algorithm never attempts to convert `range_reference_t<R>` to `value_type`.
Instead, it implicitly requires that `range_reference_t<R>::first` be convertible to `key_type`
and `range_reference_t<R>::second` be convertible to `mapped_type`. If `range_reference_t<R>` is
something without `first` and `second` members, the current spec doesn't work at all.

```c++
    std::pair<int, int> p1 = {1,2};
    std::reference_wrapper<std::pair<int, int>> a[] = { p1 };
    std::flat_map<int, int> fm;
    fm.insert_range(a);
      // Before: Ill-formed: reference_wrapper has no .first member
      // After: OK
```

The wording below implicitly converts `range_reference_t<R>` to `value_type e`, and then
move-constructs from `e.first` and `e.second` into the map's containers. Note that
`e.first` and `e.second` are never reference types, so `std::move` is correct.

LWG in Varna briefly feinted in the direction of trying to metaprogram away the extra move-construct
(e.g. by changing the lambda's parameter type to something like
`conditional_t<same_as<decay_t<range_reference_t<R>>, value_type>, range_reference_t<R>, value_type>`),
but I felt strongly that the chance of getting that correct on the first try was near-nil.
Besides, we realized that we were trying to save O(M) move operations along a codepath
whose very next step was to do an O(M log M) sort and an O(N) `inplace_merge`.

If any library vendor actually wants to try that kind of metaprogramming,
they are welcome to do so under the As-If Rule. libc++ will not do it.

### Wording ### {#wording-map-insert-range}

Note: This section was updated in R1 following LWG's preferred direction.
I don't recall why LWG preferred `ranges::for_each` over the ranged-for-loop shown in [[LWG4000]]'s P/R.

We don't need to touch [flat.multimap.modifiers]; in fact it does not currently exist;
because of <a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview]/4</a>:

<small><blockquote>
4․ Except as otherwise noted, operations on `flat_multimap` are equivalent to those of `flat_map`,
except that `flat_multimap` operations do not remove or replace elements with equal keys.
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.map.modifiers#12">[flat.map.modifiers]/12</a> as follows:

<small><blockquote>
<pre>
template&lt;<i>container-compatible-range</i>&lt;value_type> R>
  void insert_range(R&& rg);
</pre>

12․ Effects: Adds elements to `c` as if by:
<pre>
<del>for (const auto& e : rg)</del>
<ins>ranges::for_each(rg, [&c](value_type e)</ins> {
  c.keys.insert(c.keys.end(), <ins>std::move(</ins>e.first<ins>)</ins>);
  c.values.insert(c.values.end(), <ins>std::move(</ins>e.second<ins>)</ins>);
}<ins>);</ins>
</pre>
Then, sorts the range of newly inserted elements with respect to `value_comp()`;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases the duplicate elements as if by:
<pre>
auto zv = views::zip(c.keys, c.values);
auto it = ranges::unique(zv, key_equiv(compare)).begin();
auto dist = distance(zv.begin(), it);
c.keys.erase(c.keys.begin() + dist, c.keys.end());
c.values.erase(c.values.begin() + dist, c.values.end());
</pre>

13․ Complexity: N + M log M, where N is `size()` before the operation and M is `ranges::distance(rg)`.

14․ Remarks: Since this operation performs an in-place merge, it may allocate memory.
</blockquote></small>


## `insert` is more primitive than `emplace` ## {#insert-emplace}

```c++
    std::pmr::set_default_resource(std::pmr::null_memory_resource());
    std::pmr::monotonic_buffer_resource mr(1'000'000);

    auto fm = PmrFlatSet<std::pmr::string>(&mr);
    std::pmr::string ps("too long to fit in the small string buffer", &mr);
    fm.insert(ps);
      // Before: runtime abort, cannot default-allocate t
      // After: OK
```

Whenever we insert or emplace into a set or multiset, we have two tasks:

- Construct the new `value_type` object.

- Find the correct insertion point for the new object.

`emplace` receives a bag of constructor arguments, so it has no choice: it must do
"construct `t`, find insertion point for `t`, move-insert `t` into the container" exactly as specified above.

But `insert` receives an already-constructed `value_type`! It shouldn't discard that valuable information;
it should use the given `value_type` to find the appropriate insertion point, and then construct the new object
directly in place. There is no reason to construct `t` on the stack first.

The current definition of `emplace` is not expressed in terms of `insert(value_type(...))`. P2767R0 proposed
not to change it, simply to keep the diff small. But LWG in Varna asked to make that simplification.
libc++'s implementation already implements `emplace` in terms of `insert`, so there doesn't seem to be
any sneaky subtlety in that area; we can just do it. So P2767R1 does it.

### "Initializes" phrasing ### {#emplace-phrasing}

The proposed wording below brings <a href="https://eel.is/c++draft/flat.map.modifiers#2">[flat.map.modifiers]/2</a>
into line with e.g. <a href="https://eel.is/c++draft/variant#ctor-21">[variant.ctor]/21</a> and
<a href="https://eel.is/c++draft/forward.list#modifiers-23">[forward.list.modifiers]/23</a>:

<small><blockquote>
2․ Effects: <del>Initializes</del> <ins>Direct-non-list-initializes</ins> an object `t` of type `pair<key_type, mapped_type>` with `std::forward<Args>(args)...`;
if the map already contains an element whose key is equivalent to `t.first`, `*this` is unchanged. [...]
</blockquote></small>

P2767R0 asked whether LWG had appetite to invent something less jargony. No, LWG did not.

### Inconsistent `emplace` constraints ### {#emplace-constraint}

The usual pattern in [containers] is that `x.emplace(args...)`
has a precondition (<a href="https://eel.is/c++draft/containers#sequence.reqmts-21">[sequence.reqmts]</a>,
<a href="https://eel.is/c++draft/containers#associative.reqmts.general-48">[associative.reqmts.general]</a>)
but no Constraints element. That is, `emplace` is not SFINAE-friendly. And it has only the one overload,
so it doesn't need a constraint for purposes of overload resolution.

No Constraints on `emplace`:
<a href="https://eel.is/c++draft/deque.modifiers#lib:deque,emplace">`deque`</a>,
<a href="https://eel.is/c++draft/list.modifiers">`list`</a>,
<a href="https://eel.is/c++draft/vector.modifiers">`vector`</a>,
<a href="https://eel.is/c++draft/sequence.reqmts#lib:emplace,containers">containers</a>,
<a href="https://eel.is/c++draft/associative.reqmts.general#lib:emplace,ordered_associative_containers">associative containers</a>,
<a href="https://eel.is/c++draft/unord.req.general#lib:emplace,unordered_associative_containers">unordered containers</a>,
<a href="https://eel.is/c++draft/priqueue.members#lib:priority_queue,emplace">`priority_queue`</a>,
<a href="https://eel.is/c++draft/optional.assign#lib:emplace,optional">`optional`</a>.

Constraints on `emplace`:
<a href="https://eel.is/c++draft/flat.map.modifiers#lib:flat_map,emplace">`flat_map`</a>,
<a href="https://eel.is/c++draft/flat.multiset.modifiers#lib:flat_multiset,emplace">`flat_multiset`</a>,
<a href="https://eel.is/c++draft/any.modifiers#lib:emplace,any">`any`</a>,
<a href="https://eel.is/c++draft/expected.object.assign#lib:emplace,expected">`expected`</a>,
<a href="https://eel.is/c++draft/variant.mod#lib:emplace,variant">`variant`</a>.

I believe a Constraints element was accidentally copy-pasted from the spec of <a href="https://eel.is/c++draft/flat.map.modifiers#4">`flat_map::insert(P&&)`</a> —
which *does* need the constraint because it's part of `insert`'s large overload set — to `flat_map::emplace`,
and then from there to `flat_multiset::emplace`. The constraint is already (correctly) absent
from `flat_set::emplace`.

Therefore, the proposed wording for this section simply deletes those Constraints elements.

With the Constraints elements gone, and `emplace(x...)` always implemented as `insert(value_type(x...))`,
there is no longer any need for an English description of `emplace`. It is now specified by code only.

The rewrite of `emplace_hint(pos, x...)` into `insert(pos, value_type(x...))` is frightening, because of
the very large overload set of `insert`; but I think it's safe: it should always be a perfect match for
`insert(const_iterator, value_type&&)` and never a viable match for any other overload at all.

### Ambiguous `insert(first, last)` ### {#insert-ambiguity}

```c++
struct Address {
  const char *p_ = nullptr;
  Address(auto p) : p_((const char*)&*p) {}
  auto operator<=>(const Address&) const = default;
};
std::flat_set<Address> m, n;
m.insert(n.begin(), n.end());
  // Before: Ambiguous with insert(pos, K&&)
  // After: Unambiguously insert(first, last)
```

We simply need to copy the usual wording "Constraints: For the second overload, `is_convertible_v<K&&, const_iterator>` and
`is_convertible_v<K&&, iterator>` are both `false`" from [[P2363]] or <a href="https://eel.is/c++draft/flat.map.modifiers#19.4">`flat_map::try_emplace`</a>.

This is a problem only for the sets, where `const_iterator` can be convertible to `value_type`.
It's not a problem for the maps, so they don't need to change.

### `flat_multiset::emplace` by rotation? ### {#multiset-emplace}

```c++
    template<class T, class C = std::less<T>>
    using PmrFlatMultiset = std::flat_multiset<T, C, std::pmr::vector<T>>;
    auto fms = PmrFlatMultiset<std::pmr::string>(&mr);
    fms.emplace("hello world");
```

The C++23 status quo is that we "initialize an object `t` of type `value_type`" with `"hello world"`,
and then insert it into `c`. The initial construction of `t` uses the wrong allocator.

P2767R1 proposes to simplify the specification of `flat_multiset::emplace` in terms of `flat_multiset::insert`;
but does not propose to change this behavior. We'll still be constructing a temporary with the wrong
allocator.

Tim Song has observed that we could instead specify `flat_multiset::emplace` like this
(following `inplace_vector`'s precedent):

<small><blockquote>
<pre>
template&lt;class... Args> iterator emplace(Args&&... args);
</pre>
<p><del>1․ Constraints: `is_constructible_v<value_type, Args...>` is `true`.</del>
<p>2․ Effects: <del>First, initializes an object `t` of type `value_type` with `std::forward<Args>(args)...`,
then inserts `t`</del> <ins>Adds an element to <i>`c`</i></ins> as if by:
<pre>
<del>auto it = ranges::upper_bound(c, t, compare);</del>
<del>c.insert(it, std::move(t));</del>
<ins>c.emplace_back(std::forward&lt;Args>(args)...);</ins>
<ins>auto n = upper_bound(c.begin(), c.end() - 1, c.back(), compare) - c.begin();</ins>
<ins>ranges::rotate(c.begin() + n, c.end() - 1, c.end());</ins>
</pre>
<p>3․ Returns: An iterator that points to the inserted element.
</blockquote></small>

This would ensure that the new object never gets constructed with the wrong allocator.
However, this benefit comes with at least three downsides:

* A user-provided random-access container (e.g. one based on a
    <a href="https://en.wikipedia.org/wiki/Skip_list">skip list</a>) might have a way to
    insert in the middle of the container without moving any other elements at all, or moving only O(1)
    elements instead of O(n) elements.

* Even for `vector` it seems more expensive to rotate the elements than to
    do the right-shift that `c.insert` would do. Is the cost worth the benefit?

* The proposal applies to `flat_multiset::emplace` but not to `flat_set::emplace`
    (because we don't want to insert a duplicate and then have to erase it again)
    and not to `flat_multimap::emplace` (because we don't have a container of `pair`s
    to emplace into, in that case).

We could mitigate the first two downsides by leaving `emplace` alone, and doing the
rotate-based version only for `emplace_hint`. There, if the caller gives us an accurate hint,
we won't need to rotate anything at all; and when we do rotate, it can only be because
the caller gave us an inaccurate hint (i.e. it's "their fault"). But this would still
suffer the third downside (i.e. inconsistency), and it would be more complicated to teach.
Arthur thinks that it is best not to use `rotate`.


### Wording ### {#wording-insert-emplace}

Note: This section was updated in R1 following LWG’s preferred direction.
We no longer add `insert(K&&)` to `flat_multiset`; that wording has moved to [[#heterogeneous-insert-multiset]].

We don't need to touch [flat.multimap.modifiers]; in fact it does not currently exist;
because of <a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview]/4</a>:

<small><blockquote>
4․ Except as otherwise noted, operations on `flat_multimap` are equivalent to those of `flat_map`, 
except that `flat_multimap` operations do not remove or replace elements with equal keys.
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.map.modifiers], modifiers
    template&lt;class... Args> pair&lt;iterator, bool> emplace(Args&&... args)<del>;</del>
      <ins>{ return insert(value_type(std::forward&lt;Args>(args)...)); }</ins>
    template&lt;class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args)<del>;</del>
        <ins>{ return insert(position, value_type(std::forward&lt;Args>(args)...)); }</ins>

    pair&lt;iterator, bool> insert(const value_type& x)<ins>;</ins>
      <del>{ return emplace(x); }</del>
    pair&lt;iterator, bool> insert(value_type&& x)<ins>;</ins>
      <del>{ return emplace(std::move(x)); }</del>
    iterator insert(const_iterator position, const value_type& x)<ins>;</ins>
      <del>{ return emplace_hint(position, x); }</del>
    iterator insert(const_iterator position, value_type&& x)<ins>;</ins>
      <del>{ return emplace_hint(position, std::move(x)); }</del>

    template&lt;class P> pair&lt;iterator, bool> insert(P&& x);
    template&lt;class P>
      iterator insert(const_iterator position, P&&);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.map.modifiers">[flat.map.modifiers]</a> as follows:

<small><blockquote>
<pre>
<del>template&lt;class... Args> pair&lt;iterator, bool> emplace(Args&&... args);</del>
</pre>
<del>1․ Constraints: `is_constructible_v<pair<key_type, mapped_type>, Args...>` is `true`.</del>

<p><del>2․ Effects: Initializes an object `t` of type `pair<key_type, mapped_type>` with `std::forward<Args>(args)...`;
if the map already contains an element whose key is equivalent to `t.first`, `*this` is unchanged. Otherwise, equivalent to:</del>
<pre>
<del>auto key_it = ranges::upper_bound(c.keys, t.first, compare);</del>
<del>auto value_it = c.values.begin() + distance(c.keys.begin(), key_it);</del>
<del>c.keys.insert(key_it, std::move(t.first));</del>
<del>c.values.insert(value_it, std::move(t.second));</del>
</pre>

<del>3․ Returns: The `bool` component of the returned pair is `true` if and only if the insertion took place,
and the iterator component of the pair points to the element with key equivalent to `t.first`.</del>

<pre>
<ins>pair&lt;iterator, bool> insert(const value_type& x);</ins>
<ins>pair&lt;iterator, bool> insert(value_type&& x);</ins>
</pre>
<ins>x․ Effects: If the map already contains an element whose key is equivalent to `x.first`,
`*this` and `x` are unchanged. Otherwise, equivalent to:</ins>
<pre>
<ins>auto key_it = ranges::upper_bound(c.keys, x.first, compare);</ins>
<ins>auto value_it = c.values.begin() + distance(c.keys.begin(), key_it);</ins>
<ins>c.keys.insert(key_it, x.first);</ins>
<ins>c.values.insert(value_it, x.second);</ins>
</pre>
<ins>for the first overload and</ins>
<pre>
<ins>auto key_it = ranges::upper_bound(c.keys, x.first, compare);</ins>
<ins>auto value_it = c.values.begin() + distance(c.keys.begin(), key_it);</ins>
<ins>c.keys.insert(key_it, std::move(x.first));</ins>
<ins>c.values.insert(value_it, std::move(x.second));</ins>
</pre>
<ins>for the second overload.</ins>

<p><ins>3․ Returns: The `bool` component of the returned pair is `true` if and only if the insertion took place,
and the iterator component of the pair points to the element with key equivalent to `x.first`.</ins>

<pre>
template&lt;class P> pair&lt;iterator, bool> insert(P&& x);
template&lt;class P> iterator insert(const_iterator position, P&& x);
</pre>
4․ Constraints: `is_constructible_v<pair<key_type, mapped_type>, P>` is `true`. <ins>For
the second overload, `is_convertible_v<P&&, const_iterator>` and
`is_convertible_v<P&&, iterator>` are both `false`.</ins>

5․ Effects: The first form is equivalent to `return emplace(std::forward<P>(x));`.
The second form is equivalent to `return emplace_hint(position, std::forward<P>(x));`.
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:

<small><blockquote>
<pre>
    // modifiers
    template&lt;class... Args> iterator emplace(Args&&... args)<del>;</del>
      <ins>{ return insert(value_type(std::forward&lt;Args>(args)...)); }</ins>
    template&lt;class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args)<del>;</del>
        <ins>{ return insert(position, value_type(std::forward&lt;Args>(args)...)); }</ins>

    iterator insert(const value_type& x)<ins>;</ins>
      <del>{ return emplace(x); }</del>
    iterator insert(value_type&& x)<ins>;</ins>
      <del>{ return emplace(std::move(x)); }</del>
    iterator insert(const_iterator position, const value_type& x)<ins>;</ins>
      <del>{ return emplace_hint(position, x); }</del>
    iterator insert(const_iterator position, value_type&& x)<ins>;</ins>
      <del>{ return emplace_hint(position, std::move(x)); }</del>

    template&lt;class P> iterator insert(P&& x);
    template&lt;class P>
      iterator insert(const_iterator position, P&&);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.multiset.modifiers], modifiers
    template&lt;class... Args> iterator emplace(Args&&... args)<del>;</del>
      <ins>{ return insert(value_type(std::forward&lt;Args>(args)...)); }</ins>
    template&lt;class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args)<del>;</del>
        <ins>{ return insert(position, value_type(std::forward&lt;Args>(args)...)); }</ins>

    iterator insert(const value_type& x)<ins>;</ins>
      <del>{ return emplace(x); }</del>
    iterator insert(value_type&& x)<ins>;</ins>
      <del>{ return emplace(std::move(x)); }</del>
    iterator insert(const_iterator position, const value_type& x)<ins>;</ins>
      <del>{ return emplace_hint(position, x); }</del>
    iterator insert(const_iterator position, value_type&& x)<ins>;</ins>
      <del>{ return emplace_hint(position, std::move(x)); }</del>
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:

<small><blockquote>
<pre>
<del>template&lt;class... Args> iterator emplace(Args&&... args);</del>
</pre>
<p><del>1․ Constraints: `is_constructible_v<value_type, Args...>` is `true`.</del>
<p><del>2․ Effects: First, initializes an object `t` of type `value_type` with `std::forward<Args>(args)...`,
then inserts `t` as if by:</del>
<pre>
<del>auto it = ranges::upper_bound(c, t, compare);</del>
<del>c.insert(it, std::move(t));</del>
</pre>
<p><del>3․ Returns: An iterator that points to the inserted element.</del>

<pre>
<ins>iterator insert(const value_type& x);</ins>
<ins>iterator insert(value_type&& x);</ins>
</pre>
<ins>x․ Effects: Inserts a new element as if by:</ins>
<pre>
<ins>auto it = ranges::upper_bound(c, x, compare);</ins>
<ins>c.insert(it, x);</ins>
</pre>
<ins>for the first overload or</ins>
<pre>
<ins>auto it = ranges::upper_bound(c, x, compare);</ins>
<ins>c.insert(it, std::move(x));</ins>
</pre>
<ins>for the second overload.</ins>

<p><ins>x․ Returns: An iterator that points to the inserted element.</ins>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.set.modifiers], modifiers
    template&lt;class... Args> pair&lt;iterator, bool> emplace(Args&&... args)<del>;</del>
      <ins>{ return insert(value_type(std::forward&lt;Args>(args)...)); }</ins>
    template&lt;class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args)<del>;</del>
        <ins>{ return insert(position, value_type(std::forward&lt;Args>(args)...)); }</ins>

    pair&lt;iterator, bool> insert(const value_type& x)<ins>;</ins>
      <del>{ return emplace(x); }</del>
    pair&lt;iterator, bool> insert(value_type&& x)<ins>;</ins>
      <del>{ return emplace(std::move(x)); }</del>
    template&lt;class K> pair&lt;iterator, bool> insert(K&& x);
    iterator insert(const_iterator position, const value_type& x)<ins>;</ins>
      <del>{ return emplace_hint(position, x); }</del>
    iterator insert(const_iterator position, value_type&& x)<ins>;</ins>
      <del>{ return emplace_hint(position, std::move(x)); }</del>
    template&lt;class K> iterator insert(const_iterator hint, K&& x);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.modifiers">[flat.set.modifiers]</a> as follows:

<small><blockquote>
<pre>
<ins>pair&lt;iterator, bool> insert(const value_type& x);</ins>
<ins>pair&lt;iterator, bool> insert(value_type&& x);</ins>
</pre>
<ins>x․ Effects: If the set already contains an element equivalent to `x`, `*this` and `x` are unchanged.
Otherwise, inserts a new element as if by:</ins>
<pre>
<ins>auto it = ranges::upper_bound(c, x, compare);</ins>
<ins>c.insert(it, x);</ins>
</pre>
<ins>for the first overload or</ins>
<pre>
<ins>auto it = ranges::upper_bound(c, x, compare);</ins>
<ins>c.insert(it, std::move(x));</ins>
</pre>
<ins>for the second overload.</ins>

<p><ins>x․ Returns: The `bool` component of the returned pair is `true` if and only if the insertion took place.
The returned iterator points to the element equivalent to `x`.</ins>

<pre>
template&lt;class K> pair&lt;iterator, bool> insert(K&& x);
template&lt;class K> iterator insert(const_iterator hint, K&& x);
</pre>
1․ Constraints: The *qualified-id* `Compare::is_transparent` is valid and denotes a type. `is_constructible_v<value_type, K>` is `true`. <ins>For
the second overload, `is_convertible_v<K&&, const_iterator>` and `is_convertible_v<K&&, iterator>` are both `false`.</ins>

2․ Preconditions: The conversion from `x` into `value_type` constructs an object `u`<del>,</del> for which `find(x) == find(u)` is `true`.

3․ Effects: If the set already contains an element equivalent to `x`, `*this` and `x` are unchanged. Otherwise, inserts a new element as if
by `emplace(std::forward<K>(x))`.

4․ Returns: In the first overload, the `bool` component of the returned pair is `true` if and only if the insertion took place.
The returned iterator points to the element <del>whose key is</del> equivalent to `x`.
</blockquote></small>


## Inconsistent handling of redundancy in [flat.multiset] and [flat.multimap] ## {#redundancy}

See <a href="https://github.com/cplusplus/draft/pull/6246#issuecomment-1539789693">#6246</a>.

<a href="https://eel.is/c++draft/flat.multiset#overview-4">[flat.multiset.overview/4]</a> uses
the same boilerplate as `vector`, `set`, `flat_set`, and `flat_map`:

<small><blockquote>
Descriptions are provided here only for operations on `flat_multiset` that are not described
in one of the general sections or for operations where there is additional semantic information.
</blockquote></small>

<a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview/4]</a> uses
different boilerplate:

<small><blockquote>
Except as otherwise noted, operations on `flat_multimap` are equivalent to those of `flat_map`,
except that `flat_multimap` operations do not remove or replace elements with equal keys.

[Example 1: `flat_multimap` constructors and emplace do not erase non-unique elements after sorting them. —end example]
</blockquote></small>

That's a little handwavey: It doesn't bother to explain that
`flat_multimap::insert(sorted_equivalent_t, initializer_list)` is "equivalent to"
`flat_map::insert(sorted_unique_t, initializer_list)`. It doesn't bother to explain how
the `iterator` return value of `flat_multimap::insert(value_type&&)` is derived from the
`pair<iterator, bool>` return value of `flat_map::insert(value_type&&)`.  

But it does make the spec a lot shorter! Should we apply the same technique to [flat.multiset]
that we already apply to [flat.multimap]? I haven't written wording for this yet, but can do so
if LWG is interested.

Vice versa, should we tweak [flat.multimap]'s wording to address the two "doesn't bother" points above?
Should we tweak it to say "equivalent keys" or "duplicate keys" instead of "equal keys"?

## Special member functions ## {#special-members}

<a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> currently does not declare
any special member functions. This implies that they are defaulted, which implicitly specifies
their constexprness, noexceptness, and triviality.

All three C++20 container adaptors (e.g. <a href="https://eel.is/c++draft/priqueue.overview">[priqueue.overview]</a>)
follow that approach, too.

All eight associative and/or unordered containers (e.g. <a href="https://eel.is/c++draft/set.overview">[set.overview]</a>)
explicitly provide signatures for all five special members, including destructor, like this:

<small><blockquote>
<pre>
    set(const set& x);
    set(set&& x);
[...]
    ~set();
    set& operator=(const set& x);
    set& operator=(set&& x)
      noexcept(allocator_traits&lt;Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable_v&lt;Compare>);
</pre>
</blockquote></small>

Should `flat_set`'s spec hew more closely to `std::set`'s or `priority_queue`'s?
We tentatively think `set`'s is the better model, so that the vendor would be free to
make the special members non-defaulted. Vendors are still permitted to strengthen the
noexceptness and/or triviality of declared functions; for example, both libc++ and libstdc++
make `set(set&&)` conditionally noexcept.

```c++
    using V = std::inplace_vector<int, 100>;
    static_assert(std::is_trivially_destructible_v<V>);
    using M = std::flat_set<int, std::less<int>, V>;
    static_assert(std::is_trivially_destructible_v<M>);
      // Before: Mandatory.
      // After: Permitted but not mandatory.
```

### Moving from the comparator ### {#move-from-comparator}

As shown above, the associative and unordered containers give their move-assignment operator
a noexcept-spec that strongly implies it must move-from the comparator, never copy it.
This particularly affects libstdc++, where `set(set&&)` will copy a stateful comparator
(e.g. `std::function`) instead of moving-from it, but `set::operator=(set&&)` must move
the comparator, leaving the source object in a "radioactive" state.

This whole area is the subject of [[LWG2227]] "Stateful comparison objects in associative containers,"
and is certainly beyond the scope of this paper P2767.

```c++
  struct TestLess : std::less<> {
    // make this too big to fit in the small buffer
    char pad_[1000];
  };
  using C = std::function<bool(int,int)>;
  std::set<int, C> s({1,2,3}, C(TestLess()));
  assert(s.key_comp() != nullptr);
  auto t = std::move(s);
  assert(s.key_comp() != nullptr);
    // libstdc++: Succeeds
    // libc++: Fails
  s.clear();
  s.insert({1,2});
    // libstdc++: OK
    // libc++: Throws std::bad_function_call
  t = std::move(s);
  s.insert({1,2});
    // Everyone: Throws std::bad_function_call
```

If we user-declare `flat_set::operator=(flat_set&&)`,
we must decide whether to give it a similar noexcept-spec.

### Partial wording ### {#wording-special-members}

For example, change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:

<small><blockquote><pre>
    // [flat.map.cons], constructors
    flat_map() : flat_map(key_compare()) { }

    <ins>flat_map(const flat_map&);</ins>
    <ins>flat_map(flat_map&&);</ins>
    <ins>flat_map& operator=(const flat_multimap&);</ins>
    <ins>flat_map& operator=(flat_multimap&&)</ins>
      <ins>noexcept(is_nothrow_move_assignable_v&lt;KeyContainer> &&</ins>
               <ins>is_nothrow_move_assignable_v&lt;MappedContainer> &&</ins>
               <ins>is_nothrow_move_assignable_v&lt;Compare>);)</ins>
    <ins>~flat_map();</ins>

    flat_map(key_container_type key_cont, mapped_container_type mapped_cont,
             const key_compare& comp = key_compare());
</pre></blockquote></small>


# LEWG business # {#lewg-business}

## `iterator` and `const_iterator` ## {#iterator-types}

`flat_set::iterator` and `flat_set::const_iterator` are presented as if they could be
two different types. This is consistent with how we do it in `set` and `unordered_set`.
But in practice, all three vendors make `set::iterator` and `set::const_iterator` the
same type. We should consider refactoring the spec of `set`, `unordered_set`, and `flat_set`
all at once to *mandate* that these iterator types be the same type, the same way we
already do for <a href="https://eel.is/c++draft/string.view#footnote-207">`basic_string_view`</a>
and (since C++23 introduced `std::const_iterator`) <a href="https://eel.is/c++draft/span.overview">`span<const T>`</a>.

This would allow us to remove a lot of redundant overloads from the specification,
e.g. we don't need both `iterator find(value_type)` and `const_iterator find(value_type) const`
if those are the same iterator type. Vendors can already do this removal in their implementations
if they choose to. This is merely a question of our getting to do it in the paper specification too,
under the banner of "standardizing existing practice."

## Zero-initialization of containers ## {#zero-initialization}

Jean-Philippe Boivin points out that the flat containers currently specify their constructors
as value-initializing, rather than default-initializing, the `keys` and `values` containers.
This is extremely expensive for in-place containers such as
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0843r9.html">P0843</a> `std::inplace_vector` (proposed for C++26).
A reduced example looks like this ([Godbolt](https://godbolt.org/z/aWoYxEfve)):

```c++
    struct flat_set {
        using key_compare = std::less<int>;
        using container_type = std::inplace_vector<int, 1024>;

        flat_set() : flat_set(key_compare()) { }
        explicit flat_set(const key_compare& comp)
          : c_(), compare_(comp) { }
    private:
        [[no_unique_address]] key_compare compare_;
        container_type c_;
    };
```

The value-initialization of `c_` zeroes the memory footprint of `c_` and then calls `inplace_vector`'s
default constructor (which initializes `size_` but is otherwise trivial). This involves a 4096-byte `memset`.
On the other hand, if `flat_set`'s constructors were defined as

```c++
        flat_set() = default;
        explicit flat_set(const key_compare& comp)
          : compare_(comp) { }
```

then there would be no 4096-byte `memset`. This would make `flat_set` more suitable for embedded programming,
where every cycle counts.

We don't care about the cost of zero-initializing the comparator, since
comparators are usually empty types, or at least small.

### Wording ### {#wording-zero-initialization}

Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:

<small><blockquote>
[...]
<pre>
    // [flat.map.cons], constructors
    <del>flat_map() : flat_map(key_compare()) { }</del>
    <ins>flat_map() = default;</ins>
    explicit flat_map(const key_compare& comp)
      : <del>c(),</del> compare(comp) { }
    flat_map(key_container_type key_cont, mapped_container_type mapped_cont,
             const key_compare& comp = key_compare());
    flat_map(sorted_unique_t, key_container_type key_cont, mapped_container_type mapped_cont,
             const key_compare& comp = key_compare());
    template&lt;class InputIterator>
      flat_map(InputIterator first, InputIterator last, const key_compare& comp = key_compare())
        : <del>c(),</del> compare(comp) { insert(first, last); }
    template&lt;class InputIterator>
      flat_map(sorted_unique_t s, InputIterator first, InputIterator last,
               const key_compare& comp = key_compare())
        : <del>c(),</del> compare(comp) { insert(s, first, last); }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_map(from_range_t fr, R&& rg)
        : flat_map(fr, std::forward&lt;R>(rg), key_compare()) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_map(from_range_t, R&& rg, const key_compare& comp)
        : flat_map(comp) { insert_range(std::forward&lt;R>(rg)); }
</pre>
[...]
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:

<small><blockquote>
[...]
<pre>
    // [flat.multimap.cons], constructors
    <del>flat_multimap() : flat_multimap(key_compare()) { }</del>
    <ins>flat_multimap() = default;</ins>
    explicit flat_multimap(const key_compare& comp)
      : <del>c(),</del> compare(comp) { }
    flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,
                  const key_compare& comp = key_compare());
    flat_multimap(sorted_equivalent_t, key_container_type key_cont, mapped_container_type mapped_cont,
                  const key_compare& comp = key_compare());
    template&lt;class InputIterator>
      flat_multimap(InputIterator first, InputIterator last, const key_compare& comp = key_compare())
        : <del>c(),</del> compare(comp) { insert(first, last); }
    template&lt;class InputIterator>
      flat_multimap(sorted_equivalent_t s, InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : <del>c(),</del> compare(comp) { insert(s, first, last); }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_multimap(from_range_t fr, R&& rg)
        : flat_multimap(fr, std::forward&lt;R>(rg), key_compare()) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_multimap(from_range_t, R&& rg, const key_compare& comp)
        : flat_multimap(comp) { insert_range(std::forward&lt;R>(rg)); }
</pre>
[...]
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
[...]
<pre>
    // [flat.multiset.cons], constructors
    <del>flat_multiset() : flat_multiset(key_compare()) { }</del>
    <ins>flat_multiset() = default;</ins>
    explicit flat_multiset(const key_compare& comp)
      : <del>c(),</del> compare(comp) { }
    explicit flat_multiset(container_type cont, const key_compare& comp = key_compare());
    flat_multiset(sorted_equivalent_t, container_type cont,
                  const key_compare& comp = key_compare())
      : <i>c</i>(std::move(cont)), <i>compare</i>(comp) { }
    template&lt;class InputIterator>
      flat_multiset(InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : <del><i>c</i>(),</del> <i>compare</i>(comp)
        { insert(first, last); }
    template&lt;class InputIterator>
      flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : <i>c</i>(first, last), <i>compare</i>(comp) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_multiset(from_range_t fr, R&& rg)
        : flat_multiset(fr, std::forward&lt;R>(rg), key_compare()) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_multiset(from_range_t, R&& rg, const key_compare& comp)
        : flat_multiset(comp)
        { insert_range(std::forward&lt;R>(rg)); }
</pre>
[...]
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:

<small><blockquote>
[...]
<pre>
    // [flat.set.cons], constructors
    <del>flat_set() : flat_set(key_compare()) { }</del>
    <ins>flat_set() = default;</ins>
    explicit flat_set(const key_compare& comp)
      : <del>c(),</del> compare(comp) { }
    explicit flat_set(container_type cont, const key_compare& comp = key_compare());
    flat_set(sorted_unique_t, container_type cont,
             const key_compare& comp = key_compare())
      : <i>c</i>(std::move(cont)), <i>compare</i>(comp) { }
    template&lt;class InputIterator>
      flat_set(InputIterator first, InputIterator last,
               const key_compare& comp = key_compare())
        : <del><i>c</i>(),</del> <i>compare</i>(comp)
        { insert(first, last); }
    template&lt;class InputIterator>
      flat_set(sorted_unique_t, InputIterator first, InputIterator last,
               const key_compare& comp = key_compare())
        : <i>c</i>(first, last), <i>compare</i>(comp) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_set(from_range_t fr, R&& rg)
        : flat_set(fr, std::forward&lt;R>(rg), key_compare()) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_set(from_range_t, R&& rg, const key_compare& comp)
        : flat_set(comp)
        { insert_range(std::forward&lt;R>(rg)); }
</pre>
[...]
</blockquote></small>


## Add `flat_set::keys()` ## {#keys-method}

`flat_map` and `flat_multimap` provide `keys()` and `values()` getters:

<small><blockquote><pre>
    <i>// observers</i>
    key_compare key_comp() const;
    value_compare value_comp() const;
    const key_container_type& keys() const noexcept      { return c.keys; }
    const mapped_container_type& values() const noexcept { return c.values; }
</pre></blockquote></small>

`flat_set` and `flat_multiset` do not:

<small><blockquote><pre>
    <i>// observers</i>
    key_compare key_comp() const;
    value_compare value_comp() const;
</pre></blockquote></small>

libc++ has found that `.keys` and `.values` are helpful in unit tests.
The `.extract` method is a poor replacement, because it is mutating.
For a const `flat_set`, there's literally no way to get at the container
and query its properties, such as capacity, allocator, or even size.

Therefore we suggest adding `flat_{multi,}set.keys()`.

Notice that `flat_map`'s `.values()` getter returns a container of `mapped_type`,
not a container of `value_type`. `flat_set` doesn't have a `mapped_type`;
therefore it shouldn't have `.values()` either.

<small><table>
<tr><th>Before</th><th>After</th></tr>
<tr><td><pre>
auto m = std::flat_map({{1,2},{3,4},{5,6}}, A(1));
assert(m.keys().get_allocator() == A(1));
assert(m.values().get_allocator() == A(1));
  // OK, m is not modified
auto s = std::flat_set({1,2,3}, A(1));
assert(std::move(s).extract().get_allocator() == A(1));
  // awkward, s is modified
const auto cs = std::flat_set<int>();
assert(???);
  // no way to check cs's capacity
</pre></td><td><pre>
auto m = std::flat_map({{1,2},{3,4},{5,6}}, A(1));
assert(m.keys().get_allocator() == A(1));
assert(m.values().get_allocator() == A(1));
  // OK, m is not modified
auto s = std::flat_set({1,2,3}, A(1));
assert(s.keys().get_allocator() == A(1));
  // OK, s is not modified
const auto cs = std::flat_set<int>();
assert(cs.keys().capacity() == 0);
  // OK, cs can be tested
</pre></td></tr>
</table></small>

### Wording ### {#wording-keys-method}

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
<pre>
    <i>// observers</i>
    key_compare key_comp() const;
    value_compare value_comp() const;

    <ins>const container_type& keys() const noexcept { return <i>c</i>; }</ins>
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:

<small><blockquote>
<pre>
    <i>// observers</i>
    key_compare key_comp() const;
    value_compare value_comp() const;

    <ins>const container_type& keys() const noexcept { return <i>c</i>; }</ins>
</pre>
</blockquote></small>


## Efficient `flat_multiset::insert(K&&)` ## {#heterogeneous-insert-multiset}

<small><table>
<tr><th>Before</th><th>After</th></tr>
<tr><td><pre>
std::set&lt;BigNum, std::less&lt;>> s;
s.insert(42);
  // Find the insertion point via less(int, BigNum)
  // Maybe construct BigNum(int) in-place in a new node
  // Maybe attach the node to the tree
std::flat_set&lt;BigNum, std::less&lt;>> s;
s.insert(42);
  // Find the insertion point via less(int, BigNum)
  // Maybe construct BigNum(int) in-place in the vector
</pre></td><td><pre>
std::set&lt;BigNum, std::less&lt;>> s;
s.insert(42);
  // Find the insertion point via less(int, BigNum)
  // Maybe construct BigNum(int) in-place in a new node
  // Maybe attach the node to the tree
std::flat_set&lt;BigNum, std::less&lt;>> s;
s.insert(42);
  // Find the insertion point via less(int, BigNum)
  // Maybe construct BigNum(int) in-place in the vector
</pre></td></tr>
<tr><td><pre>
std::multiset&lt;BigNum, std::less&lt;>> s;
s.insert(42);
  // Construct BigNum(int) in-place in a new node
  // Find the insertion point via less(BigNum, BigNum)
  // Attach the node to the tree
std::flat_multiset&lt;BigNum, std::less&lt;>> s;
s.insert(42);
  // <del> Construct BigNum(int) in the argument slot</del>
  // Find the insertion point via less(<del>BigNum</del> , BigNum)
  // <del> Move-construct BigNum(BigNum&&) into the vector</del>
</pre></td><td><pre>
std::multiset&lt;BigNum, std::less&lt;>> s;
s.insert(42);
  // Construct BigNum(int) in-place in a new node
  // Find the insertion point via less(BigNum, BigNum)
  // Attach the node to the tree
std::flat_multiset&lt;BigNum, std::less&lt;>> s;
s.insert(42);
  // Find the insertion point via less(<ins>int</ins> , BigNum)
  // <ins> Construct BigNum(int) in-place in the vector</ins>
</pre></td></tr>
<tr><td colspan="2"><pre>
template&lt;class T, class C>
using PmrFlatMultiset = std::flat_multiset&lt;T, C, std::pmr::vector&lt;T>>;
std::pmr::monotonic_buffer_resource mr(1'000'000);
std::pmr::set_default_resource(std::pmr::null_memory_resource());
char cstr[] = "too long to fit in the small string buffer";
</pre></td></tr>
<tr><td><pre>
std::pmr::multiset&lt;std::pmr::string, std::less&lt;>> s(&mr);
s.emplace(cstr);
  // Construct string(cstr, &mr) in-place in a new node
  // Find the insertion point via less(string, string)
  // Attach the node to the tree
s.insert(cstr);
  // Construct string(cstr, &mr) in-place in a new node
  // Find the insertion point via less(string, string)
  // Attach the node to the tree
</pre></td><td><pre>
std::pmr::multiset&lt;std::pmr::string, std::less&lt;>> s(&mr);
s.emplace(cstr);
  // Construct string(cstr, &mr) in-place in a new node
  // Find the insertion point via less(string, string)
  // Attach the node to the tree
s.insert(cstr);
  // Construct string(cstr, &mr) in-place in a new node
  // Find the insertion point via less(string, string)
  // Attach the node to the tree
</pre></td></tr>
<tr><td><pre>
PmrFlatMultiset&lt;std::pmr::string, std::less&lt;>> fs(&mr);
fs.emplace(cstr);
  // Construct string(cstr) in a temporary t
  //   (throws bad_alloc)
  // Find the insertion point via less(string, string)
  // Move-construct string(std::move(t)) into the vector
fs.insert(cstr);
  // <del> Construct string(cstr) in the argument slot</del>
  //   <del> (throws bad_alloc)</del>
  // Find the insertion point via less(<del>string</del> , string)
  // <del> Move-construct string(string&&) into the vector</del>
</pre></td><td><pre>
PmrFlatMultiset&lt;std::pmr::string, std::less&lt;>> fs(&mr);
fs.emplace(cstr);
  // Construct string(cstr) in a temporary t
  //   (throws bad_alloc)
  // Find the insertion point via less(string, string)
  // Move-construct string(std::move(t)) into the vector
fs.insert(cstr);
  // Find the insertion point via less(<ins>char*</ins> , string)
  // <ins> Construct string(cstr, &mr) into the vector</ins>
  //   <ins> (OK, does not throw)</ins>
</pre></td></tr>
</table></small>

[[P2363]] <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html#ins">explains</a>
why they chose not to add `insert(K&&)` to the node-based `std::multiset`:

> Adding heterogeneous `insert` overload makes no sense for associative containers with non-unique keys (`std::multimap`, `std::multiset`,
> `std::unordered_multimap` and `std::unordered_multiset`) because the insertion will be successful in any case and the key would be always
> constructed. All additional overheads introduced by `insert` can be mitigated by using `emplace`.

That last sentence is false for the vector-based `flat_multiset`: We *cannot* mitigate overheads by using `emplace`, because
`emplace` must first construct `t` outside the vector using the default allocator (which may throw `bad_alloc`). `emplace`
cannot use the proper allocator, because `flat_multiset` is (deliberately) not allocator-aware.
Therefore we propose to add `flat_multiset::insert(K&&)`.

### Wording ### {#wording-heterogeneous-insert-multiset}

Note: This diff assumes [[#wording-insert-emplace]] as the starting point.

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.multiset.modifiers], modifiers
    template&lt;class... Args> iterator emplace(Args&&... args)
      { return insert(value_type(std::forward&lt;Args>(args)...)); }
    template&lt;class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args)
        { return insert(position, value_type(std::forward&lt;Args>(args)...)); }

    iterator insert(const value_type& x);
    iterator insert(value_type&& x);
    <ins>template&lt;class K> iterator insert(K&& x);</ins>
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    <ins>template&lt;class K> iterator insert(const_iterator hint, K&& x);</ins>
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:

<small><blockquote>
<pre>
iterator insert(const value_type& x);
iterator insert(value_type&& x);
</pre>
x․ Effects: Inserts a new element as if by:
<pre>
auto it = ranges::upper_bound(c, x, compare);
c.insert(it, x);
</pre>
for the first overload or
<pre>
auto it = ranges::upper_bound(c, x, compare);
c.insert(it, std::move(x));
</pre>
for the second overload.

<p>x․ Returns: An iterator that points to the inserted element.

<pre>
<ins>template&lt;class K> iterator insert(K&& x);</ins>
</pre>

<ins>x․ Constraints: The *qualified-id* `Compare::is_transparent` is valid and denotes a type.
`is_constructible_v<value_type, K>` is `true`.
For the second overload, `is_convertible_v<K&&, const_iterator>` and `is_convertible_v<K&&, iterator>` are both `false`.</ins>

<p><ins>x․ Preconditions: The conversion from `x` into `value_type` constructs an object `u` for which `upper_bound(x) == upper_bound(u)` is `true`.</ins>

<p><ins>x․ Effects: Inserts a new element as if by</ins>
<pre>
<ins>auto it = ranges::upper_bound(<i>c</i>, x, <i>compare</i>);</ins>
<ins>c.emplace(it, std::forward&lt;K>(x));</ins>
</pre>

<p><ins>x․ Returns: An iterator that points to the inserted element.</ins>
</blockquote></small>


## Complexity of `equal_range` ## {#complexity-equal-range}

<a href="https://eel.is/c++draft/associative.reqmts.general#171">[associative.reqmts.general]/171 and /174</a>
define the complexity of `b.equal_range(k)` and `a_tran.equal_range(ke)` as "Logarithmic."
This means that we have the following required complexities, for both `foo` and `flat_foo`:

```c++
    std::set<std::string> s;
    std::multiset<std::string> ms;
    std::set<std::string, std::less<>> st;
    std::multiset<std::string, std::less<>> mst;

    s.equal_range("abc"s);
      // 171: lower_bound, lower_bound+1; (1 + lg N) operations total
    ms.equal_range("abc"s);
      // 171: lower_bound, upper_bound; (2 lg N) operations total
    st.equal_range("abc");
      // 174: lower_bound, upper_bound; (2 lg N) operations total
    mst.equal_range("abc");
      // 174: lower_bound, upper_bound; (2 lg N) operations total
```

For `st.equal_range`, <a href="https://eel.is/c++draft/associative.reqmts.general#7.22">[associative.reqmts.general]/7.22</a>
forces us to consider the possibility that `std::less<>::operator()(key_type, const char*)`
is a less granular equivalence relation than `std::less<>::operator()(key_type, key_type)`; i.e., even though
this is a `set`, it might still contain "duplicates" from the point of view of the heterogeneous comparator.
It would be efficient in practice to find `lower_bound("abc")` in lg N time and then step forward linearly
until we find an element not equal to `"abc"` — the expected number of duplicates for the average real-world workload
is small. But the number of duplicates *theoretically* could be O(N); so we're not allowed to do this
(at least not without an arbitrary cap, e.g. if we don't find the end of the range in 10 probes then fall back
to `upper_bound` — bookkeeping which would again unnecessarily slow down the average case).

Consider a working programmer who writes

```c++
    std::flat_set<std::string> s;
    s.equal_range("abc");
      // lower_bound, lower_bound+1; (1 + lg N) operations total
```

and then switches to a heterogeneous comparator in an effort to "speed up" the code
by avoiding the conversion to `std::string`:

```c++
    std::flat_set<std::string, std::less<>> st;
    st.equal_range("abc");
      // lower_bound, upper_bound; (2 lg N) operations total, cache-unfriendly
```

libc++ would like to see vendors given a little more freedom to experiment here.

The proposed wording below doesn't require any vendor to change their implementation,
since an existing implementation in O(log N) certainly also satisfies O(M + log N).

### Wording ### {#wording-complexity-equal-range}

Change <a href="https://eel.is/c++draft/associative.reqmts.general#171">[associative.reqmts.general]</a> as follows:

<small><blockquote>
<pre>
a_tran.upper_bound(ku)
</pre>

166․ Result: `iterator`; `const_iterator` for constant `a_tran`.

167․ Returns: An iterator pointing to the first element with key `r` such that `c(ku, r)`, or `a_tran.end()` if such an element is not found.

168․ Complexity: Logarithmic.

<pre>
b.equal_range(k)
</pre>

169․ Result: `pair<iterator, iterator>`; `pair<const_iterator, const_iterator>` for constant `b`.

170․ Effects: Equivalent to: `return make_pair(b.lower_bound(k), b.upper_bound(k));`

171․ Complexity: <del>Logarithmic.</del> <ins>O(M + log N), where N is `b.size()` and M is `distance(b.lower_bound(k), b.upper_bound(k))`.</ins>

<pre>
a_tran.equal_range(ke)
</pre>

172․ Result: `pair<iterator, iterator>`; `pair<const_iterator, const_iterator>` for constant `a_tran`.

173․ Effects: Equivalent to: `return make_pair(a_tran.lower_bound(ke), a_tran.upper_bound(ke));`

174․ Complexity: <del>Logarithmic.</del> <ins>O(M + log N), where N is `a_tran.size()` and M is `distance(a_tran.lower_bound(ke), a_tran.upper_bound(ke))`.</ins>
</blockquote></small>

## "Qualifies as a container" ## {#qualifies-container}

Arthur's libc++ implements an alternative resolution to [[LWG3803]]. This resolution applies
generally to all container adaptors, and has the advantage of not ad-hoc relying on a
complicated type trait (`is_invocable`) but being a little more consistent with the
pre-existing spec.

The choice of `C::const_iterator` is simply because `T::value_type` is already present
for allocators, and `T::iterator` is already present for many iterators (those that inherit
from `std::iterator`, for example). We could just as well choose a criterion like
"The expression `declval<C&>().size()` is well-formed when treated as an unevaluated operand."

### Wording ### {#wording-qualifies-container}

Arthur's preferred resolution is shown in <ins>this color</ins>.
Parts of the current C++23 Working Draft that were introduced by the adopted
resolution of LWG3803, but would be removed by this change, are shown in <src>this color</src>.

Change <a href="https://eel.is/c++draft/container.requirements#container.reqmts-69">[container.reqmts]/69</a> as follows:

<small><blockquote>
69․ The behavior of certain container member functions and deduction guides depends on whether types qualify as
input iterators<ins>, containers,</ins> or allocators.

<p><ins>x․</ins> The extent to which an implementation determines that a type cannot be an input iterator is unspecified,
except that as a minimum integral types shall not qualify as input iterators.

<p><ins>x․</ins> <del>Likewise, the</del> <ins>The</ins> extent to which an implementation determines that a type cannot be an allocator is unspecified,
except that as a minimum a type `A` shall not qualify as an allocator unless it meets both of the following conditions:

* (69.1) The qualified-id `A::value_type` is valid and denotes a type ([temp.deduct]).
* (69.2) The expression `declval<A&>().allocate(size_t{})` is well-formed when treated as an unevaluated operand.

<p><ins>x․ The extent to which an implementation determines that a type cannot be a container
is unspecified, except that as a minimum a type C shall not qualify as a container
unless the qualified-id `C::const_iterator` is valid and denotes a type.</ins>
</blockquote></small>

Change <a href="https://eel.is/c++draft/container.adaptors.general">[container.adaptors.general]/6</a> as follows:

<small><blockquote>
6․ A deduction guide for a container adaptor shall not participate in overload resolution if any of the following are true:

* (6.1) It has an `InputIterator` template parameter and a type that does not qualify as an input iterator is deduced for that parameter.

* (6.2) It has a `Compare` template parameter and a type that qualifies as an allocator is deduced for that parameter.

* (6.3) It has a `Container`, `KeyContainer`, or `MappedContainer` template parameter
     and a type that <del>qualifies as an allocator</del> <ins>does not qualify as a container</ins> is deduced for that parameter.

* (6.4) It has no `Container`, `KeyContainer`, or `MappedContainer` template parameter,
     and it has an `Allocator` template parameter, and a type that does not qualify as an allocator is deduced for that parameter.

* (6.5) It has both `Container` and `Allocator` template parameters, and `uses_allocator_v<Container, Allocator>` is `false`.

* (6.6) It has both `KeyContainer` and `Allocator` template parameters, and `uses_allocator_v<KeyContainer, Allocator>` is `false`.

* <src>(6.7) It has both `KeyContainer` and `Compare` template parameters, and</src>
    <pre>
        <src>is_invocable_v&lt;const Compare&,</src>
                      <src>const typename KeyContainer::value_type&,</src>
                      <src>const typename KeyContainer::value_type&></src>
    </pre>
    <src>is not a valid expression or is `false`.</src>

* (6.8) It has both `MappedContainer` and `Allocator` template parameters, and `uses_allocator_v<MappedContainer, Allocator>` is `false`.

</blockquote></small>

## Support for non-standard containers ## {#containers}

Vendors are required to support "random-access containers," which means `vector<T>` (except for `vector<bool>`)
and `deque<T>`. It's unclear if vendors are required to support non-standard containers such as
`boost::container::vector<T>`; and if so, what public API those containers must provide in order
to interoperate with `flat_set`.

For example, suppose the underlying container supports `C(first, last)` but not
`C(from_range, rg)`. Then I would expect that I couldn't initialize a `flat_set<T, Compare, C>`
with `flat_set(from_range, rg)`; but I should still be able to initialize it with `flat_set(first, last)`,
right? It would be nice to see what's required and what's encouraged in this area.

libc++ goes very slightly out of its way to support `vector<bool>` as the underlying container,
even though we believe we're not required to support it.

## Noexcept `swap` ## {#noexcept-swap}

This area seems to have been tweaked quite a bit at Batavia 2018.
See <a href="https://wiki.edg.com/bin/view/LWGBatavia2018/WednesdayAMMinutes">the minutes</a>.

`flat_set::swap` is currently specified as unconditionally noexcept, which is inconsistent both
with `std::set` and with the pre-existing adaptors.

<small><blockquote>
<pre>
    // [flat.set.defn]
    void swap(flat_set& y) noexcept;

    // [priqueue.overview]
    void swap(priority_queue& q) noexcept(is_nothrow_swappable_v&lt;Container> &&
                                          is_nothrow_swappable_v&lt;Compare>)
      { using std::swap; swap(c, q.c); swap(comp, q.comp); }

    // [set.overview]
    void swap(set&)
      noexcept(allocator_traits&lt;Allocator>::is_always_equal::value &&
               is_nothrow_swappable_v&lt;Compare>);
</pre>
<a href="https://eel.is/c++draft/associative.reqmts#except-3">[associative.reqmts.except]/3</a>:
For associative containers, no `swap` function throws an exception unless that exception
is thrown by the swap of the container's `Compare` object (if any).
</blockquote></small>

Suppose the underlying container has a throwing move-constructor (like MSVC `std::list`), and lacks a custom `swap`;
then `std::swap<Container>` can throw. Or, suppose the underlying container is `std::inplace_vector<T>`;
then its `swap` must swap `T` objects, which can throw.

Now, what happens if swapping the containers actually does throw? Then both containers are in an unknown
state, so we must restore the invariant by clearing both containers. We do the same thing if `insert` or `erase`
throws, so this is nothing new.

What happens if swapping the comparators throws? Then we cannot recover. Louis suggests adding
`is_nothrow_swappable_v<Compare>` as a constraint. The intent is nicely ergonomic:
Almost all comparators are nothrow swappable (including `std::function`, if we want to support that: [[LWG2227]]).
And the resulting behavior seems better: In the pathological corner case where `flat_set` cannot safely provide
swappability, it's better for it not to be swappable at all, than for it to falsely advertise a
noexcept `swap`. But, if we constrain away `flat_set`'s hidden-friend `swap`, `swap(fs, fs)` will still
compile; it'll just fall back to `std::swap<T> [with T=flat_set]`. We could actually `=delete`
the `swap` function, like this:

<small><blockquote>
<pre>
    <del>void swap(flat_map& y) noexcept;</del>
    <ins>void swap(flat_map& y)</ins>
      <ins>noexcept(is_nothrow_swappable_v&lt;key_container_type> &&</ins>
               <ins>is_nothrow_swappable_v&lt;mapped_container_type>)</ins>
      <ins>requires is_nothrow_swappable_v&lt;key_compare></ins>
    void clear() noexcept;

[...]

    <del>friend void swap(flat_map& x, flat_map& y) noexcept { x.swap(y); }</del>
    <ins>friend void swap(flat_map& x, flat_map& y)</ins>
      <ins>noexcept(is_nothrow_swappable_v&lt;key_container_type> &&</ins>
               <ins>is_nothrow_swappable_v&lt;mapped_container_type>)</ins>
      <ins>requires is_nothrow_swappable_v&lt;key_compare></ins>
        <ins>{ x.swap(y); }</ins>
    <ins>friend void swap(flat_map& x, flat_map& y)</ins>
      <ins>requires (!is_nothrow_swappable_v&lt;key_compare>) = delete;</ins>
</pre>
</blockquote></small>

but even then `ranges::swap(fs, fs)` would still compile; it would fall back to the
three-step move-and-assign.

It seems to be impossible to make `flat_set` non-swappable. The only reasonable options are:

* Keep the status quo (unconditional `noexcept`) and terminate the program if swapping containers throws

* Conditional `noexcept` like in [priqueue.overview], and don't care if swapping throws
    (i.e. match `priority_queue`'s status quo)

* Conditional `noexcept` like in [priqueue.overview], and clear both containers if swapping throws
    (but this won't prevent radioactivity, if `swap` left the comparator in a bad state)

### Specified in terms of `ranges::swap` ### {#ranges-swap}

Orthogonally: It surprises us that [flat.map.modifiers] specifies `swap`'s
implementation in terms of `ranges::swap(c, y.c)` etc. This feels overspecified;
<a href="https://eel.is/c++draft/container.reqmts#49">[container.reqmts]</a> adequately covers the semantics of swapping,
and vendors should be able to decide for themselves how to swap comparator objects, just like
we do in `std::set`. Arguably the tight specification helps programmers providing their own
underlying containers: they know they just need to provide an ADL `swap` or the requirements
of <a href="https://eel.is/c++draft/concept.swappable#2.3.sentence-1">[concept.swappable]/2.3</a>.
But one might point out to those programmers that their underlying container
must provide the API required in <a href="https://eel.is/c++draft/container.reqmts#49">[container.reqmts]/49–51</a>,
so the vendor can use ADL `swap(c, y.c)` or `c.swap(y.c)` if they want to.

libc++'s implementation currently uses ADL `swap(c, y.c)`, which is equivalent to `ranges::swap`
for all containers satisfying <a href="https://eel.is/c++draft/container.reqmts#51">[container.reqmts]/51</a>;
but the difference between `swap(compare, y.compare)` and `ranges::swap(compare, y.compare)` is probably observable.


## Stable sorting ## {#stable-sorting}

For the tree-based associative containers,
<a href="https://eel.is/c++draft/associative.reqmts#general-68.sentence-2">[associative.reqmts.general]</a> defines
the single-element `foo::insert(val)` to insert in a well-defined order;
<a href="https://eel.is/c++draft/associative.reqmts.general#lib:insert,ordered_associative_containers___">[associative.reqmts.general]</a> defines
the multi-element `foo::insert(first, last)` to insert in an unspecified order.
Nevertheless, in practice, all three vendors implement the latter as a simple
loop over the former, so we have this de-facto behavior portable everywhere:

```c++
    struct Apathy { bool operator()(int, int) const { return false; } };
    int a[] = {1,2,3,4,5};
    std::multiset<int, Apathy> s;

    // #1
    for (int i : a) s.insert(i);
    assert(std::ranges::equal(s, a)); // de jure

    // #2
    s.insert(a, a+5);
    assert(std::ranges::is_permutation(s, a)); // de jure
    assert(std::ranges::equal(s, a)); // de facto portable

    // #3
    s.insert_range(a);
    assert(std::ranges::is_permutation(s, a)); // de jure
    assert(std::ranges::equal(s, a)); // de facto portable
```

Similarly with equivalent keys in a `map` or `multimap`:

```c++
    std::pair<int, int> a[] = {{1,1},{1,2},{1,3}};
    std::map<int, int, Apathy> m;

    // #1
    for (auto kv : a) m.insert(kv);
    assert(m[1] == 1); // de jure

    // #2
    m.insert(a, a+5);
    assert(m[1] > 0); // de jure
    assert(m[1] == 1); // de facto portable

    // #3
    m.insert_range(a);
    assert(m[1] > 0); // de jure
    assert(m[1] == 1); // de facto portable
```

Arthur's libc++ implementation leans into the idea that `flat_foo` is a drop-in replacement for `foo`,
and ensures that `flat_foo::insert{,_range}` will behave exactly like `foo::insert{,_range}`.

```c++
    std::flat_multiset<int, Apathy> fs;

    // #1
    for (int i : a) fs.insert(i);
    assert(std::ranges::equal(fs, a)); // de jure

    // #2
    fs.insert(a, a+5);
    assert(std::ranges::is_permutation(fs, a)); // de jure
    assert(std::ranges::equal(fs, a)); // libc++

    // #3
    fs.insert_range(a);
    assert(std::ranges::is_permutation(fs, a)); // de jure
    assert(std::ranges::equal(fs, a)); // libc++
```

`flat_foo::insert(first, last)` is defined by <a href="https://eel.is/c++draft/flat.set.modifiers#lib:insert,flatset">[flat.set.modifiers]</a>
to insert in order and then "sort the range." The vendor will be tempted to use `std::sort`,
which in practice is not stable. Arthur's implementation uses `std::stable_sort` specifically
to ensure that `fs` will give the same results as `s` for all multi-element insertions.

Louis Dionne worries that by providing this additional de-facto guarantee, libc++ might be creating
a "portability trap" — the programmer writes obvious code that works perfectly on libc++, and then when
the programmer migrates to libstdc++ or Microsoft STL, they suddenly find that their code no longer works.

Therefore Louis asks whether LWG could *specifically require* that newly inserted elements be sorted stably, e.g.

<small><blockquote>
<pre>
template&lt;class InputIterator>
  void insert(InputIterator first, InputIterator last);
</pre>

5․ Effects: Adds elements to `c` as if by:
<pre>
c.insert(c.end(), first, last);
</pre>
Then, <ins>stably</ins> sorts the range of newly inserted elements with respect to `compare`;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases all but the first element from each group of consecutive equivalent elements.

6․ Complexity: N + M log M, where N is `size()` before the operation and M is `distance(first, last)`.

7․ Remarks: Since this operation performs an in-place merge, it may allocate memory.
</blockquote></small>

This operation already requires an in-place merge, which allocates memory,
so requiring it to also do a stable sort — which allocates memory — might not be considered such a big deal.

The alternative here would be for libc++ to lean into the idea that `multiset::insert_range` is supposed to
leave the order of equivalent elements unspecified, and instrument it under libc++'s existing
`_LIBCPP_DEBUG_RANDOMIZE_UNSPECIFIED_STABILITY` flag (currently used only for `sort`, `nth_element`, and `partial_sort`).
This would preserve the symmetry between `multiset` and `flat_multiset`, by making both of them de facto
randomized order (at least in debug mode).


## `insert_range(sorted_unique, rg)` ## {#insert-range-sorted-unique}

The multi-element insertion API consists of these five overloads:

```c++
  insert(first, last);                 // 1a
  insert(il);                          // 2a
  insert_range(rg);                    // 3a

  insert(sorted_unique, first, last);  // 1b
  insert(sorted_unique, il);           // 2b
```

`insert_range(sorted_unique, rg) // 3c` is conspicuously missing.

<small><table>
<tr><th>Before</th><th>After</th></tr>
<tr><td colspan="2"><pre>
auto rg = std::views::iota(0, 100) | std::take_while(lessThan50);
assert(!std::ranges::common_range&lt;decltype(rg)>);
assert(std::ranges::is_sorted(rg));
std::flat_set&lt;int> fs;
</pre></td></tr>
<tr><td><pre>
// O(n lg n)
fs.insert_range(rg);
</pre></td><td><pre>
// O(n)
fs.insert_range(std::sorted_unique, rg);
</pre></td></tr>
<tr><td><pre>
// O(n)
if (auto cv = rg | std::views::common) {
  fs.insert(std::sorted_unique, cv.begin(), cv.end());
}
</pre></td><td><pre>
// O(n)
fs.insert_range(std::sorted_unique, rg);
</pre></td></tr>
</table></small>

Now, we're also conspicuously missing a constructor overload `flat_set(sorted_unique, from_range, rg)`.
There we have a real API-design conflict: Which of `sorted_unique` and `from_range` should come first?
This is enough of a reason to simply give up on that constructor. But `insert_range` has no such API-design
problem. We can easily add this overload.

### Wording ### {#wording-insert-range-sorted-unique}

Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template&lt;class InputIterator>
      void insert(sorted_unique_t, InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      void insert_range(R&& rg);
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
      <ins>void insert_range(sorted_unique_t, R&& rg);</ins>
    void insert(initializer_list&lt;value_type> il)
      { insert(il.begin(), il.end()); }
    void insert(sorted_unique_t s, initializer_list&lt;value_type> il)
      { insert(s, il.begin(), il.end()); }
</pre>
</blockquote></small>

Add a new entry to <a href="https://eel.is/c++draft/flat.map.modifiers">[flat.map.modifiers]</a> as follows:

<small><blockquote>
<pre>
template&lt;class InputIterator>
  void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
</pre>
<p>7․ Effects: Equivalent to `insert(first, last)`.
<p>8․ Complexity: Linear.

<p><pre>
<ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
  <ins>void insert_range(sorted_unique_t, R&& rg);</ins>
</pre>
<p><ins>x․ Effects: Equivalent to `insert_range(std::forward<R>(rg))`.</ins>
<p><ins>x․ Complexity: Linear in <i>N</i>, where <i>N</i> is `size()` after the operation.</ins>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template&lt;class InputIterator>
      void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      void insert_range(R&& rg);
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
      <ins>void insert_range(sorted_equivalent_t, R&& rg);</ins>
    void insert(initializer_list&lt;value_type> il)
      { insert(il.begin(), il.end()); }
    void insert(sorted_equivalent_t s, initializer_list&lt;value_type> il)
      { insert(s, il.begin(), il.end()); }
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template&lt;class InputIterator>
      void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      void insert_range(R&& rg);
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
      <ins>void insert_range(sorted_equivalent_t, R&& rg);</ins>
    void insert(initializer_list&lt;value_type> il)
      { insert(il.begin(), il.end()); }
    void insert(sorted_equivalent_t s, initializer_list&lt;value_type> il)
      { insert(s, il.begin(), il.end()); }
</pre>
</blockquote></small>

Add a new entry to <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:

<small><blockquote>
<pre>
template&lt;class InputIterator>
  void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
</pre>
<p>7․ Effects: Equivalent to `insert(first, last)`.
<p>8․ Complexity: Linear.

<pre>
<ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
  <ins>void insert_range(sorted_equivalent_t, R&& rg);</ins>
</pre>

<p><ins>x․ Effects: Equivalent to `insert_range(std::forward<R>(rg))`.</ins>

<p><ins>x․ Complexity: Linear in N, where N is `size()` after the operation.</ins>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template&lt;class InputIterator>
      void insert(sorted_unique_t, InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      void insert_range(R&& rg);
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
      <ins>void insert_range(sorted_unique_t, R&& rg);</ins>
    void insert(initializer_list&lt;value_type> il)
      { insert(il.begin(), il.end()); }
    void insert(sorted_unique_t s, initializer_list&lt;value_type> il)
      { insert(s, il.begin(), il.end()); }
</pre>
</blockquote></small>

Add a new entry to <a href="https://eel.is/c++draft/flat.set.modifiers">[flat.set.modifiers]</a> as follows:

<small><blockquote>
<pre>
template&lt;class InputIterator>
  void insert(sorted_unique_t, InputIterator first, InputIterator last);
</pre>
<p>8․ Effects: Equivalent to `insert(first, last)`.
<p>9․ Complexity: Linear.

<pre>
template&lt;<i>container-compatible-range</i>&lt;value_type> R>
  void insert_range(R&& rg);
</pre>
<p>10․ Effects: Adds elements to <i>`c`</i> as if by:
<pre>
for (const auto& e : rg) {
  c.insert(c.end(), e);
}
</pre>
Then, sorts the range of newly inserted elements with respect to <i>`compare`</i>;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases all but the first element from each group of consecutive equivalent elements.
<p>11․ Complexity: <i>N</i> + <i>M</i> log <i>M</i>, where <i>N</i> is `size()` before the operation and <i>M</i> is `ranges::distance(rg)`.
<p>12․ Remarks: Since this operation performs an in-place merge, it may allocate memory.

<pre>
<ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
  <ins>void insert_range(sorted_unique_t, R&& rg);</ins>
</pre>
<p><ins>x․ Effects: Equivalent to `insert_range(std::forward<R>(rg))`.</ins>
<p><ins>x․ Complexity: Linear in <i>N</i>, where <i>N</i> is `size()` after the operation.</ins>
</blockquote></small>


# (LEWG) Monolithic proposal: tag narrow-contract functions, remove container ctors # {#monolith}

The following proposal is large, and late-breaking. The flat adaptors technically shipped in C++23,
but no library vendor has implemented them yet — except for Arthur's own `sg14::flat_{set,map}` and
libc++ implementation, both of which are motivation and implementation experience for this very proposal.
So WG21 does have time to fix these issues as a DR, if we are responsible enough to do so.

There are a constellation of problems with the existing flat-adaptor API.
I'll present these problems, and then present a monolithic solution with all of these benefits:

- Reduces `flat_map`'s constructor overload set from 26 (pre-LWG3802) down to 20
- Reduces `flat_map`'s deduction guide set from 12 down to 6
- Resolves [[LWG3802]], which saves adding 12 <i>more</i> constructors to `flat_map` ([[#lwg-3802]])
- Eliminates the cause of users' surprise at `flat_map<int, int> fm = {{}, {}}` ([[#deceptive]])
- Prevents accidentally constructing a `flat_map` that straddles two different allocators ([[#pmr-invariant]])
- Eliminates "<i>Complexity:</i> Linear" elements that would otherwise need LWG attention ([[#sorting-complexity]])
- Makes all narrow-contract functions uniformly take the `sorted_unique` tag ([[#replace-contract]])
- Makes all mutators uniformly come in tagged (narrow-contract) and untagged (wide-contract) flavors
- Provides a wide-contract version of `replace`, which didn't exist before ([[#replace-wide]])
- Provides a narrow-contract version of `insert_range`, which didn't exist before (i.e. [[#insert-range-sorted-unique]])
- Since no vendor has shipped flat adaptors yet, this patch reduces rather than increases vendors' workload

## Deceptive list-initialization from two lists ## {#deceptive}

Arthur has observed [in a blog post](https://quuxplusone.github.io/blog/2023/04/28/flat-map-constructors/)
that `flat_{multi,}map`'s non-explicit constructor from two containers is deceptive when used with braced initializers.

```c++
    void print_map(std::flat_multimap<int, int>);

    print_map({ {1, 2, 3}, {10, 20, 30} }); // prints {1,10}, {2,20}, {3,30}
    print_map({ {1, 2},    {10, 20} });     // prints {1,2}, {10,20}
    print_map({ {1},       {10} });         // prints {1,10}
    print_map({ {},        {} });           // prints {0,0}, {0,0}
```

To address this issue (if we wanted to), we could make `flat_{multi,}map`'s container constructors `explicit`.
But my preferred solution, presented here, is to remove those container constructors.

## `flat_map` violates PMR invariant ## {#pmr-invariant}

Using the two-container constructor of `flat_map`, we can construct
a `flat_map` that uses two different PMR allocators at once.
This violates the basic philosophical invariant of PMR: that a single
data structure never "straddles" two arenas at once.

<small><table>
<tr><th>Before</th><th>After</th></tr>
<tr><td colspan="2"><pre>
std::pmr::monotonic_buffer_resource mr1, mr2;
using V = std::pmr::vector&lt;int>;
auto ks = V({1,2,3}, &mr1);
auto vs = V({1,2,3}, &mr2);
using FM = std::flat_map&lt;int, int, std::less&lt;>, V, V>;
</pre></td></tr>
<tr><td><pre>
FM fm = FM(&mr1);
  // Keys and values both allocated from mr1.
fm.replace(std::move(ks), std::move(vs));
  // values' elements will be copied from mr2 to mr1.
</pre></td><td><pre>
FM fm = FM(&mr1);
  // Keys and values both allocated from mr1.
fm.replace(std::sorted_unique, std::move(ks), std::move(vs));
  // values' elements will be copied from mr2 to mr1.
</pre></td></tr>
<tr><td><pre>
FM fm = FM(std::sorted_unique, std::move(ks), std::move(vs));
  // "Split-brain" flat adaptor: keys allocated from mr1,
  // values allocated from mr2. Violates PMR invariant.
  // This is the only way to set up such a flat adaptor.
</pre></td><td><pre>
FM fm = FM(&mr1);
fm.replace(std::sorted_unique, std::move(ks), std::move(vs));
  // values' elements will be copied from mr2 to mr1.
  // Physically impossible to create the "split-brain"
  // adaptor from the "Before" picture.
</pre></td></tr>
</table></small>

## Complexity clauses of container ctors ## {#sorting-complexity}

The flat adaptors' container constructors have
Complexity clauses that mandate O(N) performance on input that *happens* to be sorted
at runtime, even when calling the untagged wide-contract container constructor.
The vendor has three ways to deal with this:

- Guarantee that `std::sort` (or `std::stable_sort` if [[#stable-sorting]] is adopted) will
    always run in O(N) time on sorted input. This is not currently mandated by <a href="https://eel.is/c++draft/alg.sort#sort-5">[alg.sort]</a>,
    so no vendor is likely to know off the top of their heads that they really guarantee this
    for all possible sorted inputs. libc++ certainly doesn't know this for sure.

- Add a linear-time pass on the front, e.g. `if (!std::is_sorted(first, last)) std::sort(first, last)`.
    This wastes O(N) cycles in every case: it might improve the asymptotic performance in the
    rare case that the input happens to be sorted at runtime, but only at the cost of slowing down
    the expected case where the input is not sorted. libc++ doesn't want to slow down the
    average caller.

- Ignore the spec's Complexity requirement. libc++ also doesn't want to do this.

Louis Dionne would be happy with a resolution that requires all vendors to implement this
optimization in `std::sort` itself, for ranges that happen to be sorted. I.e., change
<a href="https://eel.is/c++draft/alg.sort#sort-5">[sort]/5</a> as follows:

<small><blockquote>
5․ Complexity: Let N be `last - first`. <ins>If the input is already sorted with respect to `comp` and `proj`, O(N) comparisons and projections. Otherwise,</ins>
O(N log N) comparisons and projections. <ins>In either case, twice as many projections as comparisons.</ins>
</blockquote></small>

and change <a href="https://eel.is/c++draft/alg.sort#stable.sort-5">[stable.sort]/5</a> as follows:

<small><blockquote>
5․ Complexity: Let N be `last - first`. <ins>If the input is already sorted with respect to `comp` and `proj`, O(N) comparisons.</ins>
If enough extra memory is available, <ins>O(</ins>N log(N)<ins>)</ins> comparisons.
Otherwise, <del>at most</del> <ins>O(</ins>N log<sup>2</sup>(N)<ins>)</ins> comparisons.
In <del>either</del> <ins>any</ins> case, twice as many projections as <del>the number of</del> comparisons.
</blockquote></small>

[[P2767R0]] presented a second possible solution, as a patch against the Complexity clauses of
the flat adaptors' container constructors. The third solution, presented in [[P2767R0]] and again below,
is simply to remove the container constructors, so that we don't have to worry about this entire problem.

## `replace` is unexpectedly narrow-contract ## {#replace-contract}

Most flat-adaptor member functions with narrow contracts are tagged with `std::sorted_unique`
resp. `std::sorted_equivalent`. Currently the only exception is `.replace`. It has the same
narrow contract as `std::flat_set(std::sorted_unique, v)` — that `v` must be sorted and uniqued —
but it doesn't advertise this fact in its signature, and the consequence for violating the
precondition is simply UB. This will undoubtedly lead to serious bugs.

<small><table>
<tr><th>Before</th><th>After</th></tr>
<tr><td colspan="2"><pre>
std::flat_set&lt;int> fs;
std::vector<int> v = {3,1,4,1,5};
</pre></td></tr>
<tr><td><pre>
fs = {3,1,4,1,5};
  // OK
fs = std::flat_set(std::move(v));
  // OK
fs.replace(std::move(v));
  // undefined behavior
</pre></td><td><pre>
fs = {3,1,4,1,5};
  // OK
fs = std::flat_set(std::move(v));
  // OK
fs.replace(std::move(v));
  // OK
</pre></td></tr>
<tr><td><pre>
fs = std::flat_set(std::sorted_unique, std::move(v));
  // undefined behavior
fs.replace(std::move(v));
  // undefined behavior
</pre></td><td><pre>
fs = std::flat_set(std::sorted_unique, std::move(v));
  // undefined behavior
fs.replace(std::sorted_unique, std::move(v));
  // undefined behavior
</pre></td></tr>
</table></small>

## Wide-contract `replace` is difficult to simulate ## {#replace-wide}

Suppose the programmer has a `flat_map` with certain keys and values,
and wants to apply a transformation to the keys. He has to do something
like this:

<small><table>
<tr><th>Before</th><th>After</th></tr>
<tr><td colspan="2"><pre>
std::flat_map&lt;char, int> fm = {
  {'a', 1}, {'B', 2}, {'c', 3}
};
auto [ks, vs] = std::move(fm).extract();
for (auto& k : ks)
  k = std::toupper(k);
</pre></td></tr>
<tr><td><pre>
fm.replace(std::move(ks), std::move(vs));
  // undefined behavior
</pre></td><td><pre>
fm.replace(std::move(ks), std::move(vs));
  // OK
</pre></td></tr>
<tr><td><pre>
fm = std::flat_map(std::move(ks), std::move(vs));
  // OK, move-construct + sort + move-assign
  // (but uses the container ctor we propose to remove)
</pre></td><td><pre>
fm.replace(std::move(ks), std::move(vs));
  // OK, move-construct + sort + move-assign
</pre></td></tr>
<tr><td><pre>
std::ranges::sort(std::ranges::zip(ks, vs));
std::ranges::unique(???); // difficult to spell
fm.replace(std::move(ks), std::move(vs));
  // OK but tedious and error-prone
</pre></td><td><pre>
fm.replace(std::move(ks), std::move(vs));
  // OK, not tedious at all
</pre></td></tr>
</table></small>

## `replace` can't take lvalues ## {#replace-by-value}

The current specification for `replace` takes the new container(s) by rvalue reference.
This might have been originally intended as a guard against accidental expensive copying of containers.
But C++ doesn't use this pattern anywhere else; and it's inconsistent with the container constructors,
which do take by value and happily allow passing in lvalue containers by copy.

<small><table>
<tr><th>Before</th><th>After</th></tr>
<tr><td colspan="2"><pre>
std::vector&lt;int> v = {1,2,3};
std::flat_set&lt;int> fs;
</pre></td></tr>
<tr><td><pre>
fs = std::flat_set(v);
  // OK, copy-construct + sort + move-assign
fs = std::flat_set(std::sorted_unique, v);
  // OK, copy-construct + move-assign
</pre></td><td><pre>
fs.replace(v);
  // OK, copy-construct + sort + move-assign
fs.replace(std::sorted_unique, v);
  // OK, copy-construct + move-assign
</pre></td></tr>
<tr><td><pre>
fs.replace(auto(v));
  // OK, copy-construct + move-assign
</pre></td><td><pre>
fs.replace(std::sorted_unique, v);
  // OK, copy-construct + move-assign
</pre></td></tr>
<tr><td><pre>
fs.replace(std::move(v));
  // OK, move-assign
</pre></td><td><pre>
fs.replace(std::sorted_unique, std::move(v));
  // OK, move-construct + move-assign
</pre></td></tr>
</table></small>

## (LWG3802) Allocator-extended container ctors lack move semantics ## {#lwg-3802}

Arthur's libc++ has implemented move-semantic allocator-extended constructors for all four flat containers
(<a href="https://godbolt.org/z/We7K1K6bE">Godbolt</a>). This is [[LWG3802]].

```c++
    template<class K, class V, class C = std::less<K>>
    using PmrFlatMap = std::flat_map<K, V, C, std::pmr::vector<K>, std::pmr::vector<V>>;

    std::pmr::monotonic_buffer_resource mr;
    auto keys = std::pmr::vector<int>({1,2,3}, &mr);
    auto values = std::pmr::vector<int>({1,2,3}, &mr);
    auto maps = std::pmr::vector<PmrFlatMap<int, int>>(&mr);
    maps.emplace_back(std::move(keys), values);
      // Before: Makes copies of both keys and values
      // After: Moves-from keys; copies values

    auto keys2 = std::pmr::vector<std::unique_ptr<int>>();
    auto sets = std::pmr::vector<PmrFlatSet<std::unique_ptr<int>>>();
    sets.emplace_back(std::move(keys2));
      // Before: Ill-formed
      // After: OK, moves-from keys2
```

To make this work, we'd have to add 12 new constructors to `flat_map`, like this.
But I propose that instead of bloating the existing overload set, we shrink it
by removing the container constructors altogether.

<small><blockquote>
<pre>
    // [flat.map.cons.alloc], constructors with allocators

    template&lt;class Alloc>
      flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,
               const Alloc& a);
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(const key_container_type& key_cont, mapped_container_type&& mapped_cont,</ins>
               <ins>const Alloc& a);</ins>
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(key_container_type&& key_cont, const mapped_container_type& mapped_cont,</ins>
               <ins>const Alloc& a);</ins>
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(key_container_type&& key_cont, mapped_container_type&& mapped_cont,</ins>
               <ins>const Alloc& a);</ins>
    template&lt;class Alloc>
      flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,
               const key_compare& comp, const Alloc& a);
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(const key_container_type& key_cont, mapped_container_type&& mapped_cont,</ins>
               <ins>const key_compare& comp, const Alloc& a);</ins>
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(key_container_type&& key_cont, const mapped_container_type& mapped_cont,</ins>
               <ins>const key_compare& comp, const Alloc& a);</ins>
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(key_container_type&& key_cont, mapped_container_type&& mapped_cont,</ins>
               <ins>const key_compare& comp, const Alloc& a);</ins>
    template&lt;class Alloc>
      flat_map(sorted_unique_t, const key_container_type& key_cont,
               const mapped_container_type& mapped_cont, const Alloc& a);
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(sorted_unique_t, const key_container_type& key_cont,</ins>
               <ins>mapped_container_type&& mapped_cont, const Alloc& a);</ins>
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(sorted_unique_t, key_container_type&& key_cont,</ins>
               <ins>const mapped_container_type& mapped_cont, const Alloc& a);</ins>
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(sorted_unique_t, key_container_type&& key_cont,</ins>
               <ins>mapped_container_type&& mapped_cont, const Alloc& a);</ins>
    template&lt;class Alloc>
      flat_map(sorted_unique_t, const key_container_type& key_cont,
               const mapped_container_type& mapped_cont,
               const key_compare& comp, const Alloc& a);
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(sorted_unique_t, const key_container_type& key_cont,</ins>
               <ins>mapped_container_type&& mapped_cont,</ins>
               <ins>const key_compare& comp, const Alloc& a);</ins>
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(sorted_unique_t, key_container_type&& key_cont,</ins>
               <ins>const mapped_container_type& mapped_cont,</ins>
               <ins>const key_compare& comp, const Alloc& a);</ins>
    <ins>template&lt;class Alloc></ins>
      <ins>flat_map(sorted_unique_t, key_container_type&& key_cont,</ins>
               <ins>mapped_container_type&& mapped_cont,</ins>
               <ins>const key_compare& comp, const Alloc& a);</ins>
</pre>
</blockquote></small>


## Monolithic wording ## {#wording-monolith}

Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:

<small><blockquote>
<pre>
[...]

    // [flat.map.cons], constructors
    flat_map() : flat_map(key_compare()) { }
    explicit flat_map(const key_compare& comp)
      : c(), compare(comp) { }
    <del>flat_map(key_container_type key_cont, mapped_container_type mapped_cont,</del>
             <del>const key_compare& comp = key_compare());</del>
    <del>flat_map(sorted_unique_t, key_container_type key_cont, mapped_container_type mapped_cont,</del>
             <del>const key_compare& comp = key_compare());</del>
    template&lt;class InputIterator>
      flat_map(InputIterator first, InputIterator last, const key_compare& comp = key_compare())
        : c(), compare(comp) { insert(first, last); }
    template&lt;class InputIterator>
      flat_map(sorted_unique_t s, InputIterator first, InputIterator last,
               const key_compare& comp = key_compare())
        : c(), compare(comp) { insert(s, first, last); }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_map(from_range_t fr, R&& rg)
        : flat_map(fr, std::forward&lt;R>(rg), key_compare()) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_map(from_range_t, R&& rg, const key_compare& comp)
        : flat_map(comp) { insert_range(std::forward&lt;R>(rg)); }

[...]

    // [flat.map.cons.alloc], constructors with allocators

    template&lt;class Alloc>
      explicit flat_map(const Alloc& a);
    template&lt;class Alloc>
      flat_map(const key_compare& comp, const Alloc& a);
    <del>template&lt;class Alloc></del>
      <del>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</del>
               <del>const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</del>
               <del>const key_compare& comp, const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_map(sorted_unique_t, const key_container_type& key_cont,</del>
               <del>const mapped_container_type& mapped_cont, const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_map(sorted_unique_t, const key_container_type& key_cont,</del>
               <del>const mapped_container_type& mapped_cont,</del>
               <del>const key_compare& comp, const Alloc& a);</del>
    template&lt;class InputIterator, class Alloc>
      flat_map(InputIterator first, InputIterator last, const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_map(InputIterator first, InputIterator last,
               const key_compare& comp, const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_map(sorted_unique_t, InputIterator first, InputIterator last, const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_map(sorted_unique_t, InputIterator first, InputIterator last,
               const key_compare& comp, const Alloc& a);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
      flat_map(from_range_t, R&& rg, const Alloc& a);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
      flat_map(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);

[...]

    containers extract() &&;
    void replace(key_container_type<del>&&</del> key_cont, mapped_container_type<del>&&</del> mapped_cont);
    <ins>void replace(sorted_unique_t, key_container_type key_cont, mapped_container_type mapped_cont);</ins>

[...]

  };

  <del>template&lt;class KeyContainer, class MappedContainer,</del>
           <del>class Compare = less&lt;typename KeyContainer::value_type>></del>
    <del>flat_map(KeyContainer, MappedContainer, Compare = Compare())</del>
      <del>-> flat_map&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                  <del>Compare, KeyContainer, MappedContainer>;</del>
  <del>template&lt;class KeyContainer, class MappedContainer, class Allocator></del>
    <del>flat_map(KeyContainer, MappedContainer, Allocator)</del>
      <del>-> flat_map&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                  <del>less&lt;typename KeyContainer::value_type>, KeyContainer, MappedContainer>;</del>
  <del>template&lt;class KeyContainer, class MappedContainer, class Compare, class Allocator></del>
    <del>flat_map(KeyContainer, MappedContainer, Compare, Allocator)</del>
      <del>-> flat_map&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                  <del>Compare, KeyContainer, MappedContainer>;</del>
  <del>template&lt;class KeyContainer, class MappedContainer,</del>
           <del>class Compare = less&lt;typename KeyContainer::value_type>></del>
    <del>flat_map(sorted_unique_t, KeyContainer, MappedContainer, Compare = Compare())</del>
      <del>-> flat_map&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                  <del>Compare, KeyContainer, MappedContainer>;</del>
  <del>template&lt;class KeyContainer, class MappedContainer, class Allocator></del>
    <del>flat_map(sorted_unique_t, KeyContainer, MappedContainer, Allocator)</del>
      <del>-> flat_map&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                  <del>less&lt;typename KeyContainer::value_type>, KeyContainer, MappedContainer>;</del>
  <del>template&lt;class KeyContainer, class MappedContainer, class Compare, class Allocator></del>
    <del>flat_map(sorted_unique_t, KeyContainer, MappedContainer, Compare, Allocator)</del>
      <del>-> flat_map&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                  <del>Compare, KeyContainer, MappedContainer>;</del>
  template&lt;class InputIterator, class Compare = less&lt;<i>iter-key-type</i>&lt;InputIterator>>>
    flat_map(InputIterator, InputIterator, Compare = Compare())
      -> flat_map&lt;<i>iter-key-type</i>&lt;InputIterator>, <i>iter-mapped-type</i>&lt;InputIterator>, Compare>;
  template&lt;class InputIterator, class Compare = less&lt;<i>iter-key-type</i>&lt;InputIterator>>>
    flat_map(sorted_unique_t, InputIterator, InputIterator, Compare = Compare())
      -> flat_map&lt;<i>iter-key-type</i>&lt;InputIterator>, <i>iter-mapped-type</i>&lt;InputIterator>, Compare>;
  template&lt;ranges::input_range R, class Compare = less&lt;<i>range-key-type</i>&lt;R>>,
           class Allocator = allocator&lt;byte>>
    flat_map(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
      -> flat_map&lt;<i>range-key-type</i>&lt;R>, <i>range-mapped-type</i>&lt;R>, Compare,
                  vector&lt;<i>range-key-type</i>&lt;R>, <i>alloc-rebind</i>&lt;Allocator, <i>range-key-type</i>&lt;R>>>,
                  vector&lt;<i>range-mapped-type</i>&lt;R>, <i>alloc-rebind</i>&lt;Allocator, <i>range-mapped-type</i>&lt;R>>>>;
  template&lt;ranges::input_range R, class Allocator>
    flat_map(from_range_t, R&&, Allocator)
      -> flat_map&lt;<i>range-key-type</i>&lt;R>, <i>range-mapped-type</i>&lt;R>, less&lt;<i>range-key-type</i>&lt;R>>,
                  vector&lt;<i>range-key-type</i>&lt;R>, <i>alloc-rebind</i>&lt;Allocator, <i>range-key-type</i>&lt;R>>>,
                  vector&lt;<i>range-mapped-type</i>&lt;R>, <i>alloc-rebind</i>&lt;Allocator, <i>range-mapped-type</i>&lt;R>>>>;
  template&lt;class Key, class T, class Compare = less&lt;Key>>
    flat_map(initializer_list&lt;pair&lt;Key, T>>, Compare = Compare())
      -> flat_map&lt;Key, T, Compare>;
  template&lt;class Key, class T, class Compare = less&lt;Key>>
    flat_map(sorted_unique_t, initializer_list&lt;pair&lt;Key, T>>, Compare = Compare())
        -> flat_map&lt;Key, T, Compare>;
</pre>
</blockquote></small>

Remove the whole of <a href="https://eel.is/c++draft/flat.map.cons">[flat.map.cons]</a>,
and change <a href="https://eel.is/c++draft/flat.map.cons.alloc">[flat.map.cons.alloc]</a>, as follows:

<small><blockquote>
<del><b>Constructors [flat.map.cons]</b></del>
<p><pre>
<del>flat_map(key_container_type key_cont, mapped_container_type mapped_cont,</del>
         <del>const key_compare& comp = key_compare());</del>
</pre>
<p><del>1․ <i>Effects:</i> Initializes `c.keys` with `std::move(key_cont)`,
`c.values` with `std::move(mapped_cont)`, and `compare` with `comp`;
sorts the range [`begin()`, `end()`) with respect to `value_comp()`; and
finally erases the duplicate elements as if by:</del>
<pre>
<del>auto zv = views::zip(c.keys, c.values);</del>
<del>auto it = ranges::unique(zv, key_equiv(compare)).begin();</del>
<del>auto dist = distance(zv.begin(), it);</del>
<del>c.keys.erase(c.keys.begin() + dist, c.keys.end());</del>
<del>c.values.erase(c.values.begin() + dist, c.values.end());</del>
</pre>
<p><del>2․ <i>Complexity:</i> Linear in <i>N</i> if the container arguments are already sorted
with respect to `value_comp()` and otherwise <i>N</i> log <i>N</i>,
where <i>N</i> is the value of `key_cont.size()` before this call.</del>

<p><pre>
<del>flat_map(sorted_unique_t, key_container_type key_cont, mapped_container_type mapped_cont,</del>
         <del>const key_compare& comp = key_compare());</del>
</pre>
<p><del>3․ <i>Effects:</i> Initializes `c.keys` with `std::move(key_cont)`,
`c.values` with `std::move(mapped_cont)`, and `compare` with `comp`.</del>

<p><del>4․ <i>Complexity:</i> Constant.</del>

<p><b>Constructors with allocators [flat.map.cons.alloc]</b>

<p>1․ The constructors in this subclause shall not participate in overload resolution
unless `uses_allocator_v<key_container_type, Alloc>` is `true`
and `uses_allocator_v<mapped_container_type, Alloc>` is `true`.

<p><pre>
<del>template&lt;class Alloc></del>
  <del>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</del>
           <del>const Alloc& a);</del>
<del>template&lt;class Alloc></del>
  <del>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</del>
           <del>const key_compare& comp, const Alloc& a);</del>
</pre>
<p><del>2․ <i>Effects:</i> Equivalent to `flat_map(key_cont, mapped_cont)` and `flat_map(key_cont, mapped_cont, comp)`, respectively,
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).</del>
<p><del>3․ <i>Complexity:</i> Same as `flat_map(key_cont, mapped_cont)` and `flat_map(key_cont, mapped_cont, comp)`, respectively.</del>

<p><pre>
<del>template&lt;class Alloc></del>
  <del>flat_map(sorted_unique_t s, const key_container_type& key_cont,</del>
           <del>const mapped_container_type& mapped_cont, const Alloc& a);</del>
<del>template&lt;class Alloc></del>
  <del>flat_map(sorted_unique_t s, const key_container_type& key_cont,</del>
           <del>const mapped_container_type& mapped_cont, const key_compare& comp,</del>
           <del>const Alloc& a);</del>
</pre>
<p><del>4․ <i>Effects:</i> Equivalent to `flat_map(s, key_cont, mapped_cont)` and `flat_map(s, key_cont, mapped_cont, comp)`, respectively,
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).</del>
<p><del>5․ <i>Complexity:</i> Linear.</del>

<p><pre>
template&lt;class Alloc>
  explicit flat_map(const Alloc& a);
template&lt;class Alloc>
  flat_map(const key_compare& comp, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_map(InputIterator first, InputIterator last, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_map(InputIterator first, InputIterator last, const key_compare& comp, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_map(sorted_unique_t, InputIterator first, InputIterator last, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_map(sorted_unique_t, InputIterator first, InputIterator last,
           const key_compare& comp, const Alloc& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
  flat_map(from_range_t, R&& rg, const Alloc& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
  flat_map(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template&lt;class Alloc>
  flat_map(initializer_list&lt;value_type> il, const Alloc& a);
template&lt;class Alloc>
  flat_map(initializer_list&lt;value_type> il, const key_compare& comp, const Alloc& a);
template&lt;class Alloc>
  flat_map(sorted_unique_t, initializer_list&lt;value_type> il, const Alloc& a);
template&lt;class Alloc>
  flat_map(sorted_unique_t, initializer_list&lt;value_type> il,
           const key_compare& comp, const Alloc& a);
</pre>
<p>6․ <i>Effects:</i> Equivalent to the corresponding non-allocator constructors except that
`c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.map.modifiers">[flat.map.modifiers]</a> as follows:

<small><blockquote>
[...]
<p><pre>
containers extract() &&;
</pre>
<p>34․ <i>Postconditions:</i> `*this` is emptied, even if the function exits via an exception.
<p>35․ <i>Returns:</i> `std::move(c)`.

<p><pre>
void replace(key_container_type<del>&&</del> key_cont, mapped_container_type<del>&&</del> mapped_cont);
</pre>
<p><ins>x․ <i>Preconditions:</i> `key_cont.size() == mapped_cont.size()` is `true`.</ins>
<p><ins>x․ <i>Effects:</i> Replaces `c.keys` with `key_cont` and `c.values` with `mapped_cont`;
sorts the range [`begin()`, `end()`) with respect to `value_comp()`; and
finally erases the duplicate elements as if by:</ins>
<pre>
<ins>auto zv = views::zip(c.keys, c.values);</ins>
<ins>auto it = ranges::unique(zv, key_equiv(compare)).begin();</ins>
<ins>auto dist = distance(zv.begin(), it);</ins>
<ins>c.keys.erase(c.keys.begin() + dist, c.keys.end());</ins>
<ins>c.values.erase(c.values.begin() + dist, c.values.end());</ins>
</pre>

<p><pre>
<ins>void replace(sorted_unique_t, key_container_type key_cont, mapped_container_type mapped_cont);</ins>
</pre>
<p>36․ <i>Preconditions:</i> `key_cont.size() == mapped_cont.size()` is `true`, the elements of
`key_cont` are sorted with respect to `compare`, and `key_cont` contains no equal elements.
<p>37․ <i>Effects:</i> Equivalent to:
<pre>
c.keys = std::move(key_cont);
c.values = std::move(mapped_cont);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:

<small><blockquote>
<pre>
[...]

    // [flat.multimap.cons], constructors
    flat_multimap() : flat_multimap(key_compare()) { }
    explicit flat_multimap(const key_compare& comp)
      : c(), compare(comp) { }
    <del>flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,</del>
                  <del>const key_compare& comp = key_compare());</del>
    <del>flat_multimap(sorted_equivalent_t, key_container_type key_cont, mapped_container_type mapped_cont,</del>
                  <del>const key_compare& comp = key_compare());</del>
    template&lt;class InputIterator>
      flat_multimap(InputIterator first, InputIterator last, const key_compare& comp = key_compare())
        : c(), compare(comp) { insert(first, last); }
    template&lt;class InputIterator>
      flat_multimap(sorted_equivalent_t s, InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : c(), compare(comp) { insert(s, first, last); }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_multimap(from_range_t fr, R&& rg)
        : flat_multimap(fr, std::forward&lt;R>(rg), key_compare()) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_multimap(from_range_t, R&& rg, const key_compare& comp)
        : flat_multimap(comp) { insert_range(std::forward&lt;R>(rg)); }

[...]

    // [flat.multimap.cons.alloc], constructors with allocators

    template&lt;class Alloc>
      explicit flat_multimap(const Alloc& a);
    template&lt;class Alloc>
      flat_multimap(const key_compare& comp, const Alloc& a);
    <del>template&lt;class Alloc></del>
      <del>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</del>
                    <del>const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</del>
                    <del>const key_compare& comp, const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_multimap(sorted_equivalent_t, const key_container_type& key_cont,</del>
                    <del>const mapped_container_type& mapped_cont, const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_multimap(sorted_equivalent_t, const key_container_type& key_cont,</del>
                    <del>const mapped_container_type& mapped_cont,</del>
                    <del>const key_compare& comp, const Alloc& a);</del>
    template&lt;class InputIterator, class Alloc>
      flat_multimap(InputIterator first, InputIterator last, const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_multimap(InputIterator first, InputIterator last,
                    const key_compare& comp, const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const key_compare& comp, const Alloc& a);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
      flat_multimap(from_range_t, R&& rg, const Alloc& a);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
      flat_multimap(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);

[...]

    containers extract() &&;
    void replace(key_container_type<del>&&</del> key_cont, mapped_container_type<del>&&</del> mapped_cont);
    <ins>void replace(sorted_equivalent_t, key_container_type key_cont, mapped_container_type mapped_cont);</ins>

[...]

  };

  <del>template&lt;class KeyContainer, class MappedContainer,</del>
           <del>class Compare = less&lt;typename KeyContainer::value_type>></del>
    <del>flat_multimap(KeyContainer, MappedContainer, Compare = Compare())</del>
      <del>-> flat_multimap&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                       <del>Compare, KeyContainer, MappedContainer>;</del>
  <del>template&lt;class KeyContainer, class MappedContainer, class Allocator></del>
    <del>flat_multimap(KeyContainer, MappedContainer, Allocator)</del>
      <del>-> flat_multimap&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                       <del>less&lt;typename KeyContainer::value_type>, KeyContainer, MappedContainer>;</del>
  <del>template&lt;class KeyContainer, class MappedContainer, class Compare, class Allocator></del>
    <del>flat_multimap(KeyContainer, MappedContainer, Compare, Allocator)</del>
      <del>-> flat_multimap&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                       <del>Compare, KeyContainer, MappedContainer>;</del>
  <del>template&lt;class KeyContainer, class MappedContainer,</del>
           <del>class Compare = less&lt;typename KeyContainer::value_type>></del>
    <del>flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer, Compare = Compare())</del>
      <del>-> flat_multimap&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                       <del>Compare, KeyContainer, MappedContainer>;</del>
  <del>template&lt;class KeyContainer, class MappedContainer, class Allocator></del>
    <del>flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer, Allocator)</del>
      <del>-> flat_multimap&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                       <del>less&lt;typename KeyContainer::value_type>, KeyContainer, MappedContainer>;</del>
  <del>template&lt;class KeyContainer, class MappedContainer, class Compare, class Allocator></del>
    <del>flat_multimap(sorted_equivalent_t, KeyContainer, MappedContainer, Compare, Allocator)</del>
      <del>-> flat_multimap&lt;typename KeyContainer::value_type, typename MappedContainer::value_type,</del>
                       <del>Compare, KeyContainer, MappedContainer>;</del>
  template&lt;class InputIterator, class Compare = less&lt;<i>iter-key-type</i>&lt;InputIterator>>>
    flat_multimap(InputIterator, InputIterator, Compare = Compare())
      -> flat_multimap&lt;<i>iter-key-type</i>&lt;InputIterator>, <i>iter-mapped-type</i>&lt;InputIterator>, Compare>;
  template&lt;class InputIterator, class Compare = less&lt;<i>iter-key-type</i>&lt;InputIterator>>>
    flat_multimap(sorted_equivalent_t, InputIterator, InputIterator, Compare = Compare())
      -> flat_multimap&lt;<i>iter-key-type</i>&lt;InputIterator>, <i>iter-mapped-type</i>&lt;InputIterator>, Compare>;
  template&lt;ranges::input_range R, class Compare = less&lt;<i>range-key-type</i>&lt;R>>,
           class Allocator = allocator&lt;byte>>
    flat_multimap(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
      -> flat_multimap&lt;<i>range-key-type</i>&lt;R>, <i>range-mapped-type</i>&lt;R>, Compare,
                       vector&lt;<i>range-key-type</i>&lt;R>,
                              <i>alloc-rebind</i>&lt;Allocator, <i>range-key-type</i>&lt;R>>>,
                       vector&lt;<i>range-mapped-type</i>&lt;R>,
                              <i>alloc-rebind</i>&lt;Allocator, <i>range-mapped-type</i>&lt;R>>>>;
  template&lt;ranges::input_range R, class Allocator>
    flat_multimap(from_range_t, R&&, Allocator)
      -> flat_multimap&lt;<i>range-key-type</i>&lt;R>, <i>range-mapped-type</i>&lt;R>, less&lt;<i>range-key-type</i>&lt;R>>,
                       vector&lt;<i>range-key-type</i>&lt;R>,
                              <i>alloc-rebind</i>&lt;Allocator, <i>range-key-type</i>&lt;R>>>,
                       vector&lt;<i>range-mapped-type</i>&lt;R>,
                              <i>alloc-rebind</i>&lt;Allocator, <i>range-mapped-type</i>&lt;R>>>>;
  template&lt;class Key, class T, class Compare = less&lt;Key>>
    flat_multimap(initializer_list&lt;pair&lt;Key, T>>, Compare = Compare())
      -> flat_multimap&lt;Key, T, Compare>;
  template&lt;class Key, class T, class Compare = less&lt;Key>>
    flat_multimap(sorted_equivalent_t, initializer_list&lt;pair&lt;Key, T>>, Compare = Compare())
        -> flat_multimap&lt;Key, T, Compare>;
</pre>
</blockquote></small>

Remove the whole of <a href="https://eel.is/c++draft/flat.multimap.cons">[flat.multimap.cons]</a>,
and change <a href="https://eel.is/c++draft/flat.multimap.cons.alloc">[flat.multimap.cons.alloc]</a>, as follows:

<small><blockquote>
<del><b>Constructors [flat.multimap.cons]</b></del>
<p><pre>
<del>flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,</del>
              <del>const key_compare& comp = key_compare());</del>
</pre>
<p><del>1․ <i>Effects:</i> Initializes `c.keys` with `std::move(key_cont)`,
`c.values` with `std::move(mapped_cont)`, and `compare` with `comp`;
sorts the range [`begin()`, `end()`) with respect to `value_comp()`.</del>
<p><del>2․ <i>Complexity:</i> Linear in <i>N</i> if the container arguments are already sorted
with respect to `value_comp()` and otherwise <i>N</i> log <i>N</i>,
where <i>N</i> is the value of `key_cont.size()` before this call.</del>

<p><pre>
<del>flat_multimap(sorted_equivalent_t, key_container_type key_cont, mapped_container_type mapped_cont,</del>
              <del>const key_compare& comp = key_compare());</del>
</pre>
<p><del>3․ <i>Effects:</i> Initializes `c.keys` with `std::move(key_cont)`,
`c.values` with `std::move(mapped_cont)`, and `compare` with `comp`.</del>
<p><del>4․ <i>Complexity:</i> Constant.</del>

<p><b>Constructors with allocators [flat.multimap.cons.alloc]</b>

<p>1․ The constructors in this subclause shall not participate in overload resolution
unless `uses_allocator_v<key_container_type, Alloc>` is `true`
and `uses_allocator_v<mapped_container_type, Alloc>` is `true`.

<p><pre>
<del>template&lt;class Alloc></del>
  <del>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</del>
                <del>const Alloc& a);</del>
<del>template&lt;class Alloc></del>
  <del>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</del>
                <del>const key_compare& comp, const Alloc& a);</del>
</pre>
<p><del>2․ <i>Effects:</i> Equivalent to `flat_multimap(key_cont, mapped_cont)` and
`flat_multimap(key_cont, mapped_cont, comp)`, respectively,
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).</del>
<p><del>3․ <i>Complexity:</i> Same as `flat_multimap(key_cont, mapped_cont)` and
`flat_multimap(key_cont, mapped_cont, comp)`, respectively.</del>

<p><pre>
<del>template&lt;class Alloc></del>
  <del>flat_multimap(sorted_equivalent_t s, const key_container_type& key_cont,</del>
                <del>const mapped_container_type& mapped_cont, const Alloc& a);</del>
<del>template&lt;class Alloc></del>
  <del>flat_multimap(sorted_equivalent_t s, const key_container_type& key_cont,</del>
                <del>const mapped_container_type& mapped_cont, const key_compare& comp,</del>
                <del>const Alloc& a);</del>
</pre>
<p><del>4․ <i>Effects:</i> Equivalent to `flat_multimap(s, key_cont, mapped_cont)` and
`flat_multimap(s, key_cont, mapped_cont, comp)`, respectively,
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).</del>
<p><del>5․ <i>Complexity:</i> Linear.</del>

<p><pre>
template&lt;class Alloc>
  explicit flat_multimap(const Alloc& a);
template&lt;class Alloc>
  flat_multimap(const key_compare& comp, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_multimap(InputIterator first, InputIterator last, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_multimap(InputIterator first, InputIterator last, const key_compare& comp,
                const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                const key_compare& comp, const Alloc& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
  flat_multimap(from_range_t, R&& rg, const Alloc& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
  flat_multimap(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template&lt;class Alloc>
  flat_multimap(initializer_list&lt;value_type> il, const Alloc& a);
template&lt;class Alloc>
  flat_multimap(initializer_list&lt;value_type> il, const key_compare& comp, const Alloc& a);
template&lt;class Alloc>
  flat_multimap(sorted_equivalent_t, initializer_list&lt;value_type> il, const Alloc& a);
template&lt;class Alloc>
  flat_multimap(sorted_equivalent_t, initializer_list&lt;value_type> il,
                const key_compare& comp, const Alloc& a);
</pre>
<p>6․ <i>Effects:</i> Equivalent to the corresponding non-allocator constructors
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
<pre>
[...]

    // [flat.multiset.cons], constructors
    flat_multiset() : flat_multiset(key_compare()) { }
    explicit flat_multiset(const key_compare& comp)
      : c(), compare(comp) { }
    <del>explicit flat_multiset(container_type cont, const key_compare& comp = key_compare());</del>
    <del>flat_multiset(sorted_equivalent_t, container_type cont,</del>
                  <del>const key_compare& comp = key_compare())</del>
      <del>: <i>c</i>(std::move(cont)), <i>compare</i>(comp) { }</del>
    template&lt;class InputIterator>
      flat_multiset(InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : <i>c</i>(), <i>compare</i>(comp)
        { insert(first, last); }
    template&lt;class InputIterator>
      flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : <i>c</i>(first, last), <i>compare</i>(comp) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_multiset(from_range_t fr, R&& rg)
        : flat_multiset(fr, std::forward&lt;R>(rg), key_compare()) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_multiset(from_range_t, R&& rg, const key_compare& comp)
        : flat_multiset(comp)
        { insert_range(std::forward&lt;R>(rg)); }

[...]

    // [flat.multiset.cons.alloc], constructors with allocators

    template&lt;class Alloc>
      explicit flat_multiset(const Alloc& a);
    template&lt;class Alloc>
      flat_multiset(const key_compare& comp, const Alloc& a);
    <del>template&lt;class Alloc></del>
      <del>flat_multiset(const container_type& cont, const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_multiset(const container_type& cont, const key_compare& comp, const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_multiset(sorted_equivalent_t, const container_type&, const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_multiset(sorted_equivalent_t, const container_type& cont,</del>
                    <del>const key_compare& comp, const Alloc& a);</del>
    template&lt;class InputIterator, class Alloc>
      flat_multiset(InputIterator first, InputIterator last, const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_multiset(InputIterator first, InputIterator last,
                    const key_compare& comp, const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                    const key_compare& comp, const Alloc& a);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
      flat_multiset(from_range_t, R&& rg, const Alloc& a);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
      flat_multiset(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);

[...]

    container_type extract() &&;
    void replace(container_type<del>&&</del>);
    <ins>void replace(sorted_equivalent_t, container_type<del>&&</del>);</ins>

[...]

  };

  <del>template&lt;class KeyContainer, class Compare = less&lt;typename KeyContainer::value_type>></del>
    <del>flat_multiset(KeyContainer, Compare = Compare())</del>
      <del>-> flat_multiset&lt;typename KeyContainer::value_type, Compare, KeyContainer>;</del>
  <del>template&lt;class KeyContainer, class Allocator></del>
    <del>flat_multiset(KeyContainer, Allocator)</del>
      <del>-> flat_multiset&lt;typename KeyContainer::value_type,</del>
                       <del>less&lt;typename KeyContainer::value_type>, KeyContainer>;</del>
  <del>template&lt;class KeyContainer, class Compare, class Allocator></del>
    <del>flat_multiset(KeyContainer, Compare, Allocator)</del>
      <del>-> flat_multiset&lt;typename KeyContainer::value_type, Compare, KeyContainer>;</del>
  <del>template&lt;class KeyContainer, class Compare = less&lt;typename KeyContainer::value_type>></del>
    <del>flat_multiset(sorted_equivalent_t, KeyContainer, Compare = Compare())</del>
      <del>-> flat_multiset&lt;typename KeyContainer::value_type, Compare, KeyContainer>;</del>
  <del>template&lt;class KeyContainer, class Allocator></del>
    <del>flat_multiset(sorted_equivalent_t, KeyContainer, Allocator)</del>
      <del>-> flat_multiset&lt;typename KeyContainer::value_type,</del>
                       <del>less&lt;typename KeyContainer::value_type>, KeyContainer>;</del>
  <del>template&lt;class KeyContainer, class Compare, class Allocator></del>
    <del>flat_multiset(sorted_equivalent_t, KeyContainer, Compare, Allocator)</del>
      <del>-> flat_multiset&lt;typename KeyContainer::value_type, Compare, KeyContainer>;</del>
  template&lt;class InputIterator, class Compare = less&lt;<i>iter-value-type</i>&lt;InputIterator>>>
    flat_multiset(InputIterator, InputIterator, Compare = Compare())
      -> flat_multiset&lt;<i>iter-value-type</i>&lt;InputIterator>, <i>iter-value-type</i>&lt;InputIterator>, Compare>;
  template&lt;class InputIterator, class Compare = less&lt;<i>iter-value-type</i>&lt;InputIterator>>>
    flat_multiset(sorted_equivalent_t, InputIterator, InputIterator, Compare = Compare())
      -> flat_multiset&lt;<i>iter-value-type</i>&lt;InputIterator>, <i>iter-value-type</i>&lt;InputIterator>, Compare>;
  template&lt;ranges::input_range R, class Compare = less&lt;ranges::range_value_t&lt;R>>,
           class Allocator = allocator&lt;ranges::range_value_t&lt;R>>>
    flat_multiset(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
      -> flat_multiset&lt;ranges::range_value_t&lt;R>, Compare,
                       vector&lt;ranges::range_value_t&lt;R>,
                              <i>alloc-rebind</i>&lt;Allocator, ranges::range_value_t&lt;R>>>>;
  template&lt;ranges::input_range R, class Allocator>
    flat_multiset(from_range_t, R&&, Allocator)
      -> flat_multiset&lt;ranges::range_value_t&lt;R>, less&lt;ranges::range_value_t&lt;R>>,
                       vector&lt;ranges::range_value_t&lt;R>,
                              <i>alloc-rebind</i>&lt;Allocator, ranges::range_value_t&lt;R>>>>;
  template&lt;class Key, class Compare = less&lt;Key>>
    flat_multiset(initializer_list&lt;Key>, Compare = Compare())
      -> flat_multiset&lt;Key, Compare>;
  template&lt;class Key, class Compare = less&lt;Key>>
  flat_multiset(sorted_equivalent_t, initializer_list&lt;Key>, Compare = Compare())
      -> flat_multiset&lt;Key, Compare>;
</pre>
</blockquote></small>

Remove the whole of <a href="https://eel.is/c++draft/flat.multiset.cons">[flat.multiset.cons]</a>,
and change <a href="https://eel.is/c++draft/flat.multiset.cons.alloc">[flat.multiset.cons.alloc]</a>, as follows:

<small><blockquote>
<p><del><b>Constructors [flat.multiset.cons]</b></del>

<p><pre>
<del>explicit flat_multiset(container_type cont, const key_compare& comp = key_compare());</del>
</pre>
<p><del>1․ <i>Effects:</i> Initializes `c` with `std::move(cont)` and `compare` with `comp`,
and sorts the range [`begin()`, `end()`) with respect to `compare`.</del>
<p><del>2․ <i>Complexity:</i> Linear in <i>N</i> if `cont` is already sorted with respect to `compare`
and otherwise <i>N</i> log <i>N</i>, where <i>N</i> is the value of `cont.size()` before this call.</del>

<p><b>Constructors with allocators [flat.multiset.cons.alloc]</b>

<p>1․ The constructors in this subclause shall not participate in overload resolution
unless `uses_allocator_v<container_type, Alloc>` is `true`.

<p><pre>
<del>template&lt;class Alloc></del>
  <del>flat_multiset(const container_type& cont, const Alloc& a);</del>
<del>template&lt;class Alloc></del>
  <del>flat_multiset(const container_type& cont, const key_compare& comp, const Alloc& a);</del>
</pre>
<p><del>2․ <i>Effects:</i> Equivalent to `flat_multiset(cont)` and `flat_multiset(cont, comp)`, respectively,
except that `c` is constructed with uses-allocator construction ([allocator.uses.construction]).</del>
<p><del>3․ <i>Complexity:</i> Same as `flat_multiset(cont)` and `flat_multiset(cont, comp)`, respectively.</del>

<p><pre>
<del>template&lt;class Alloc></del>
  <del>flat_multiset(sorted_equivalent_t s, const container_type& cont, const Alloc& a);</del>
<del>template&lt;class Alloc></del>
  <del>flat_multiset(sorted_equivalent_t s, const container_type& cont,</del>
                <del>const key_compare& comp, const Allocator& a);</del>
</pre>
<p><del>4․ <i>Effects:</i> Equivalent to `flat_multiset(s, cont)` and `flat_multiset(s, cont, comp)`, respectively,
except that `c` is constructed with uses-allocator construction ([allocator.uses.construction]).</del>
<p><del>5․ <i>Complexity:</i> Linear.</del>

<p><pre>
template&lt;class Alloc>
  explicit flat_multiset(const Alloc& a);
template&lt;class Alloc>
  flat_multiset(const key_compare& comp, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_multiset(InputIterator first, InputIterator last, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_multiset(InputIterator first, InputIterator last,
                const key_compare& comp, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_multiset(sorted_equivalent_t, InputIterator first, InputIterator last,
                const key_compare& comp, const Alloc& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
  flat_multiset(from_range_t, R&& rg, const Alloc& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
  flat_multiset(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template&lt;class Alloc>
  flat_multiset(initializer_list&lt;value_type> il, const Alloc& a);
template&lt;class Alloc>
  flat_multiset(initializer_list&lt;value_type> il, const key_compare& comp, const Alloc& a);
template&lt;class Alloc>
  flat_multiset(sorted_equivalent_t, initializer_list&lt;value_type> il, const Alloc& a);
template&lt;class Alloc>
  flat_multiset(sorted_equivalent_t, initializer_list&lt;value_type> il,
                const key_compare& comp, const Alloc& a);
</pre>
<p>6․ <i>Effects:</i> Equivalent to the corresponding non-allocator constructors except that `c` is
constructed with uses-allocator construction ([allocator.uses.construction]).
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:

<small><blockquote>
[...]

<p><pre>
container_type extract() &&;
</pre>
<p>10․ <i>Postconditions:</i> `*this` is emptied, even if the function exits via an exception.
<p>11․ <i>Returns:</i> `std::move(c)`.

<p><pre>
void replace(container_type<del>&&</del> cont);
</pre>
<p><ins>x․ <i>Effects:</i> Replaces `c` with `cont`, and sorts the range [`begin()`, `end()`)
with respect to `compare`.</ins>

<p><pre>
<ins>void replace(sorted_equivalent_t, container_type cont);</ins>
</pre>
<p>12․ <i>Preconditions:</i> <del>The elements of `cont` are</del> <ins>`cont` is</ins> sorted with respect to `compare`.
<p>13․ <i>Effects:</i> Equivalent to: `c = std::move(cont);`
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:

<small><blockquote>
<pre>
[...]

    // [flat.set.cons], constructors
    flat_set() : flat_set(key_compare()) { }

    explicit flat_set(const key_compare& comp)
      : c(), compare(comp) { }

    <del>explicit flat_set(container_type cont, const key_compare& comp = key_compare());</del>

    <del>flat_set(sorted_unique_t, container_type cont,</del>
                  <del>const key_compare& comp = key_compare())</del>
      <del>: <i>c</i>(std::move(cont)), <i>compare</i>(comp) { }</del>

    template&lt;class InputIterator>
      flat_set(InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : <i>c</i>(), <i>compare</i>(comp)
        { insert(first, last); }

    template&lt;class InputIterator>
      flat_set(sorted_unique_t, InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : <i>c</i>(first, last), <i>compare</i>(comp) { }

    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_set(from_range_t fr, R&& rg)
        : flat_set(fr, std::forward&lt;R>(rg), key_compare()) { }
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_set(from_range_t, R&& rg, const key_compare& comp)
        : flat_set(comp)
        { insert_range(std::forward&lt;R>(rg)); }

[...]

    // [flat.set.cons.alloc], constructors with allocators

    template&lt;class Alloc>
      explicit flat_set(const Alloc& a);
    template&lt;class Alloc>
      flat_set(const key_compare& comp, const Alloc& a);
    <del>template&lt;class Alloc></del>
      <del>flat_set(const container_type& cont, const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_set(const container_type& cont, const key_compare& comp, const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_set(sorted_unique_t, const container_type&, const Alloc& a);</del>
    <del>template&lt;class Alloc></del>
      <del>flat_set(sorted_unique_t, const container_type& cont,</del>
               <del>const key_compare& comp, const Alloc& a);</del>
    template&lt;class InputIterator, class Alloc>
      flat_set(InputIterator first, InputIterator last, const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_set(InputIterator first, InputIterator last,
               const key_compare& comp, const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_set(sorted_unique_t, InputIterator first, InputIterator last,
               const Alloc& a);
    template&lt;class InputIterator, class Alloc>
      flat_set(sorted_unique_t, InputIterator first, InputIterator last,
               const key_compare& comp, const Alloc& a);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
      flat_set(from_range_t, R&& rg, const Alloc& a);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
      flat_set(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);

[...]

    container_type extract() &&;
    void replace(container_type<del>&&</del>);
    <ins>void replace(sorted_unique_t, container_type<del>&&</del>);</ins>

[...]

  };

  <del>template&lt;class KeyContainer, class Compare = less&lt;typename KeyContainer::value_type>></del>
    <del>flat_set(KeyContainer, Compare = Compare())</del>
      <del>-> flat_set&lt;typename KeyContainer::value_type, Compare, KeyContainer>;</del>
  <del>template&lt;class KeyContainer, class Allocator></del>
    <del>flat_set(KeyContainer, Allocator)</del>
      <del>-> flat_set&lt;typename KeyContainer::value_type,</del>
                  <del>less&lt;typename KeyContainer::value_type>, KeyContainer>;</del>
  <del>template&lt;class KeyContainer, class Compare, class Allocator></del>
    <del>flat_set(KeyContainer, Compare, Allocator)</del>
      <del>-> flat_set&lt;typename KeyContainer::value_type, Compare, KeyContainer>;</del>
  <del>template&lt;class KeyContainer, class Compare = less&lt;typename KeyContainer::value_type>></del>
    <del>flat_set(sorted_unique_t, KeyContainer, Compare = Compare())</del>
      <del>-> flat_set&lt;typename KeyContainer::value_type, Compare, KeyContainer>;</del>
  <del>template&lt;class KeyContainer, class Allocator></del>
    <del>flat_set(sorted_unique_t, KeyContainer, Allocator)</del>
      <del>-> flat_set&lt;typename KeyContainer::value_type,</del>
                  <del>less&lt;typename KeyContainer::value_type>, KeyContainer>;</del>
  <del>template&lt;class KeyContainer, class Compare, class Allocator></del>
    <del>flat_set(sorted_unique_t, KeyContainer, Compare, Allocator)</del>
      <del>-> flat_set&lt;typename KeyContainer::value_type, Compare, KeyContainer>;</del>
  template&lt;class InputIterator, class Compare = less&lt;<i>iter-value-type</i>&lt;InputIterator>>>
    flat_set(InputIterator, InputIterator, Compare = Compare())
      -> flat_set&lt;<i>iter-value-type</i>&lt;InputIterator>, Compare>;
  template&lt;class InputIterator, class Compare = less&lt;<i>iter-value-type</i>&lt;InputIterator>>>
    flat_set(sorted_unique_t, InputIterator, InputIterator, Compare = Compare())
      -> flat_set&lt;<i>iter-value-type</i>&lt;InputIterator>, Compare>;
  template&lt;ranges::input_range R, class Compare = less&lt;ranges::range_value_t&lt;R>>,
           class Allocator = allocator&lt;ranges::range_value_t&lt;R>>>
    flat_set(from_range_t, R&&, Compare = Compare(), Allocator = Allocator())
      -> flat_set&lt;ranges::range_value_t&lt;R>, Compare,
                  vector&lt;ranges::range_value_t&lt;R>,
                         <i>alloc-rebind</i>&lt;Allocator, ranges::range_value_t&lt;R>>>>;
  template&lt;ranges::input_range R, class Allocator>
    flat_set(from_range_t, R&&, Allocator)
      -> flat_set&lt;ranges::range_value_t&lt;R>, less&lt;ranges::range_value_t&lt;R>>,
                  vector&lt;ranges::range_value_t&lt;R>,
                         <i>alloc-rebind</i>&lt;Allocator, ranges::range_value_t&lt;R>>>>;
  template&lt;class Key, class Compare = less&lt;Key>>
    flat_set(initializer_list&lt;Key>, Compare = Compare())
      -> flat_set&lt;Key, Compare>;
  template&lt;class Key, class Compare = less&lt;Key>>
    flat_set(sorted_unique_t, initializer_list&lt;Key>, Compare = Compare())
      -> flat_set&lt;Key, Compare>;
</pre>
</blockquote></small>

Remove the whole of <a href="https://eel.is/c++draft/flat.set.cons">[flat.set.cons]</a>,
and change <a href="https://eel.is/c++draft/flat.set.cons.alloc">[flat.set.cons.alloc]</a> as follows:

<small><blockquote>
<del><b>Constructors [flat.set.cons]</b></del>

<p><pre>
<del>explicit flat_set(container_type cont, const key_compare& comp = key_compare());</del>
</pre>
<p><del>1․ <i>Effects:</i> Initializes `c` with `std::move(cont)` and `compare` with `comp`,
sorts the range [`begin()`, `end()`) with respect to `compare`, and finally erases all but the first element
from each group of consecutive equivalent elements.</del>
<p><del>2․ <i>Complexity:</i> Linear in <i>N</i> if `cont` is already sorted with respect to `compare`
and otherwise <i>N</i> log <i>N</i>, where <i>N</i> is the value of `cont.size()` before this call.</del>

<p><b>Constructors with allocators [flat.set.cons.alloc]</b>

<p>1․ The constructors in this subclause shall not participate in overload resolution
unless `uses_allocator_v<container_type, Alloc>` is `true`.
<p><pre>
<del>template&lt;class Alloc></del>
  <del>flat_set(const container_type& cont, const Alloc& a);</del>
<del>template&lt;class Alloc></del>
  <del>flat_set(const container_type& cont, const key_compare& comp, const Alloc& a);</del>
</pre>
<p><del>2․ <i>Effects:</i> Equivalent to `flat_set(cont)` and `flat_set(cont, comp)`, respectively,
except that `c` is constructed with uses-allocator construction ([allocator.uses.construction]).</del>
<p><del>3․ <i>Complexity:</i> Same as `flat_set(cont)` and `flat_set(cont, comp)`, respectively.</del>

<p><pre>
<del>template&lt;class Alloc></del>
  <del>flat_set(sorted_unique_t s, const container_type& cont, const Alloc& a);</del>
<del>template&lt;class Alloc></del>
  <del>flat_set(sorted_unique_t s, const container_type& cont,</del>
           <del>const key_compare& comp, const Alloc& a);</del>
</pre>
<p><del>4․ <i>Effects:</i> Equivalent to `flat_set(s, cont)` and `flat_set(s, cont, comp)`, respectively,
except that `c` is constructed with uses-allocator construction ([allocator.uses.construction]).</del>
<p><del>5․ <i>Complexity:</i> Linear.</del>

<p><pre>
template&lt;class Alloc>
  explicit flat_set(const Alloc& a);
template&lt;class Alloc>
  flat_set(const key_compare& comp, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_set(InputIterator first, InputIterator last, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_set(InputIterator first, InputIterator last, const key_compare& comp, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_set(sorted_unique_t, InputIterator first, InputIterator last, const Alloc& a);
template&lt;class InputIterator, class Alloc>
  flat_set(sorted_unique_t, InputIterator first, InputIterator last,
           const key_compare& comp, const Alloc& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
  flat_set(from_range_t, R&& rg, const Alloc& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc>
  flat_set(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);
template&lt;class Alloc>
  flat_set(initializer_list&lt;value_type> il, const Alloc& a);
template&lt;class Alloc>
  flat_set(initializer_list&lt;value_type> il, const key_compare& comp, const Alloc& a);
template&lt;class Alloc>
  flat_set(sorted_unique_t, initializer_list&lt;value_type> il, const Alloc& a);
template&lt;class Alloc>
  flat_set(sorted_unique_t, initializer_list&lt;value_type> il,
           const key_compare& comp, const Alloc& a);
</pre>
<p>6․ <i>Effects:</i> Equivalent to the corresponding non-allocator constructors
except that `c` is constructed with uses-allocator construction ([allocator.uses.construction]).
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.modifiers">[flat.set.modifiers]</a> as follows:

<small><blockquote>
[...]

<p><pre>
container_type extract() &&;
</pre>
<p>14․ <i>Postconditions:</i> `*this` is emptied, even if the function exits via an exception.
<p>15․ <i>Returns:</i> `std::move(c)`.

<p><pre>
void replace(container_type<del>&&</del> cont);
</pre>
<p><ins>x․ <i>Effects:</i> Replaces `c` with `cont`; sorts the range [`begin()`, `end()`)
with respect to `compare`; and finally erases all but the first element from each group of
consecutive equivalent elements.</ins>

<p><pre>
<ins>void replace(sorted_unique_t, container_type cont);</ins>
</pre>
<p>16․ <i>Preconditions:</i> <del>The elements of `cont` are</del> <ins>`cont` is</ins> sorted with respect to `compare`, and `cont` contains no
<del>equal</del> <ins>equivalent</ins> elements.
<p>17․ <i>Effects:</i> Equivalent to: `c = std::move(cont);`
</blockquote></small>


# Implementation experience # {#experience}

I have implemented all of [[P0429]]/[[P1222]] and all of this proposal
as a series of patches against libc++ trunk; see [[Patch]].
You can experiment with it <a href="https://godbolt.org/z/Trneaj4Mo">on Godbolt Compiler Explorer</a>;
just use the P1144 branch of Clang, which uses Arthur's patched libc++ by default.


# Acknowledgments # {#acknowledgments}

- Thanks to Tomasz Kamiński for recommending Arthur write this paper.

- Thanks to Louis Dionne for his code review of libc++'s `flat_set` implementation.


<pre class=biblio>
{
  "LWG2227": {
    "title": "Stateful comparison objects in associative containers",
    "authors": [
      "Juan Soulie"
    ],
    "href": "https://cplusplus.github.io/LWG/issue2227",
    "date": "December 2012"
  },
  "LWG3786": {
    "title": "Flat maps' deduction guide needs to default Allocator to be useful",
    "authors": [
      "Johel Ernesto Guerrero Peña"
    ],
    "href": "https://cplusplus.github.io/LWG/issue3786",
    "date": "September 2022"
  },
  "LWG3802": {
    "title": "flat_foo allocator-extended constructors lack move semantics",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/LWG/issue3802",
    "date": "October 2022"
  },
  "LWG3803": {
    "title": "flat_foo constructors taking KeyContainer lack KeyCompare parameter",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/LWG/issue3803",
    "date": "October 2022"
  },
  "LWG3804": {
    "title": "flat_foo missing some allocator-extended deduction guides",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/LWG/issue3804",
    "date": "October 2022"
  },
  "LWG3884": {
    "title": "flat_foo is missing allocator-extended copy/move constructors",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/LWG/issue3884",
    "date": "February 2023"
  },
  "LWG4000": {
    "title": "flat_map::insert_range's Effects is not quite right",
    "authors": [
      "Hewill Kang"
    ],
    "href": "https://cplusplus.github.io/LWG/issue4000",
    "date": "October 2023"
  },
  "P0429": {
    "title": "A standard flat_map",
    "authors": [
      "Zach Laine"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf",
    "date": "June 2022"
  },
  "P1163": {
    "title": "Explicitly implicifying explicit constructors",
    "authors": [
      "Nevin Liber"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1163r0.pdf",
    "date": "August 2018"
  },
  "P1222": {
    "title": "A standard flat_set",
    "authors": [
      "Zach Laine"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf",
    "date": "June 2022"
  },
  "P2363": {
    "title": "Extending associative containers with the remaining heterogeneous overloads",
    "authors": [
      "Konstantin Boyarinov",
      "Sergey Vinogradov",
      "Ruslan Arutyunyan"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html",
    "date": "February 2023"
  },
  "Patch": {
    "title": "[libc++] trivially_relocatable branch",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://github.com/Quuxplusone/llvm-project/compare/main...trivially-relocatable",
    "date": "May 2023"
  }
}
</pre>
