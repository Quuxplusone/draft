<pre class='metadata'>
Title: flat_map/flat_set omnibus
Shortname: D2767
Revision: 0
!Draft Revision: 5
Audience: LWG
Status: D
Group: WG21
URL:
!Current Source: <a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d2767-flat-omnibus.bs">github.com/Quuxplusone/draft/blob/gh-pages/d2767-flat-omnibus.bs</a>
!Current: <a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d2767-flat-omnibus.html">rawgit.com/Quuxplusone/draft/gh-pages/d2767-flat-omnibus.html</a>
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  Dummy text
Date: 2023-05-09
</pre>

<style>
hilite  {background-color: #FFFF00; font-weight: bold;}
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
src  {background-color: #FFDDFF; text-decoration: line-through;}
dst  {background-color: #CCFFEE; text-decoration: underline;}
</style>

# Changelog # {#changelog}

- R0:

    - Initial draft.

# Introduction # {#intro}

Arthur has implemented all of [[P0429]] `flat_map` and [[P1222]] `flat_set` for libc++.
As he implemented them, he and Louis Dionne collected issues that libc++ would like to see resolved
by LWG. This paper presents all of these issues together in one place, along with Arthur's proposed
solutions for each one.

Some of the proposed solutions are LEWG-level design changes. Contrariwise, some of the issues collected
here don't have "solutions" at all, but are recorded merely For Your Information (for other vendors/implementors)
to document the design choices libc++ has made.

Arthur also proposes a major editorial change to the presentation order of [flat.foo.cons], to collect
the allocator-extended constructors in one place, consistent with <a href="https://eel.is/c++draft/priority.queue#priqueue.cons.alloc">[priqueue.cons.alloc]</a>,
<a href="https://eel.is/c++draft/queue#cons.alloc">[queue.cons.alloc]</a>, and <a href="https://eel.is/c++draft/stack#cons.alloc">[stack.cons.alloc]</a>.

# Editorial introduction of [flat.foo.cons.alloc] # {#editorial-cons-alloc}

This editorial change was originally submitted as <a href="https://github.com/cplusplus/draft/pull/5923">#5923</a>
(October 2022). It bit-rotted after the resolutions of LWG 3802/3803. Here is a clean rebased copy, with easier-to-review
formatting.

This wording merge-conflicts with the resolution of [[LWG3884]]. See [[#clean-copy]]
for a complete diff of everything proposed in this paper and all outstanding LWG issues.

The only changes happening in this part, and their rationales, are:

- Move all of the allocator-extended constructors down to the end of [flat.foo.cons].
    - Ease of reading.
    - Consistency with `priority_queue`, `queue`, `stack`.

- Introduce a new subsection, [flat.foo.cons.alloc], to hold just those constructors.
    - Consistency with [priqueue.cons.alloc], [queue.cons.alloc], [stack.cons.alloc].

- Rename the template parameter `Allocator` to `Alloc`, in every case.
    - Consistency with `priority_queue`, `queue`, `stack`; all of which use the name `Alloc`.
    - This parameter could be an allocator (e.g. `std::pmr::polymorphic_allocator<int>`,
        or it could be a non-allocator (e.g. `std::pmr::memory_resource*`) which is nevertheless
        convertible to an allocator type. The `uses_allocator_v` constraint makes this work.
    - No blanket wording is activated nor deactivated by this name change.

Text is marked as <del>deleted</del>, <ins>inserted</ins>, or <src>moved</src> <dst>moved</dst>.

## [flat.map] ## {#editorial-flat-map-cons-alloc}

<small><blockquote>
<b>24.6.9.2 Definition [flat.map.defn]</b>

<pre>
[...]
    struct containers {
      key_container_type keys;
      mapped_container_type values;
    };

    // [flat.map.cons], <del>construct/copy/destroy</del> <ins>constructors</ins>
    flat_map() : flat_map(key_compare()) { }

    flat_map(key_container_type key_cont, mapped_container_type mapped_cont,
             const key_compare& comp = key_compare());
    <src>template&lt;class Allocator></src>
      <src>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</src>
               <mov>const Allocator& a);</src>
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</src>
               <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>

    flat_map(sorted_unique_t, key_container_type key_cont, mapped_container_type mapped_cont,
             const key_compare& comp = key_compare());
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_map(sorted_unique_t, const key_container_type& key_cont,</src>
               <src>const mapped_container_type& mapped_cont, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_map(sorted_unique_t, const key_container_type& key_cont,</src>
               <src>const mapped_container_type& mapped_cont,</src>
               <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>

    explicit flat_map(const key_compare& comp)
      : c(), compare(comp) { }
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_map(const key_compare& comp, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>explicit flat_map(const Alloc<del>ator</del>& a);</src>

    template&lt;class InputIterator>
      flat_map(InputIterator first, InputIterator last, const key_compare& comp = key_compare())
        : c(), compare(comp) { insert(first, last); }
    <src>template&lt;class InputIterator, class Alloc<del>ator</del>></src>
      <src>flat_map(InputIterator first, InputIterator last,</src>
               <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class InputIterator, class Alloc<del>ator</del>></src>
      <src>flat_map(InputIterator first, InputIterator last, const Alloc<del>ator</del>& a);</src>

    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_map(from_range_t fr, R&& rg)
        : flat_map(fr, std::forward&lt;R>(rg), key_compare()) { }
    <src>template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc<del>ator</del>></src>
      <src>flat_map(from_range_t, R&& rg, const Alloc<del>ator</del>& a);</src>
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      flat_map(from_range_t, R&& rg, const key_compare& comp)
        : flat_map(comp) { insert_range(std::forward&lt;R>(rg)); }
    <src>template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc<del>ator</del>></src>
      <src>flat_map(from_range_t, R&& rg, const key_compare& comp, const Alloc<del>ator</del>& a);</src>

    template&lt;class InputIterator>
      flat_map(sorted_unique_t s, InputIterator first, InputIterator last,
               const key_compare& comp = key_compare())
        : c(), compare(comp) { insert(s, first, last); }
    <src>template&lt;class InputIterator, class Alloc<del>ator</del>></src>
      <src>flat_map(sorted_unique_t, InputIterator first, InputIterator last,</src>
               <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class InputIterator, class Alloc<del>ator</del>></src>
      <src>flat_map(sorted_unique_t, InputIterator first, InputIterator last, const Alloc<del>ator</del>& a);</src>

    flat_map(initializer_list&lt;value_type> il, const key_compare& comp = key_compare())
        : flat_map(il.begin(), il.end(), comp) { }
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_map(initializer_list&lt;value_type> il, const key_compare& comp, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_map(initializer_list&lt;value_type> il, const Alloc<del>ator</del>& a);</src>

    flat_map(sorted_unique_t s, initializer_list&lt;value_type> il,
             const key_compare& comp = key_compare())
        : flat_map(s, il.begin(), il.end(), comp) { }
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_map(sorted_unique_t, initializer_list&lt;value_type> il,</src>
               <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_map(sorted_unique_t, initializer_list&lt;value_type> il, const Alloc<del>ator</del>& a);</src>

    <ins>// [flat.map.cons.alloc], constructors with allocators</ins>

    <dst>template&lt;class Alloc></dst>
      <dst>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</dst>
               <dst>const Alloc& a);</dst>  
    <dst>template&lt;class Alloc></dst>
      <dst>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</dst>
               <dst>const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_map(sorted_unique_t, const key_container_type& key_cont,</dst>
               <dst>const mapped_container_type& mapped_cont, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_map(sorted_unique_t, const key_container_type& key_cont,</dst>
               <dst>const mapped_container_type& mapped_cont,</dst>
               <dst>const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_map(const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>explicit flat_map(const Alloc& a);</dst>
    <dst>template&lt;class InputIterator, class Alloc></dst>
      <dst>flat_map(InputIterator first, InputIterator last,</dst>
               <dst>const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class InputIterator, class Alloc></dst>
      <dst>flat_map(InputIterator first, InputIterator last, const Alloc& a);</dst>
    <dst>template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc></dst>
      <dst>flat_map(from_range_t, R&& rg, const Alloc& a);</dst>
    <dst>template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc></dst>
      <dst>flat_map(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class InputIterator, class Alloc></dst>
      <dst>flat_map(sorted_unique_t, InputIterator first, InputIterator last,</dst>
               <dst>const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class InputIterator, class Alloc></dst>
      <dst>flat_map(sorted_unique_t, InputIterator first, InputIterator last, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_map(initializer_list&lt;value_type> il, const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_map(initializer_list&lt;value_type> il, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_map(sorted_unique_t, initializer_list&lt;value_type> il,</dst>
               <dst>const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_map(sorted_unique_t, initializer_list&lt;value_type> il, const Alloc& a);</dst>

    flat_map& operator=(initializer_list&lt;value_type> il);

    // iterators
[...]
</pre>

<b>24.6.9.3 Constructors [flat.map.cons]</b>

<pre>
flat_map(key_container_type key_cont, mapped_container_type mapped_cont,
         const key_compare& comp = key_compare());
</pre>

1․ Effects: Initializes `c.keys` with `std::move(key_cont)`, `c.values` with `std::move(mapped_cont)`, and `compare` with `comp`;
sorts the range [`begin()`, `end()`) with respect to `value_comp()`; and finally erases the duplicate elements as if by:
<pre>
auto zv = ranges::zip_view(c.keys, c.values);
auto it = ranges::unique(zv, key_equiv(compare)).begin();
auto dist = distance(zv.begin(), it);
c.keys.erase(c.keys.begin() + dist, c.keys.end());
c.values.erase(c.values.begin() + dist, c.values.end());
</pre>

2․ Complexity: Linear in N if the container arguments are already sorted with respect to `value_comp()` and otherwise N log N,
where N is the value of `key_cont.size()` before this call.

<pre>
<src>template&lt;class Alloc<del>ator</del>></src>
  <src>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</src>
           <src>const Alloc<del>ator</del>& a);</src>
<src>template&lt;class Alloc<del>ator</del>></src>
  <src>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</src>
           <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>
</pre>

<del>3․ Constraints: `uses_allocator_v<key_container_type, Allocator>` is `true` and `uses_allocator_v<mapped_container_type, Allocator>` is `true`.</del>

<p><src>4․ Effects: Equivalent to `flat_map(key_cont, mapped_cont)` and `flat_map(key_cont, mapped_cont, comp)`, respectively,
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).</src>

<p><src>5․ Complexity: Same as `flat_map(key_cont, mapped_cont)` and `flat_map(key_cont, mapped_cont, comp)`, respectively.</src>

<pre>
flat_map(sorted_unique_t, key_container_type key_cont, mapped_container_type mapped_cont,
         const key_compare& comp = key_compare());
</pre>

6․ Effects: Initializes `c.keys` with `std::move(key_cont)`, `c.values` with `std::move(mapped_cont)`, and `compare` with `comp`.

7․ Complexity: Constant.

<ins><b>24.6.9.x Constructors with allocators [flat.map.cons.alloc]</b></ins>

<p><ins>x․ The constructors in this subclause shall not participate in overload resolution unless
`uses_allocator_v<key_container_type, Alloc>` is `true` and `uses_allocator_v<mapped_container_type, Alloc>` is `true`.</ins>

<pre>
<dst>template&lt;class Alloc></dst>
  <dst>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</dst>
           <dst>const Alloc& a);</dst>
<dst>template&lt;class Alloc></dst>
  <dst>flat_map(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</dst>
           <dst>const key_compare& comp, const Alloc& a);</dst>
</pre>

<p><dst>4․ Effects: Equivalent to `flat_map(key_cont, mapped_cont)` and `flat_map(key_cont, mapped_cont, comp)`, respectively,
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).</dst>

<p><dst>5․ Complexity: Same as `flat_map(key_cont, mapped_cont)` and `flat_map(key_cont, mapped_cont, comp)`, respectively.</dst>

<pre>
template&lt;class Alloc<del>ator</del>>
  flat_map(sorted_unique_t s, const key_container_type& key_cont,
           const mapped_container_type& mapped_cont, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  flat_map(sorted_unique_t s, const key_container_type& key_cont,
           const mapped_container_type& mapped_cont, const key_compare& comp,
           const Alloc<del>ator</del>& a);
</pre>

<del>8․ Constraints: `uses_allocator_v<key_container_type, Allocator>` is `true` and `uses_allocator_v<mapped_container_type, Allocator>` is `true`.</del>

9․ Effects: Equivalent to `flat_map(s, key_cont, mapped_cont)` and `flat_map(s, key_cont, mapped_cont, comp)`, respectively,
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).

10․ Complexity: Linear.

<pre>
template&lt;class Alloc<del>ator</del>>
  flat_map(const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  explicit flat_map(const Alloc<del>ator</del>& a);
template&lt;class InputIterator, class Alloc<del>ator</del>>
  flat_map(InputIterator first, InputIterator last, const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class InputIterator, class Alloc<del>ator</del>>
  flat_map(InputIterator first, InputIterator last, const Alloc<del>ator</del>& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc<del>ator</del>>
  flat_map(from_range_t, R&& rg, const Alloc<del>ator</del>& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc<del>ator</del>>
  flat_map(from_range_t, R&& rg, const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class InputIterator, class Alloc<del>ator</del>>
  flat_map(sorted_unique_t, InputIterator first, InputIterator last,
           const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class InputIterator, class Alloc<del>ator</del>>
  flat_map(sorted_unique_t, InputIterator first, InputIterator last, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  flat_map(initializer_list&lt;value_type> il, const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  flat_map(initializer_list&lt;value_type> il, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  flat_map(sorted_unique_t, initializer_list&lt;value_type> il,
           const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  flat_map(sorted_unique_t, initializer_list&lt;value_type> il, const Alloc<del>ator</del>& a);
</pre>

<del>11․ Constraints: `uses_allocator_v<key_container_type, Allocator>` is `true` and `uses_allocator_v<mapped_container_type, Allocator>` is `true`.</del>

12․ Effects: Equivalent to the corresponding non-allocator constructors except that `c.keys` and `c.values` are constructed
with uses-allocator construction ([allocator.uses.construction]).
</blockquote></small>

## [flat.multimap] ## {#editorial-flat-multimap-cons-alloc}

<small><blockquote>
<b>24.6.10.2 Definition [flat.multimap.defn]</b>

<pre>
[...]
    struct containers {
      key_container_type keys;
      mapped_container_type values;
    };

    // [flat.multimap.cons], <del>construct/copy/destroy</del> <ins>constructors</ins>
    flat_multimap() : flat_multimap(key_compare()) { }

    flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,
                  const key_compare& comp = key_compare());
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</src>
                    <src>const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</src>
                    <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>

    flat_multimap(sorted_equivalent_t,
                  key_container_type key_cont, mapped_container_type mapped_cont,
                  const key_compare& comp = key_compare());
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_multimap(sorted_equivalent_t, const key_container_type& key_cont,</src>
                    <src>const mapped_container_type& mapped_cont, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_multimap(sorted_equivalent_t, const key_container_type& key_cont,</src>
                    <src>const mapped_container_type& mapped_cont,</src>
                    <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>

    explicit flat_multimap(const key_compare& comp)
      : c(), compare(comp) { }
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_multimap(const key_compare& comp, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>explicit flat_multimap(const Alloc<del>ator</del>& a);</src>

    template&lt;class InputIterator>
      flat_multimap(InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : c(), compare(comp)
        { insert(first, last); }
    <src>template&lt;class InputIterator, class Alloc<del>ator</del>></src>
      <src>flat_multimap(InputIterator first, InputIterator last,</src>
                    <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class InputIterator, class Alloc<del>ator</del>></src>
      <src>flat_multimap(InputIterator first, InputIterator last, const Alloc<del>ator</del>& a);</src>

    template&lt;container-compatible-range&lt;value_type> R>
      flat_multimap(from_range_t fr, R&& rg)
        : flat_multimap(fr, std::forward&lt;R>(rg), key_compare()) { }
    <src>template&lt;container-compatible-range&lt;value_type> R, class Alloc<del>ator</del>></src>
      <src>flat_multimap(from_range_t, R&& rg, const Alloc<del>ator</del>& a);</src>
    template&lt;container-compatible-range&lt;value_type> R>
      flat_multimap(from_range_t, R&& rg, const key_compare& comp)
        : flat_multimap(comp) { insert_range(std::forward&lt;R>(rg)); }
    <src>template&lt;container-compatible-range&lt;value_type> R, class Alloc<del>ator</del>></src>
      <src>flat_multimap(from_range_t, R&& rg, const key_compare& comp, const Alloc<del>ator</del>& a);</src>

    template&lt;class InputIterator>
      flat_multimap(sorted_equivalent_t s, InputIterator first, InputIterator last,
                    const key_compare& comp = key_compare())
        : c(), compare(comp) { insert(s, first, last); }
    <src>template&lt;class InputIterator, class Alloc<del>ator</del>></src>
      <src>flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,</src>
                    <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class InputIterator, class Alloc<del>ator</del>></src>
      <src>flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,</src>
                    <src>const Alloc<del>ator</del>& a);</src>

    flat_multimap(initializer_list&lt;value_type> il, const key_compare& comp = key_compare())
        : flat_multimap(il.begin(), il.end(), comp) { }
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_multimap(initializer_list&lt;value_type> il, const key_compare& comp,</src>
                    <src>const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_multimap(initializer_list&lt;value_type> il, const Alloc<del>ator</del>& a);</src>

    flat_multimap(sorted_equivalent_t s, initializer_list&lt;value_type> il,
                  const key_compare& comp = key_compare())
        : flat_multimap(s, il.begin(), il.end(), comp) { }
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_multimap(sorted_equivalent_t, initializer_list&lt;value_type> il,</src>
                    <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>
    <src>template&lt;class Alloc<del>ator</del>></src>
      <src>flat_multimap(sorted_equivalent_t, initializer_list&lt;value_type> il, const Alloc<del>ator</del>& a);</src>

    <ins>// [flat.multimap.cons.alloc], constructors with allocators</ins>

    <dst>template&lt;class Alloc></dst>
      <dst>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</dst>
                    <dst>const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</dst>
                    <dst>const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_multimap(sorted_equivalent_t, const key_container_type& key_cont,</dst>
                    <dst>const mapped_container_type& mapped_cont, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_multimap(sorted_equivalent_t, const key_container_type& key_cont,</dst>
                    <dst>const mapped_container_type& mapped_cont,</dst>
                    <dst>const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_multimap(const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>explicit flat_multimap(const Alloc& a);</dst>
    <dst>template&lt;class InputIterator, class Alloc></dst>
      <dst>flat_multimap(InputIterator first, InputIterator last,</dst>
                    <dst>const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class InputIterator, class Alloc></dst>
      <dst>flat_multimap(InputIterator first, InputIterator last, const Alloc& a);</dst>
    <dst>template&lt;container-compatible-range&lt;value_type> R, class Alloc></dst>
      <dst>flat_multimap(from_range_t, R&& rg, const Alloc& a);</dst>
    <dst>template&lt;container-compatible-range&lt;value_type> R, class Alloc></dst>
      <dst>flat_multimap(from_range_t, R&& rg, const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class InputIterator, class Alloc></dst>
      <dst>flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,</dst>
                    <dst>const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class InputIterator, class Alloc></dst>
      <dst>flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,</dst>
                    <dst>const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_multimap(initializer_list&lt;value_type> il, const key_compare& comp,</dst>
                    <dst>const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_multimap(initializer_list&lt;value_type> il, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_multimap(sorted_equivalent_t, initializer_list&lt;value_type> il,</dst>
                    <dst>const key_compare& comp, const Alloc& a);</dst>
    <dst>template&lt;class Alloc></dst>
      <dst>flat_multimap(sorted_equivalent_t, initializer_list&lt;value_type> il, const Alloc& a);</dst>

    flat_multimap& operator=(initializer_list&lt;value_type> il);

    // iterators
[...]
</pre>

<b>24.6.10.3 Constructors [flat.multimap.cons]</b>

<pre>
flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,
              const key_compare& comp = key_compare());
</pre>

1․ Effects: Initializes `c.keys` with `std::move(key_cont)`, `c.values` with `std::move(mapped_cont)`,
and `compare` with `comp`; sorts the range [`begin()`, `end()`) with respect to `value_comp()`.

2․ Complexity: Linear in N if the container arguments are already sorted with respect to `value_comp()` and otherwise N log N,
where N is the value of `key_cont.size()` before this call.

<pre>
<src>template&lt;class Alloc<del>ator</del>></src>
  <src>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</src>
                <src>const Alloc<del>ator</del>& a);</src>
<src>template&lt;class Alloc<del>ator</del>></src>
  <src>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</src>
                <src>const key_compare& comp, const Alloc<del>ator</del>& a);</src>
</pre>

<del>3․ Constraints: `uses_allocator_v<key_container_type, Allocator>` is `true` and `uses_allocator_v<mapped_container_type, Allocator>` is `true`.</del>

<p><src>4․ Effects: Equivalent to `flat_multimap(key_cont, mapped_cont)` and `flat_multimap(key_cont, mapped_cont, comp)`, respectively,
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).</src>

<p><src>5․ Complexity: Same as `flat_multimap(key_cont, mapped_cont)` and `flat_multimap(key_cont, mapped_cont, comp)`, respectively.</src>

<pre>
flat_multimap(sorted_equivalent_t, key_container_type key_cont, mapped_container_type mapped_cont,
              const key_compare& comp = key_compare());
</pre>

6․ Effects: Initializes `c.keys` with `std::move(key_cont)`, `c.values` with `std::move(mapped_cont)`, and `compare` with `comp`.

7․ Complexity: Constant.

<ins><b>24.6.10.x Constructors with allocators [flat.map.cons.alloc]</b></ins>

<p><ins>x․ The constructors in this subclause shall not participate in overload resolution unless
`uses_allocator_v<key_container_type, Alloc>` is `true` and `uses_allocator_v<mapped_container_type, Alloc>` is `true`.</ins>

<pre>
<dst>template&lt;class Alloc></dst>
  <dst>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</dst>
           <dst>const Alloc& a);</dst>
<dst>template&lt;class Alloc></dst>
  <dst>flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,</dst>
           <dst>const key_compare& comp, const Alloc& a);</dst>
</pre>

<p><dst>4․ Effects: Equivalent to `flat_multimap(key_cont, mapped_cont)` and `flat_multimap(key_cont, mapped_cont, comp)`, respectively,
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).</dst>

<p><dst>5․ Complexity: Same as `flat_multimap(key_cont, mapped_cont)` and `flat_multimap(key_cont, mapped_cont, comp)`, respectively.</dst>

<pre>
template&lt;class Alloc<del>ator</del>>
  flat_multimap(sorted_equivalent_t s, const key_container_type& key_cont,
                const mapped_container_type& mapped_cont, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  flat_multimap(sorted_equivalent_t s, const key_container_type& key_cont,
                const mapped_container_type& mapped_cont, const key_compare& comp,
                const Alloc<del>ator</del>& a);
</pre>

<del>8․ Constraints: `uses_allocator_v<key_container_type, Allocator>` is `true` and `uses_allocator_v<mapped_container_type, Allocator>` is `true`.</del>

<p>9․ Effects: Equivalent to `flat_multimap(s, key_cont, mapped_cont)` and `flat_multimap(s, key_cont, mapped_cont, comp)`, respectively,
except that `c.keys` and `c.values` are constructed with uses-allocator construction ([allocator.uses.construction]).

<p>10․ Complexity: Linear.

<pre>
template&lt;class Alloc<del>ator</del>>
  flat_multimap(const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  explicit flat_multimap(const Alloc<del>ator</del>& a);
template&lt;class InputIterator, class Alloc<del>ator</del>>
  flat_multimap(InputIterator first, InputIterator last, const key_compare& comp,
                const Alloc<del>ator</del>& a);
template&lt;class InputIterator, class Alloc<del>ator</del>>
  flat_multimap(InputIterator first, InputIterator last, const Alloc<del>ator</del>& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc<del>ator</del>>
  flat_multimap(from_range_t, R&& rg, const Alloc<del>ator</del>& a);
template&lt;<i>container-compatible-range</i>&lt;value_type> R, class Alloc<del>ator</del>>
  flat_multimap(from_range_t, R&& rg, const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class InputIterator, class Alloc<del>ator</del>>
  flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class InputIterator, class Alloc<del>ator</del>>
  flat_multimap(sorted_equivalent_t, InputIterator first, InputIterator last,
                const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  flat_multimap(initializer_list&lt;value_type> il, const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  flat_multimap(initializer_list&lt;value_type> il, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  flat_multimap(sorted_equivalent_t, initializer_list&lt;value_type> il,
                const key_compare& comp, const Alloc<del>ator</del>& a);
template&lt;class Alloc<del>ator</del>>
  flat_multimap(sorted_equivalent_t, initializer_list&lt;value_type> il, const Alloc<del>ator</del>& a);
</pre>

<del>11․ Constraints: `uses_allocator_v<key_container_type, Allocator>` is `true` and `uses_allocator_v<mapped_container_type, Allocator>` is `true`.</del>

<p>12․ Effects: Equivalent to the corresponding non-allocator constructors except that c.keys and c.values are constructed with uses-allocator
construction ([allocator.uses.construction]).
</blockquote></small>


## [flat.multiset] ## {#editorial-flat-multiset-cons-alloc}

TODO FIXME BUG HACK

## [flat.set] ## {#editorial-flat-set-cons-alloc}

TODO FIXME BUG HACK

# Accidentally explicit constructor # {#explicit-oops}

STL style is that multi-argument constructors should be non-`explicit`; see [[P1163]].
This change is non-editorial, but should be non-controversial, unless anyone objects
to the delegating constructor's doing an extra move of `cont`. In practice, libc++
doesn't actually move `cont` twice; we consider the delegating constructor merely a tool
to shorten the spec.

```c++
    std::vector<int> v;
    std::flat_set s = { v, std::less(), std::allocator<int>() };
      // OK
    std::flat_set s = { v, std::less() };
      // Before: Ill-formed
      // After: OK
```

## Wording ## {#wording-explicit-oops}

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.multiset.cons], constructors
    flat_multiset() : flat_multiset(key_compare()) { }

    <del>explicit flat_multiset(container_type cont, const key_compare& comp = key_compare());</del>
    <ins>explicit flat_multiset(container_type cont)</ins>
      <ins>: flat_multiset(std::move(cont), key_compare()) { }</ins>
    <ins>flat_multiset(container_type cont, const key_compare& comp);</ins>
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.cons">[flat.multiset.cons]</a> as follows:

<small><blockquote>
<pre>
<del>explicit</del> flat_multiset(container_type cont, const key_compare& comp <del>= key_compare()</del>);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.set.cons], constructors
    flat_set() : flat_set(key_compare()) { }

    <del>explicit flat_set(container_type cont, const key_compare& comp = key_compare());</del>
    <ins>explicit flat_set(container_type cont)</ins>
      <ins>: flat_set(std::move(cont), key_compare()) { }</ins>
    <ins>flat_set(container_type cont, const key_compare& comp);</ins>
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.cons">[flat.set.cons]</a> as follows:

<small><blockquote>
<pre>
<del>explicit</del> flat_set(container_type cont, const key_compare& comp <del>= key_compare()</del>);
</pre>
</blockquote></small>

# Add move semantics to `flat_set::insert_range` # {#set-insert-range}

```c++
    std::flat_set<std::string> fs1;
    std::vector<std::string> v1 = {"hello", "world"};
    fs1.insert_range(std::views::as_rvalue(v1));
      // Before: Copies the strings.
      // After: Moves the strings.

    std::flat_set<std::unique_ptr<int>> fs2;
    std::vector<std::unique_ptr<int>> v2;
    fs2.insert_range(std::views::as_rvalue(v2));
      // Before: Ill-formed.
      // After: Moves the unique_ptrs.
```

## Wording ## {#wording-set-insert-range}

Change <a href="https://eel.is/c++draft/flat.set#modifiers-10">[flat.set.modifiers]/10</a> as follows:

<small><blockquote>
<pre>
template&lt;<i>container-compatible-range</i>&lt;value_type> R>
  void insert_range(R&& rg);
</pre>

10․ Effects: Adds elements to `c` as if by:
<pre>
for (<del>const auto&</del> <ins>auto&&</ins> e : rg) {
  c.insert(c.end(), <ins>std::forward&lt;decltype(e)>(</ins>e<ins>)</ins>);
}
</pre>
Then, sorts the range of newly inserted elements with respect to <i>`compare`</i>;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases all but the first element from each group of consecutive equivalent elements.

11․ Complexity: N + M log M, where N is `size()` before the operation and M is <del>`distance(first, last)`</del> <ins>`ranges::distance(rg)`</ins>.

12․ Remarks: Since this operation performs an in-place merge, it may allocate memory.
</blockquote></small>

Add a new section to <a href="https://eel.is/c++draft/flat.multiset#modifiers">[flat.multiset.modifiers]</a>
explaining the semantics of `flat_multiset::insert_range`.

<small><blockquote>
<pre>
<ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
  <ins>void insert_range(R&& rg);</ins>
</pre>

<p><ins>x․ Effects: Adds elements to `c` as if by:</ins>
<pre>
<ins>for (auto&& e : rg) {</ins>
  <ins>c.insert(c.end(), std::forward&lt;decltype(e)>(e));</ins>
<ins>}</ins>
</pre>
<ins>Then, sorts the range of newly inserted elements with respect to <i>`compare`</i>, and
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range.

<p><ins>x․ Complexity: N + M log M, where N is `size()` before the operation and M is `ranges::distance(rg)`.</ins>

<p><ins>x․ Remarks: Since this operation performs an in-place merge, it may allocate memory.</ins>
</blockquote></small>



# Add move semantics to `flat_map::insert_range` # {#map-insert-range}

`flat_map`'s `insert_range` has the same issue as `flat_set`'s, at least on paper.

```c++
    std::flat_map<int, std::unique_ptr<int>> fs2;
    std::vector<std::pair<int, std::unique_ptr<int>>> v2;
    fs2.insert_range(std::views::as_rvalue(v2));
      // Before: Ill-formed.
      // After: Moves the unique_ptrs.
```

However, libc++'s implementation of `flat_map` and `flat_multimap` didn't need
to change — we already "accidentally" support move semantics in the maps' `insert_range` methods,
because we factor out a helper method `__append_pairs` that is used by all three of
`insert(first, last)`, `insert(sorted_unique, first, last)`, and `insert_range(rg)`.
It looks very similar to the specification proposed below.

The current specification says:

```c++
  for (const auto& e : rg) {
    c.keys.insert(c.keys.end(), e.first);
    c.values.insert(c.values.end(), e.second);
  }
```

The `insert_range` method is constrained on <i>`container-compatible-range`</i>`<value_type>`,
i.e. `convertible_to<range_reference_t<R>, value_type>`.
But in fact the current spec's algorithm never attempts to convert `range_reference_t<R>` to `value_type`.
Instead, it implicitly requires that `range_reference_t<R>::first` be convertible to `key_type`
and `range_reference_t<R>::second` be convertible to `mapped_type`. If `range_reference_t<R>` is
something without `first` and `second` members, the current spec doesn't work at all.

```c++
    std::pair<int, int> p1 = {1,2};
    std::reference_wrapper<std::pair<int, int>> a[] = { p1 };
    std::flat_map<int, int> fm;
    fm.insert_range(a);
      // Before: Ill-formed: reference_wrapper has no .first member
      // After: OK
```

## Wording ## {#wording-map-insert-range}

We don't need to touch [flat.multimap.modifiers]; in fact it does not currently exist;
because of <a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview]/4</a>:

<small><blockquote>
4․ Except as otherwise noted, operations on `flat_multimap` are equivalent to those of `flat_map`,
except that `flat_multimap` operations do not remove or replace elements with equal keys.
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.map.modifiers#12">[flat.map.modifiers]/12</a> as follows:

<small><blockquote>
<pre>
template&lt;<i>container-compatible-range</i>&lt;value_type> R>
  void insert_range(R&& rg);
</pre>

12․ Effects: Adds elements to `c` as if by:
<pre>
for (<del>const auto&</del> <ins>value_type</ins> e : rg) {
  c.keys.insert(c.keys.end(), <ins>std::move(</ins>e.first<ins>)</ins>);
  c.values.insert(c.values.end(), <ins>std::move(</ins>e.second<ins>)</ins>);
}
</pre>
Then, sorts the range of newly inserted elements with respect to `value_comp()`;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases the duplicate elements as if by:
<pre>
auto zv = ranges::zip_view(c.keys, c.values);
auto it = ranges::unique(zv, key_equiv(compare)).begin();
auto dist = distance(zv.begin(), it);
c.keys.erase(c.keys.begin() + dist, c.keys.end());
c.values.erase(c.values.begin() + dist, c.values.end());
</pre>

13․ Complexity: N + M log M, where N is `size()` before the operation and M is `ranges::distance(rg)`.

14․ Remarks: Since this operation performs an in-place merge, it may allocate memory.
</blockquote></small>


# `insert` is more primitive than `emplace` # {#insert-emplace}

```c++
    std::pmr::set_default_resource(std::pmr::null_memory_resource());
    std::pmr::monotonic_buffer_resource mr(1'000'000);

    auto fm = PmrFlatSet<std::pmr::string>(&mr);
    std::pmr::string ps("too long to fit in the small string buffer", &mr);
    fm.insert(ps);
      // Before: runtime abort, cannot default-allocate t
      // After: OK
```

Whenever we insert or emplace into a set or multiset, we have two tasks:

- Construct the new `value_type` object.

- Find the correct insertion point for the new object.

`emplace` receives a bag of constructor arguments, so it has no choice: it must do
"construct `t`, find insertion point for `t`, move-insert `t` into the container" exactly as specified above.

But `insert` receives an already-constructed `value_type`! It shouldn't discard that valuable information;
it should use the given `value_type` to find the appropriate insertion point, and then construct the new object
directly in place. There is no reason to construct `t` on the stack first.

## Heterogeneous `multiset::insert` ## {#heterogeneous-insert-multiset}

[[P2363]] <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html#ins">explains</a>
why the node-based `multiset` still lacks a heterogeneous `insert(K&&)`:

> Adding heterogeneous `insert` overload makes no sense for associative containers with non-unique keys (`std::multimap`, `std::multiset`,
> `std::unordered_multimap` and `std::unordered_multiset`) because the insertion will be successful in any case and the key would be always
> constructed. All additional overheads introduced by `insert` can be mitigated by using `emplace`.

For `flat_multiset`, the last sentence is false; generic `emplace` is unusable for PMR allocators, because it
must first construct `t` using the default allocator. Therefore we also propose to add a heterogeneous-comparison
overload of `flat_multiset::insert`.

```c++
    template<class T, class C = std::less<T>>
    using PmrFlatMultiset = std::flat_multiset<T, C, std::pmr::vector<T>>;
 
    std::pmr::monotonic_buffer_resource mr(1'000'000);
    std::pmr::set_default_resource(std::pmr::null_memory_resource());
    const char s[] = "too long to fit in the small string buffer";

    auto m = std::pmr::multiset<std::pmr::string>(&mr);
    m.emplace(s); // OK
    m.insert(s); // runtime abort, cannot default-allocate x

    auto fm = PmrFlatMultiset<std::pmr::string>(&mr);
    fm.emplace(s); // runtime abort, cannot default-allocate t
    fm.insert(s); // runtime abort, cannot default-allocate x

    auto m2 = std::pmr::multiset<std::pmr::string, std::less<>>(&mr);
    m2.emplace(s); // OK
    m2.insert(s); // runtime abort, cannot default-allocate x

    auto fm2 = PmrFlatMultiset<std::pmr::string, std::less<>>(&mr);
    fm2.emplace(s); // runtime abort, cannot default-allocate t
    fm2.insert(s);
      // Before: runtime abort, cannot default-allocate x
      // After: OK
```

Notice the asymmetry between `fm2.insert(s)` and `m2.insert(s)`. Arthur thinks it would be
nice to support heterogeneous `insert` for node-based `multiset` and `unordered_multiset`
(*contra* P2363's reasoning),
but that's out of scope for this particular paper P2767. For P2767's purposes, we're satisfied
once there exists *some* way of inserting `s` into `fm2`. We don't mind that the working approaches
use different spellings: `m2.emplace(s)` versus `fm2.insert(s)`.


## Unusual constraints ## {#emplace-constraint}

The usual pattern in [containers] is that `x.emplace(args...)`
has a precondition (<a href="https://eel.is/c++draft/containers#sequence.reqmts-21">[sequence.reqmts]</a>,
<a href="https://eel.is/c++draft/containers#associative.reqmts.general-48">[associative.reqmts.general]</a>)
but no Constraints element. That is, `emplace` is not SFINAE-friendly. And it has only the one overload,
so it doesn't need a constraint for purposes of overload resolution.

No Constraints on `emplace`:
<a href="https://eel.is/c++draft/deque.modifiers#lib:deque,emplace">`deque`</a>
<a href="https://eel.is/c++draft/list.modifiers">`list`</a>,
<a href="https://eel.is/c++draft/priqueue.members#lib:priority_queue,emplace">`priority_queue`</a>,
<a href="https://eel.is/c++draft/vector.modifiers">`vector`</a>

But these two places have a Constraints element on `emplace`:
<a href="https://eel.is/c++draft/flat.map.modifiers#lib:flat_map,emplace">`flat_map`</a>,
<a href="https://eel.is/c++draft/flat.multiset.modifiers#lib:flat_multiset,emplace">`flat_multiset`</a>.

> Constraints: `is_constructible_v<pair<key_type, mapped_type>, Arg...>` is `true`.

I believe this element was accidentally copy-pasted from the spec of <a href="https://eel.is/c++draft/flat.map.modifiers#4">`flat_map::insert(P&&)`</a> —
which *does* need the constraint because it's part of `insert`'s large overload set — to `flat_map::emplace`,
and then from there to `flat_multiset::emplace`. The constraint is already (correctly) absent
from `flat_set::emplace`.

Therefore, the proposed wording for this section simply deletes those Constraints elements.

## Wording ## {#wording-insert-emplace}

We don't need to touch [flat.multimap.modifiers]; in fact it does not currently exist;
because of <a href="https://eel.is/c++draft/flat.multimap#overview-4">[flat.multimap.overview]/4</a>:

<small><blockquote>
4․ Except as otherwise noted, operations on `flat_multimap` are equivalent to those of `flat_map`, 
except that `flat_multimap` operations do not remove or replace elements with equal keys.
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.map.modifiers], modifiers
    template&lt;class... Args> pair&lt;iterator, bool> emplace(Args&&... args);
    template&lt;class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args);

    pair&lt;iterator, bool> insert(const value_type& x)<ins>;</ins>
      <del>{ return emplace(x); }</del>
    pair&lt;iterator, bool> insert(value_type&& x)<ins>;</ins>
      <del>{ return emplace(std::move(x)); }</del>
    iterator insert(const_iterator position, const value_type& x)<ins>;</ins>
      <del>{ return emplace_hint(position, x); }</del>
    iterator insert(const_iterator position, value_type&& x)<ins>;</ins>
      <del>{ return emplace_hint(position, std::move(x)); }</del>

    template&lt;class P> pair&lt;iterator, bool> insert(P&& x);
    template&lt;class P>
      iterator insert(const_iterator position, P&&);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.map.modifiers">[flat.map.modifiers]</a> as follows:

<small><blockquote>
<pre>
template&lt;class... Args> pair&lt;iterator, bool> emplace(Args&&... args);
</pre>
<del>1․ Constraints: `is_constructible_v<pair<key_type, mapped_type>, Args...>` is `true`.</del>

<p>2․ Effects: Initializes an object `t` of type `pair<key_type, mapped_type>` with `std::forward<Args>(args)...`;
if the map already contains an element whose key is equivalent to `t.first`, `*this` is unchanged. Otherwise, equivalent to:
<pre>
auto key_it = ranges::upper_bound(c.keys, t.first, compare);
auto value_it = c.values.begin() + distance(c.keys.begin(), key_it);
c.keys.insert(key_it, std::move(t.first));
c.values.insert(value_it, std::move(t.second));
</pre>

3․ Returns: The `bool` component of the returned pair is `true` if and only if the insertion took place,
and the iterator component of the pair points to the element with key equivalent to `t.first`.

<pre>
<ins>pair&lt;iterator, bool> insert(const value_type& x);</ins>
<ins>pair&lt;iterator, bool> insert(value_type&& x);</ins>
</pre>
<ins>x․ Effects: If the map already contains an element whose key is equivalent to `x.first`,
`*this` and `x` are unchanged. Otherwise, equivalent to:</ins>
<pre>
<ins>auto key_it = ranges::upper_bound(c.keys, x.first, compare);</ins>
<ins>auto value_it = c.values.begin() + distance(c.keys.begin(), key_it);</ins>
<ins>c.keys.insert(key_it, x.first);</ins>
<ins>c.values.insert(value_it, x.second);</ins>
</pre>
<ins>for the first overload and</ins>
<pre>
<ins>auto key_it = ranges::upper_bound(c.keys, x.first, compare);</ins>
<ins>auto value_it = c.values.begin() + distance(c.keys.begin(), key_it);</ins>
<ins>c.keys.insert(key_it, std::move(x.first));</ins>
<ins>c.values.insert(value_it, std::move(x.second));</ins>
</pre>
<ins>for the second overload.</ins>

<pre>
template<class P> pair&lt;iterator, bool> insert(P&& x);
template<class P> iterator insert(const_iterator position, P&& x);
</pre>
4․ Constraints: `is_constructible_v<pair<key_type, mapped_type>, P>` is `true`.

5․ Effects: The first form is equivalent to `return emplace(std::forward<P>(x));`.
The second form is equivalent to `return emplace_hint(position, std::forward<P>(x));`.
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:

<small><blockquote>
<pre>
    // modifiers
    template&lt;class... Args> iterator emplace(Args&&... args);
    template&lt;class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args);

    iterator insert(const value_type& x)<ins>;</ins>
      <del>{ return emplace(x); }</del>
    iterator insert(value_type&& x)<ins>;</ins>
      <del>{ return emplace(std::move(x)); }</del>
    iterator insert(const_iterator position, const value_type& x)<ins>;</ins>
      <del>{ return emplace_hint(position, x); }</del>
    iterator insert(const_iterator position, value_type&& x)<ins>;</ins>
      <del>{ return emplace_hint(position, std::move(x)); }</del>

    template&lt;class P> iterator insert(P&& x);
    template&lt;class P>
      iterator insert(const_iterator position, P&&);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.multiset.modifiers], modifiers
    template&lt;class... Args> iterator emplace(Args&&... args)<del>;</del>
      <ins>{ return insert(value_type(std::forward&lt;Args>(args)...)); }</ins>
    template&lt;class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args)<del>;</del>
        <ins>{ return insert(position, value_type(std::forward&lt;Args>(args)...)); }</ins>

    iterator insert(const value_type& x)<ins>;</ins>
      <del>{ return emplace(x); }</del>
    iterator insert(value_type&& x)<ins>;</ins>
      <del>{ return emplace(std::move(x)); }</del>
    <ins>template&lt;class K> iterator insert(K&& x);</ins>
    iterator insert(const_iterator position, const value_type& x)<ins>;</ins>
      <del>{ return emplace_hint(position, x); }</del>
    iterator insert(const_iterator position, value_type&& x)<ins>;</ins>
      <del>{ return emplace_hint(position, std::move(x)); }</del>
    <ins>template&lt;class K> iterator insert(const_iterator hint, K&& x);</ins>
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:

<small><blockquote>
<pre>
<del>template&lt;class... Args> iterator emplace(Args&&... args);</del>
</pre>
<p><del>1․ Constraints: `is_constructible_v<value_type, Args...>` is `true`.</del>
<p><del>2․ Effects: First, initializes an object `t` of type `value_type` with `std::forward<Args>(args)...`,
then inserts `t` as if by:</del>
<pre>
<del>auto it = ranges::upper_bound(c, t, compare);</del>
<del>c.insert(it, std::move(t));</del>
</pre>
<p><del>3․ Returns: An iterator that points to the inserted element.</del>

<pre>
<ins>iterator insert(const value_type& x);</ins>
<ins>iterator insert(value_type&& x);</ins>
</pre>
<ins>x․ Effects: Inserts a new element as if by:</ins>
<pre>
<ins>auto it = ranges::upper_bound(c, x, compare);</ins>
<ins>c.insert(it, x);</ins>
</pre>
<ins>for the first overload or</ins>
<pre>
<ins>auto it = ranges::upper_bound(c, x, compare);</ins>
<ins>c.insert(it, std::move(x));</ins>
</pre>
<ins>for the second overload.</ins>

<p><ins>x․ Returns: An iterator that points to the inserted element.</ins>

<pre>
<ins>template&lt;class K> iterator insert(K&& x);</ins>
<ins>template&lt;class K> iterator insert(const_iterator hint, K&& x);</ins>
</pre>
<p><ins>x․ Constraints: The *qualified-id* `Compare::is_transparent` is valid and denotes a type. `is_constructible_v<value_type, K>` is `true`.</ins>

<p><ins>x․ Preconditions: The conversion from `x` into `value_type` constructs an object `u`, for which `find(x) == find(u)` is `true`.</ins>

<p><ins>x․ Effects: If the set already contains an element equivalent to `x`, `*this` and `x` are unchanged. Otherwise, inserts a new element as if by
`emplace(std::forward<K>(x))`.</ins>

<p><ins>x․ Returns: An iterator that points to the inserted element.</ins>

</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.set.modifiers], modifiers
    template&lt;class... Args> pair&lt;iterator, bool> emplace(Args&&... args)<del>;</del>
      <ins>{ return insert(value_type(std::forward&lt;Args>(args)...)); }</ins>
    template&lt;class... Args>
      iterator emplace_hint(const_iterator position, Args&&... args)<del>;</del>
        <ins>{ return insert(position, value_type(std::forward&lt;Args>(args)...)); }</ins>

    pair&lt;iterator, bool> insert(const value_type& x)<ins>;</ins>
      <del>{ return emplace(x); }</del>
    pair&lt;iterator, bool> insert(value_type&& x)<ins>;</ins>
      <del>{ return emplace(std::move(x)); }</del>
    template&lt;class K> pair&lt;iterator, bool> insert(K&& x);
    iterator insert(const_iterator position, const value_type& x)<ins>;</ins>
      <del>{ return emplace_hint(position, x); }</del>
    iterator insert(const_iterator position, value_type&& x)<ins>;</ins>
      <del>{ return emplace_hint(position, std::move(x)); }</del>
    template&lt;class K> iterator insert(const_iterator hint, K&& x);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.modifiers">[flat.set.modifiers]</a> as follows:

<small><blockquote>
<pre>
<ins>pair&lt;iterator, bool> insert(const value_type& x);</ins>
<ins>pair&lt;iterator, bool> insert(value_type&& x);</ins>
</pre>
<ins>x․ Effects: If the set already contains an element equivalent to `x`, `*this` and `x` are unchanged.
Otherwise, inserts a new element as if by:</ins>
<pre>
<ins>auto it = ranges::upper_bound(c, x, compare);</ins>
<ins>c.insert(it, x);</ins>
</pre>
<ins>for the first overload or</ins>
<pre>
<ins>auto it = ranges::upper_bound(c, x, compare);</ins>
<ins>c.insert(it, std::move(x));</ins>
</pre>
<ins>for the second overload.</ins>

<p><ins>x․ Returns: The `bool` component of the returned pair is `true` if and only if the insertion took place.
The returned iterator points to the element whose key is equivalent to `x`.</ins>

<pre>
template&lt;class K> pair&lt;iterator, bool> insert(K&& x);
template&lt;class K> iterator insert(const_iterator hint, K&& x);
</pre>
1․ Constraints: The *qualified-id* `Compare::is_transparent` is valid and denotes a type. `is_constructible_v<value_type, K>` is `true`.

2․ Preconditions: The conversion from `x` into `value_type` constructs an object `u`, for which `find(x) == find(u)` is `true`.

3․ Effects: If the set already contains an element equivalent to `x`, `*this` and `x` are unchanged. Otherwise, inserts a new element as if by
<del>`emplace(std::forward<K>(x))`</del> <ins>`insert(std::forward<K>(x))`</ins>.

4․ Returns: In the first overload, the `bool` component of the returned pair is `true` if and only if the insertion took place.
The returned iterator points to the element whose key is equivalent to `x`.
</blockquote></small>


# `insert_range(sorted_unique, rg)` # {#insert-range-sorted-unique}

The multi-element insertion API consists of these overloads:

```c++
  insert(first, last);
  insert(il);
  insert_range(rg);

  insert(sorted_unique, first, last);
  insert(sorted_unique, il);
```

An overload of `insert_range(sorted_unique, rg)` is conspicuously missing.

```c++
   auto rg = std::views::iota(0, 100) | std::take_while(lessThan50);
   assert(!std::ranges::common_range<decltype(rg)>);
   assert(std::ranges::is_sorted(rg));

   std::flat_set<int> fs;

   fs.insert_range(rg);
     // OK, but unnecessarily re-sorts the input

   if (auto cv = rg | std::views::common; true) {
     fs.insert(std::sorted_unique, cv.begin(), cv.end());
       // OK, doesn't re-sort, but arcane
   }

   fs.insert_range(std::sorted_unique, rg);
     // Before: Ill-formed
     // After: OK
```

Now, we're also conspicuously missing a constructor overload `flat_set(sorted_unique, from_range, rg)`.
There we have a real API-design conflict: Which of `sorted_unique` and `from_range` should come first?
This is enough of a reason to simply give up on that constructor. But `insert_range` has no such API-design
problem. We could add this overload easily.

## Wording ## {#wording-insert-range-sorted-unique}

Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template&lt;class InputIterator>
      void insert(sorted_unique_t, InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      void insert_range(R&& rg);
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
      <ins>void insert_range(sorted_unique_t, R&& rg);</ins>
    void insert(initializer_list&lt;value_type> il)
      { insert(il.begin(), il.end()); }
    void insert(sorted_unique_t s, initializer_list&lt;value_type> il)
      { insert(s, il.begin(), il.end()); }
</pre>
</blockquote></small>

Add a new entry to <a href="https://eel.is/c++draft/flat.map.modifiers">[flat.map.modifiers]</a> as follows:

<small><blockquote>
<pre>
<ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
  <ins>void insert_range(sorted_unique_t, R&& rg);</ins>
</pre>

<p><ins>x․ Effects: Equivalent to `insert_range(std::forward<R>(rg))`.</ins>

<p><ins>x․ Complexity: Linear in N, where N is `size()` after the operation.</ins>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template&lt;class InputIterator>
      void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      void insert_range(R&& rg);
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
      <ins>void insert_range(sorted_equivalent_t, R&& rg);</ins>
    void insert(initializer_list&lt;value_type> il)
      { insert(il.begin(), il.end()); }
    void insert(sorted_equivalent_t s, initializer_list&lt;value_type> il)
      { insert(s, il.begin(), il.end()); }
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template&lt;class InputIterator>
      void insert(sorted_equivalent_t, InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      void insert_range(R&& rg);
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
      <ins>void insert_range(sorted_equivalent_t, R&& rg);</ins>
    void insert(initializer_list&lt;value_type> il)
      { insert(il.begin(), il.end()); }
    void insert(sorted_equivalent_t s, initializer_list&lt;value_type> il)
      { insert(s, il.begin(), il.end()); }
</pre>
</blockquote></small>

Add a new entry to <a href="https://eel.is/c++draft/flat.multiset.modifiers">[flat.multiset.modifiers]</a> as follows:

<small><blockquote>
<pre>
<ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
  <ins>void insert_range(sorted_equivalent_t, R&& rg);</ins>
</pre>

<p><ins>x․ Effects: Equivalent to `insert_range(std::forward<R>(rg))`.</ins>

<p><ins>x․ Complexity: Linear in N, where N is `size()` after the operation.</ins>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator>
      void insert(InputIterator first, InputIterator last);
    template&lt;class InputIterator>
      void insert(sorted_unique_t, InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;value_type> R>
      void insert_range(R&& rg);
    <ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
      <ins>void insert_range(sorted_unique_t, R&& rg);</ins>
    void insert(initializer_list&lt;value_type> il)
      { insert(il.begin(), il.end()); }
    void insert(sorted_unique_t s, initializer_list&lt;value_type> il)
      { insert(s, il.begin(), il.end()); }
</pre>
</blockquote></small>

Add a new entry to <a href="https://eel.is/c++draft/flat.set.modifiers">[flat.set.modifiers]</a> as follows:

<small><blockquote>
<pre>
<ins>template&lt;<i>container-compatible-range</i>&lt;value_type> R></ins>
  <ins>void insert_range(sorted_unique_t, R&& rg);</ins>
</pre>

<p><ins>x․ Effects: Equivalent to `insert_range(std::forward<R>(rg))`.</ins>

<p><ins>x․ Complexity: Linear in N, where N is `size()` after the operation.</ins>
</blockquote></small>

# Sorting complexity # {#sorting-complexity}

Most operations that require sorting come in `sorted_unique` and non-`sorted_unique` flavors;
the `sorted_unique` flavor is rightly specified not to sort, which means it can be O(N)
instead of O(N + M log M). That's fine. But some non-`sorted_unique` constructors have
Complexity clauses that mandate O(N) performance on input that *happens* to be sorted
at runtime. The vendor has three ways to deal with this:

- Guarantee that `std::sort` (or `std::stable_sort` if [[#stable-sorting]] is adopted) will
    always run in O(N) time on sorted input. This is not currently mandated by <a href="https://eel.is/c++draft/alg.sort#sort-5">[alg.sort]</a>,
    so no vendor is likely to know off the top of their heads that they really guarantee this
    for all possible sorted inputs. libc++ certainly doesn't know this for sure.

- Add a linear-time pass on the front, e.g. `if (!std::is_sorted(first, last)) std::sort(first, last)`.
    This wastes O(N) cycles in every case: it might improve the asymptotic performance in the
    rare case that the input happens to be sorted at runtime, but only at the cost of slowing down
    the expected case where the input is not sorted. libc++ doesn't want to slow down the
    average caller.

- Ignore the spec's Complexity requirement. libc++ also doesn't want to do this.

Louis Dionne would be happy with a resolution that requires all vendors to implement this
optimization in `std::sort` itself, for ranges that happen to be sorted. I.e., change
<a href="https://eel.is/c++draft/alg.sort#sort-5">[sort]/5</a> as follows:

<small><blockquote>
5․ Complexity: Let N be `last - first`. <ins>If the input is sorted with respect to `comp` and `proj`, O(N) comparisons and projections. Otherwise,</ins>
O(N log N) comparisons and projections. <ins>In either case, twice as many projections as comparisons.</ins>
</blockquote></small>

and change <a href="https://eel.is/c++draft/alg.sort#stable.sort-5">[stable.sort]/5</a> as follows:

<small><blockquote>
5․ Complexity: Let N be `last - first`. <ins>If the input is sorted with respect to `comp` and `proj`, O(N) comparisons.</ins>
If enough extra memory is available, <ins>O(</ins>N log(N)<ins>)</ins> comparisons.
Otherwise, <del>at most</del> <ins>O(</ins>N log<sup>2</sup>(N)<ins>)</ins> comparisons.
In <del>either</del> <ins>any</ins> case, twice as many projections as <del>the number of</del> comparisons.
</blockquote></small>

If we changed [alg.sort], then we'd get [flat.foo]'s unusual complexity guarantees for free, and
the following changes in [flat.foo] would be no-ops, just a bit of editorial cleanup.
However, Louis and Arthur would prefer to leave [alg.sort] alone for now,
making the following changes in [flat.foo] significant and non-editorial.

## Wording ## {#wording-sorting-complexity}

If these changes are not adopted wholesale, we still propose editorially to replace `zip_view` with `zip`
and "if the container arguments are already sorted with respect to `value_comp()`" with
"if `key_cont` is already sorted with respect to `compare`."

Change <a href="https://eel.is/c++draft/flat.map.cons">[flat.map.cons]</a> as follows:

<small><blockquote>
<pre>
flat_map(key_container_type key_cont, mapped_container_type mapped_cont,
         const key_compare& comp = key_compare());
</pre>
1․ Effects: Initializes `c.keys` with `std::move(key_cont)`, `c.values` with `std::move(mapped_cont)`,
and `compare` with `comp`; sorts the range [`begin()`, `end()`) with respect to `value_comp()`; and
finally erases the duplicate elements as if by:
<pre>
auto zv = ranges::zip<del>_view</del>(c.keys, c.values);
auto it = ranges::unique(zv, key_equiv(compare)).begin();
auto dist = distance(zv.begin(), it);
c.keys.erase(c.keys.begin() + dist, c.keys.end());
c.values.erase(c.values.begin() + dist, c.values.end());
</pre>

<p>2․ Complexity: <del>Linear in N if the container arguments are already sorted with respect to `value_comp()`
and otherwise N log N, where N is the value of `key_cont.size()` before this call.</del>
<ins>Same as `ranges::sort(ranges::zip(c.keys, c.values), value_comp())`.</ins>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multimap.cons">[flat.multimap.cons]</a> as follows:

<small><blockquote>
<pre>
flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,
              const key_compare& comp = key_compare());
</pre>
1․ Effects: Initializes `c.keys` with `std::move(key_cont)`, `c.values` with `std::move(mapped_cont)`, 
and `compare` with `comp`; sorts the range [`begin()`, `end()`) with respect to `value_comp()`.

<p>2․ Complexity: <del>Linear in N if the container arguments are already sorted with respect to `value_comp()`
and otherwise N log N, where N is the value of `key_cont.size()` before this call.</del>
<ins>Same as `ranges::sort(ranges::zip(c.keys, c.values), value_comp())`.</ins>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.cons">[flat.multiset.cons]</a> as follows:

<small><blockquote>
<pre>
explicit flat_multiset(container_type cont, const key_compare& comp = key_compare());
</pre>

1․ Effects: Initializes <i>`c`</i> with `std::move(cont)` and <i>`compare`</i> with `comp`<del>, and</del> <ins>;</ins>
sorts the range [`begin()`, `end()`) with respect to <i>`compare`</i>.

2․ Complexity: <del>Linear in N if `cont` is sorted with respect to <i>`compare`</i>
and otherwise N log N, where N is the value of `cont.size()` before this call.</del> <ins>Same as `ranges::sort(c, compare)`.</ins>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.cons">[flat.set.cons]</a> as follows:

<small><blockquote>
<pre>
explicit flat_set(container_type cont, const key_compare& comp = key_compare());
</pre>

1․ Effects: Initializes <i>`c`</i> with `std::move(cont)` and <i>`compare`</i> with `comp`<del>,</del> <ins>;</ins>
sorts the range [`begin()`, `end()`) with respect to <i>`compare`</i><del>,</del> <ins>;</ins>
and finally erases all but the first element from each group of consecutive equivalent elements.

2․ Complexity: <del>Linear in N if `cont` is sorted with respect to <i>`compare`</i>
and otherwise N log N, where N is the value of `cont.size()` before this call.</del> <ins>Same as `ranges::sort(c, compare)`.</ins>
</blockquote></small>

# `replace` should take by value # {#replace-by-value}

The current specification for `replace` takes the new container(s) by rvalue reference,
which means you can't just pass in a container the way you can with the `key_cont` constructor;
instead, you have to manually `std::move` the container.

This might have been originally intended as a guard against accidental expensive copying of containers.
But C++ doesn't use this (explicit-pass-by-rvalue-reference) pattern anywhere else; and it's
inconsistent with the specification of the `key_cont` constructors, which do take by value
and happily allow passing in lvalue containers by copy.

```c++
    std::vector<int> v = {1,2,3};
    std::flat_set<int> fs;

    fs = std::flat_set(v); // OK
    fs.replace(std::vector(v)); // OK

    fs.replace(v);
      // Before: Ill-formed
      // After: OK
```

Taking by value and move-constructing into place is almost always just as performant as
taking by rvalue-reference and move-constructing into place. Caveat: some containers
are expensive to move-construct. `std::pmr::vector` is *not* such a container.
Boost `static_vector` is. But we shouldn't cater for such types, especially not at
the cost of API consistency.

```
    boost::container::static_vector<int, 100> v;
    auto fs = std::flat_set(std::move(v)); // OK, does 2 expensive moves
    fs.replace(std::move(v));
      // Before: OK, does 1 expensive move
      // After: OK, does 2 expensive moves
    fs.replace(v);
      // Before: Ill-formed
      // After: OK, does 1 expensive copy and 1 expensive move
```

## Wording ## {#wording-replace-by-value}

Change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:

<small><blockquote>
<pre>
    containers extract() &&;
    void replace(key_container_type<del>&&</del> key_cont, mapped_container_type<del>&&</del> mapped_cont);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.map.modifiers#lib:replace,flat_map">[flat.map.modifiers]</a> as follows:

<small><blockquote>
<pre>
void replace(key_container_type<del>&&</del> key_cont, mapped_container_type<del>&&</del> mapped_cont);
</pre>

36․ Preconditions: `key_cont.size() == mapped_cont.size()` is `true`, the elements of `key_cont` are sorted with respect to `compare`,
and `key_cont` contains no equal elements.

37․ Effects: Equivalent to:
<pre>
c.keys = std::move(key_cont);
c.values = std::move(mapped_cont);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multimap.defn">[flat.multimap.defn]</a> as follows:

<small><blockquote>
<pre>
    containers extract() &&;
    void replace(key_container_type<del>&&</del> key_cont, mapped_container_type<del>&&</del> mapped_cont);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.defn">[flat.multiset.defn]</a> as follows:

<small><blockquote>
<pre>
    container_type extract() &&;
    void replace(container_type<del>&&</del>);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.multiset.modifiers#lib:replace,flat_multiset">[flat.multiset.modifiers]</a> as follows:

<small><blockquote>
<pre>
void replace(container_type<del>&&</del> cont);
</pre>

12․ Preconditions: The elements of `cont` are sorted with respect to `compare`.

13․ Effects: Equivalent to: `c = std::move(cont);`
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> as follows:

<small><blockquote>
<pre>
    container_type extract() &&;
    void replace(container_type<del>&&</del>);
</pre>
</blockquote></small>

Change <a href="https://eel.is/c++draft/flat.set.modifiers#lib:replace,flat_set">[flat.set.modifiers]</a> as follows:

<small><blockquote>
<pre>
void replace(container_type<del>&&</del> cont);
</pre>

12․ Preconditions: The elements of `cont` are sorted with respect to `compare`, and `cont` contains no equal elements.

13․ Effects: Equivalent to: `c = std::move(cont);`
</blockquote></small>


# Noexcept `swap` # {#noexcept-swap}

TODO FIXME BUG HACK
`swap` is unconditionally noexcept, which is inconsistent with priority_queue and stack and queue (they're conditionally noexcept). We should really
be conditionally noexcept, and then "restore the invariant" (i.e. clear both containers) if an exception is thrown. Except: What do we do if swapping
the comparators throws? Then we can't do anything at all!  Suggest at least a precondition that swapping the comparators will not throw an exception.
Louis suggests stronger: Constraint that is_nothrow_swappable_v<Compare>!  Also, the unconditional noexcept produces worse codegen (try-catch-abort)
than a conditional noexcept would produce.

## Wording ## {#wording-noexcept-swap}

TODO FIXME BUG HACK


# Issues for discussion # {#issues-for-discussion}

The following subsections describe known issues with the flat containers, where Arthur thinks the
status quo is fine, but Louis Dionne asks for further clarification and/or changes to the wording.

## Stable sorting in `insert` ## {#stable-sorting}

For the tree-based associative containers,
<a href="https://eel.is/c++draft/associative.reqmts#general-68.sentence-2">[associative.reqmts.general]</a> defines
the single-element `foo::insert(val)` to insert in a well-defined order;
<a href="https://eel.is/c++draft/associative.reqmts.general#lib:insert,ordered_associative_containers___">[associative.reqmts.general]</a> defines
the multi-element `foo::insert(first, last)` to insert in an unspecified order.
Nevertheless, in practice, all three vendors implement the latter as a simple
loop over the former, so we have this de-facto behavior portable everywhere:

```c++
    struct Apathy { bool operator()(int, int) const { return false; } };
    int a[] = {1,2,3,4,5};
    std::multiset<int, Apathy> s;

    // #1
    for (int i : a) s.insert(i);
    assert(std::ranges::equal(s, a)); // de jure

    // #2
    s.insert(a, a+5);
    assert(std::ranges::is_permutation(s, a)); // de jure
    assert(std::ranges::equal(s, a)); // de facto portable

    // #3
    s.insert_range(a);
    assert(std::ranges::is_permutation(s, a)); // de jure
    assert(std::ranges::equal(s, a)); // de facto portable
```

Similarly with equivalent keys in a `map` or `multimap`:

```c++
    std::pair<int, int> a[] = {{1,1},{1,2},{1,3}};
    std::map<int, int, Apathy> m;

    // #1
    for (auto kv : a) m.insert(kv);
    assert(m[1] == 1); // de jure

    // #2
    m.insert(a, a+5);
    assert(m[1] > 0); // de jure
    assert(m[1] == 1); // de facto portable

    // #3
    m.insert_range(a);
    assert(m[1] > 0); // de jure
    assert(m[1] == 1); // de facto portable
```

Arthur's libc++ implementation leans into the idea that `flat_foo` is a drop-in replacement for `foo`,
and ensures that `flat_foo::insert{,_range}` will behave exactly like `foo::insert{,_range}`.

```c++
    std::flat_multiset<int, Apathy> fs;

    // #1
    for (int i : a) fs.insert(i);
    assert(std::ranges::equal(fs, a)); // de jure

    // #2
    fs.insert(a, a+5);
    assert(std::ranges::is_permutation(fs, a)); // de jure
    assert(std::ranges::equal(fs, a)); // libc++

    // #3
    fs.insert_range(a);
    assert(std::ranges::is_permutation(fs, a)); // de jure
    assert(std::ranges::equal(fs, a)); // libc++
```

`flat_foo::insert(first, last)` is defined by <a href="https://eel.is/c++draft/flat.set.modifiers#lib:insert,flatset">[flat.set.modifiers]</a>
to insert in order and then "sort the range." The vendor will be tempted to use `std::sort`,
which in practice is not stable. Arthur's implementation uses `std::stable_sort` specifically
to ensure that `fs` will give the same results as `s` for all multi-element insertions.

Louis Dionne worries that by providing this additional de-facto guarantee, libc++ might be creating
a "portability trap" — the programmer writes obvious code that works perfectly on libc++, and then when
the programmer migrates to libstdc++ or Microsoft STL, they suddenly find that their code no longer works.

Therefore Louis asks whether LWG could *specifically require* that newly inserted elements be sorted stably, e.g.

<small><blockquote>
<pre>
template&lt;class InputIterator>
  void insert(InputIterator first, InputIterator last);
</pre>

5․ Effects: Adds elements to `c` as if by:
<pre>
c.insert(c.end(), first, last);
</pre>
Then, <ins>stably</ins> sorts the range of newly inserted elements with respect to `compare`;
merges the resulting sorted range and the sorted range of pre-existing elements into a single sorted range;
and finally erases all but the first element from each group of consecutive equivalent elements.

6․ Complexity: N + M log M, where N is `size()` before the operation and M is `distance(first, last)`.

7․ Remarks: Since this operation performs an in-place merge, it may allocate memory.
</blockquote></small>

This operation already requires an in-place merge, which allocates memory,
so requiring it to also do a stable sort — which allocates memory — might not be considered such a big deal.

The alternative here would be for libc++ to lean into the idea that `multiset::insert_range` is supposed to
leave the order of equivalent elements unspecified, and instrument it under libc++'s existing
`_LIBCPP_DEBUG_RANDOMIZE_UNSPECIFIED_STABILITY` flag (currently used only for `sort`, `nth_element`, and `partial_sort`).
This would preserve the symmetry between `multiset` and `flat_multiset`, by making both of them de facto
randomized order (at least in debug mode).

## Non-explicit constructor from two containers ## {#deceptive}

Arthur has observed [in a blog post](https://quuxplusone.github.io/blog/2023/04/28/flat-map-constructors/)
that `flat_map`'s non-explicit constructor from two containers is deceptive when used with braced initializers.

```c++
    void print_map(std::flat_multimap<int, int>);

    // Test the two-container constructor... or is it?

    print_map({ {1, 2, 3}, {10, 20, 30} }); // {1,10}, {2,20}, {3,30}
    print_map({ {1, 2},    {10, 20} });     // {1,2}, {10,20}
    print_map({ {1},       {10} });         // {1,10}
    print_map({ {},        {} });           // {0,0}, {0,0}
```

To address this issue (if we wanted to), we could make one of the relevant constructors `explicit`.
We obviously can't prevent `vector`'s construction from a braced list
of elements, nor `pair`'s from a braced list of (exactly two) elements, nor (in practice)
`pair`'s construction from `{}`; so the only constructor we could explicify to address this
would be `flat_multimap`'s own constructor from a braced list of (exactly two) containers. That is,
we'd do this (and likewise in `flat_map`; `flat_set` doesn't need to change):

<small><blockquote>
<pre>
    <ins>explicit flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont)</ins>
      <ins>: flat_multimap(std::move(key_cont), std::move(mapped_cont), key_compare()) {}</ins>
    flat_multimap(key_container_type key_cont, mapped_container_type mapped_cont,
                  const key_compare& comp <del>= key_compare()</del>);
    template&lt;class Allocator>
      flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,
                    const Allocator& a);
    template&lt;class Allocator>
      flat_multimap(const key_container_type& key_cont, const mapped_container_type& mapped_cont,
                    const key_compare& comp, const Allocator& a);
</pre>
</blockquote></small>

Arthur thinks this change would be appreciated by programmers in practice (or rather, if we *don't*
make this change, then programmers will only ever notice this issue when it bites them).
But it would be surprisingly asymmetric to explicify only this one constructor. The small benefit
probably does not justify the asymmetry.

We recently made some constructors `explicit` in
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2711r1.html">P2711 "Making multi-param constructors of views explicit,"</a>
but that paper's goal was to *increase* uniformity and symmetry, not to decrease it.

## Complexity of `equal_range` ## {#complexity-equal-range}

<a href="https://eel.is/c++draft/associative.reqmts.general#171">[associative.reqmts.general]/171 and /174</a>
define the complexity of `b.equal_range(k)` and `a_tran.equal_range(ke)` as "Logarithmic."
This means that we have the following required complexities, for both `foo` and `flat_foo`:

```c++
    std::set<std::string> s;
    std::multiset<std::string> ms;
    std::set<std::string, std::less<>> st;
    std::multiset<std::string, std::less<>> mst;

    s.equal_range("abc"s);
      // 171: lower_bound, lower_bound+1; (1 + lg N) operations total
    ms.equal_range("abc"s);
      // 171: lower_bound, upper_bound; (2 lg N) operations total
    st.equal_range("abc");
      // 174: lower_bound, upper_bound; (2 lg N) operations total
    mst.equal_range("abc");
      // 174: lower_bound, upper_bound; (2 lg N) operations total
```

For `st.equal_range`, <a href="https://eel.is/c++draft/associative.reqmts.general#7.22">[associative.reqmts.general]/7.22</a>
forces us to consider the possibility that `std::less<>::operator()(key_type, const char*)`
is a less granular equivalence relation than `std::less<>::operator()(key_type, key_type)`; i.e., even though
this is a `set`, it might still contain "duplicates" from the point of view of the heterogeneous comparator.
It would be efficient in practice to find `lower_bound("abc")` in lg N time and then step forward linearly
until we find an element not equal to `"abc"` — the expected number of duplicates for the average real-world workload
is small. But the number of duplicates *theoretically* could be O(N); so we're not allowed to do this
(at least not without an arbitrary cap, e.g. if we don't find the end of the range in 10 probes then fall back
to `upper_bound` — bookkeeping which would again unnecessarily slow down the average case).

Consider a working programmer who writes

```c++
    std::flat_set<std::string> s;
    s.equal_range("abc");
      // lower_bound, lower_bound+1; (1 + lg N) operations total
```

and then switches to a heterogeneous comparator in an effort to "speed up" the code
by avoiding the conversion to `std::string`:

```c++
    std::flat_set<std::string, std::less<>> st;
    st.equal_range("abc");
      // lower_bound, upper_bound; (2 lg N) operations total, cache-unfriendly
```

libc++ would like to see vendors given a little more freedom to experiment here.

The proposed wording below doesn't require any vendor to change their implementation,
since an existing implementation in O(log N) certainly also satisfies O(M + log N).

### Wording ### {#wording-complexity-equal-range}

Change <a href="https://eel.is/c++draft/associative.reqmts.general#171">[associative.reqmts.general]</a> as follows:

<small><blockquote>
<pre>
a_tran.upper_bound(ku)
</pre>

166․ Result: `iterator`; `const_iterator` for constant `a_tran`.

167․ Returns: An iterator pointing to the first element with key `r` such that `c(ku, r)`, or `a_tran.end()` if such an element is not found.

168․ Complexity: Logarithmic.

<pre>
b.equal_range(k)
</pre>

169․ Result: `pair<iterator, iterator>`; `pair<const_iterator, const_iterator>` for constant `b`.

170․ Effects: Equivalent to: `return make_pair(b.lower_bound(k), b.upper_bound(k));`

171․ Complexity: <del>Logarithmic.</del> <ins>O(M + log N), where N is `b.size()` and M is `distance(b.lower_bound(k), b.upper_bound(k))`.</ins>

<pre>
a_tran.equal_range(ke)
</pre>

172․ Result: pair<iterator, iterator>; pair<const_iterator, const_iterator> for constant a_tran.

173․ Effects: Equivalent to: return make_pair(a_tran.lower_bound(ke), a_tran.upper_bound(ke));

174․ Complexity: <del>Logarithmic.</del> <ins>O(M + log N), where N is `a_tran.size()` and M is `distance(a_tran.lower_bound(ke), a_tran.upper_bound(ke))`.</ins>
</blockquote></small>


## Special member functions ## {#special-members}

<a href="https://eel.is/c++draft/flat.set.defn">[flat.set.defn]</a> currently does not declare
any special member functions. This implies that they are defaulted, which implicitly specifies
their constexprness, noexceptness, and triviality.

All three C++20 container adaptors (e.g. <a href="https://eel.is/c++draft/priqueue.overview">[priqueue.overview]</a>)
follow that approach, too.

All four associative and four unordered containers (e.g. <a href="https://eel.is/c++draft/set.overview">[set.overview]</a>)
explicitly provide signatures for all five special members, including the destructor, like
this:

<small><blockquote>
<pre>
    set(const set& x);
    set(set&& x);
[...]
    ~set();
    set& operator=(const set& x);
    set& operator=(set&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable_v<Compare>);
</pre>
</blockquote></small>

Should `flat_set`'s spec hew more closely to `std::set`'s or `priority_queue`'s?
We tentatively think `set`'s is the better model, so that the vendor would be free to
make the special members non-defaulted. Vendors are still permitted to strengthen the
noexceptness and/or triviality of declared functions; for example, both libc++ and libstdc++
make `set(set&&)` conditionally noexcept.

```c++
    using V = std::experimental::fixed_capacity_vector<int, 100>;
    static_assert(std::is_trivially_destructible_v<V>);
    using M = std::flat_set<int, std::less<int>, V>;
    static_assert(std::is_trivially_destructible_v<M>);
      // Before: Mandatory.
      // After: Permitted but not mandatory.
```

## Moving from the comparator ## {#move-from-comparator}

As shown above, the associative and unordered containers give their move-assignment operator
a noexcept-spec that strongly implies it must move-from the comparator, never copy it.
This particularly affects libstdc++, where `set(set&&)` will copy a stateful comparator
(e.g. `std::function`) instead of moving-from it, but `set::operator=(set&&)` must move
the comparator, leaving the source object in a "radioactive" state.

This whole area is the subject of [[LWG2227]] "Stateful comparison objects in associative containers,"
and is certainly beyond the scope of this paper P2767.

```c++
  struct TestLess : std::less<> {
    // make this too big to fit in the small buffer
    char pad_[1000];
  };
  using C = std::function<bool(int,int)>;
  std::set<int, C> s({1,2,3}, C(TestLess()));
  assert(s.key_comp() != nullptr);
  auto t = std::move(s);
  assert(s.key_comp() != nullptr);
    // libstdc++: Succeeds
    // libc++: Fails
  s.clear();
  s.insert({1,2});
    // libstdc++: OK
    // libc++: Throws std::bad_function_call
  t = std::move(s);
  s.insert({1,2});
    // Everyone: Throws std::bad_function_call
```

If we user-declare `flat_set::operator=(flat_set&&)`,
we must decide whether to give it a similar noexcept-spec.

### Possible wording ### {#wording-special-members}

(This wording merge-conflicts with the resolution of [[LWG3884]], which in turn merge-conflicts
with the editorial refactoring at the beginning of this paper P2767. We can polish it later;
the first question is whether LWG wants to pursue this direction at all.)

For example, change <a href="https://eel.is/c++draft/flat.map.defn">[flat.map.defn]</a> as follows:

<small><blockquote>
<pre>
    // [flat.map.cons], constructors
    flat_map() : flat_map(key_compare()) { }

    <ins>flat_map(const flat_map&);</ins>
    <ins>flat_map(flat_map&&);</ins>
    <ins>flat_map& operator=(const flat_multimap&);</ins>
    <ins>flat_map& operator=(flat_multimap&&)</ins>
      <ins>noexcept(is_nothrow_move_assignable_v&lt;KeyContainer> &&</ins>
               <ins>is_nothrow_move_assignable_v&lt;MappedContainer> &&</ins>
               <ins>is_nothrow_move_assignable_v&lt;Compare>);)</ins>
    <ins>~flat_map();</ins>

    flat_map(key_container_type key_cont, mapped_container_type mapped_cont,
             const key_compare& comp = key_compare());
</pre>
</blockquote></small>

## `iterator` and `const_iterator` ## {#iterator-types}

`flat_set::iterator` and `flat_set::const_iterator` are presented as if they could be
two different types. This is consistent with how we do it in `set` and `unordered_set`.
But in practice, all three vendors make `set::iterator` and `set::const_iterator` the
same type. We should consider refactoring the spec of `set`, `unordered_set`, and `flat_set`
all at once to *mandate* that these iterator types be the same type, the same way we
already do for [`basic_string_view`](https://eel.is/c++draft/string.view#footnote-207)
and (since C++23 introduced `std::const_iterator`) [`span<const T>`](https://eel.is/c++draft/span.overview).

This would allow us to remove a lot of redundant overloads from the specification,
e.g. we don't need both `iterator find(value_type)` and `const_iterator find(value_type) const`
if those are the same iterator type. Vendors can already do this removal in their implementations
if they choose to. This is merely a question of our getting to do it in the paper specification too,
under the banner of "standardizing existing practice."

## Support for non-standard containers ## {#containers}

TODO FIXME BUG HACK
Vendors are required to support "random-access containers," which means `vector<T>` (except for `vector<bool>`)
and `deque<T>`. It's unclear if vendors are required to support non-standard containers such as
`boost::container::vector<T>`; and if so, what public API those containers must provide in order
to interoperate with `flat_set`.

For example, suppose the underlying container supports `C(first, last)` but not
`C(from_range, rg)`. Then I would expect that I couldn't initialize a `flat_set<T, Compare, C>`
with `flat_set(from_range, rg)`; but I should still be able to initialize it with `flat_set(first, last)`,
right? It would be nice to see what's required and what's encouraged in this area.

libc++ goes very slightly out of its way to support `vector<bool>` as the underlying container,
even though we believe we're not required to support it.




<!-- ------


- What containers are supported?

(4) In general, `flat_set` cannot deal with containers or comparators that throw exceptions. 
(I discussed this general problem in "Mostly Invalid", CppCon 2019.) If inserting into the underlying container throws an exception,
 then `flat_set` cannot possibly know what state the underlying container is in — did the insert succeed? fail? half-succeed? — and therefore `flat_set`
 can't know whether its sortedness invariant still holds. (It can't test the sortedness invariant, either, because the comparator might throw, and we
 already have one exception in flight at this point.) So, if `insert` throws an exception, `flat_set` will clear itself.
It's possible that we could do something clever in the case that we know the container is a specialization of `vector` (which we control), and 
various things are noexcept, so that if insertion throws (e.g. due to `bad_alloc`) then the user doesn't lose all of their data. Should we attempt
 to special-case `vector` and/or `deque`'s recovery behavior? I propose "no," because I think our attempt would fail anyway and so I don't want to
 waste time thinking about clever tactics. But if someone wants to propose a specific clever tactic, I'll investigate it and tell you why it didn't work.






----- -->




# Implementation experience # {#experience}

I have implemented this proposal as a patch against libc++ trunk; see [[Patch]].
You can experiment with it [on Godbolt Compiler Explorer]();
just use the P1144 branch of Clang, which uses this patched libc++ by default.

The complete wording diff against `cplusplus/draft:main` is also available
on my GitHub; see [[Wording]].


# Acknowledgments # {#acknowledgments}

- Thanks to Tomasz Kamiński for recommending Arthur write this paper.


<pre class=biblio>
{
  "LWG2227": {
    "title": "Stateful comparison objects in associative containers",
    "authors": [
      "Juan Soulie"
    ],
    "href": "https://cplusplus.github.io/LWG/issue2227",
    "date": "December 2012"
  },
  "LWG3786": {
    "title": "Flat maps' deduction guide needs to default Allocator to be useful",
    "authors": [
      "Johel Ernesto Guerrero Peña"
    ],
    "href": "https://cplusplus.github.io/LWG/issue3786",
    "date": "September 2022"
  },
  "LWG3802": {
    "title": "flat_foo allocator-extended constructors lack move semantics",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/LWG/issue3802",
    "date": "October 2022"
  },
  "LWG3803": {
    "title": "flat_foo constructors taking KeyContainer lack KeyCompare parameter",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/LWG/issue3803",
    "date": "October 2022"
  },
  "LWG3804": {
    "title": "flat_foo missing some allocator-extended deduction guides",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/LWG/issue3804",
    "date": "October 2022"
  },
  "LWG3884": {
    "title": "flat_foo is missing allocator-extended copy/move constructors",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/LWG/issue3884",
    "date": "February 2023"
  },
  "P0429": {
    "title": "A standard flat_map",
    "authors": [
      "Zach Laine"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf",
    "date": "June 2022"
  },
  "P1163": {
    "title": "Explicitly implicifying explicit constructors",
    "authors": [
      "Nevin Liber"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1163r0.pdf",
    "date": "August 2018"
  },
  "P1222": {
    "title": "A standard flat_set",
    "authors": [
      "Zach Laine"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1222r4.pdf",
    "date": "June 2022"
  },
  "P2363": {
    "title": "Extending associative containers with the remaining heterogeneous overloads",
    "authors": [
      "Konstantin Boyarinov",
      "Sergey Vinogradov",
      "Ruslan Arutyunyan"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2363r5.html",
    "date": "February 2023"
  }
}
</pre>
