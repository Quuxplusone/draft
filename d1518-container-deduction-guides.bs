<pre class='metadata'>
Title: Container deduction guides should accept not just allocators but things-convertible-to-allocators
Shortname: D1518
Revision: 0
!Draft Revision: 2
Audience: LEWG
Status: D
Group: WG21
URL:
!Current Source: <a href="https://github.com/Quuxplusone/draft/blob/gh-pages/stack-ctad.bs">github.com/Quuxplusone/draft/blob/gh-pages/stack-ctad.bs</a>
!Current: <a href="https://rawgit.com/Quuxplusone/draft/gh-pages/stack-ctad.html">rawgit.com/Quuxplusone/draft/gh-pages/stack-ctad.html</a>
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Editor: Mike Spertus, mike@spertus.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  Discussion of flatmap's deduction guides revealed that the deduction guides for
  sequence containers and container adaptors are subtly overconstrained. We fix this.
Date: 2019-02-22
</pre>

<style>
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>


# The problem # {#problem}

Consider this code:

```c++
std::pmr::monotonic_buffer_resource mr;
std::pmr::polymorphic_allocator<int> a = &mr;
std::pmr::vector<int> pv(a);

auto v1 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv);
auto v2 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv, a);
auto v3 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv, &mr);

auto s1 = std::stack<int, std::pmr::vector<int>>(pv);
auto s2 = std::stack<int, std::pmr::vector<int>>(pv, a);
auto s3 = std::stack<int, std::pmr::vector<int>>(pv, &mr);

auto dv1 = std::vector(pv);
auto dv2 = std::vector(pv, a);
auto dv3 = std::vector(pv, &mr);

auto ds1 = std::stack(pv);
auto ds2 = std::stack(pv, a);
auto ds3 = std::stack(pv, &mr);
```

The initializers of `v1`, `v2`, `v3`, `s1`, `s2`, and `s3` (which do not use CTAD) are all well-formed.

The initializer of `dv1` is well-formed and deduces `std::pmr::vector<int>` just like `v1`.

The initializer of `dv2` is well-formed and deduces `std::pmr::vector<int>` just like `v2`.

The initializer of `ds1` is well-formed and deduces `std::stack<int, std::pmr::vector<int>>` just like `s1`.

The initializer of `ds2` is well-formed and deduces `std::stack<int, std::pmr::vector<int>>` just like `s2`.

But the initializers of `dv3` and `ds3` are ill-formed!

In both cases, we know from the `pv` argument that the correct type for the vector is
`decltype(pv)`, i.e. `std::pmr::vector<int>`. Therefore we know what is the possible range
of types for the allocator parameter. The allocator parameter's type does not *contribute*
to class template argument deduction in these cases; it brings no new information, and therefore
should be treated no differently than it is in the non-CTAD case.

The non-CTAD version `std::vector<...>(pv, &mr)` works; therefore it is surprising when the CTAD
version `std::vector(pv, &mr)` fails.

The problem we see with `vector` also occurs for all other sequence containers, associative containers,
and unordered associative containers. However, there is implementation divergence in the details.
The following table summarizes what we see in [this Godbolt](https://godbolt.org/z/1QepHG):

<small>
<table class="def">
<tr><th>Construct</th><th>Well-formed</th><th>SFINAE-friendly<br> ill-formed</th><th>Hard error</th></tr>

<tr><td>std::deque(pd, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::forward_list(pfl, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::list(pl, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::map(pm, &mr)</td> <td>MSVC</td> <td>libstdc++, libc++</td> <td></td>
<tr><td>std::multimap(pmm, &mr)</td> <td>MSVC</td> <td>libstdc++, libc++</td> <td></td>
<tr><td>std::multiset(pms, &mr)</td> <td>MSVC</td> <td>libstdc++, libc++</td> <td></td>
<tr><td>std::set(ps, &mr)</td> <td>MSVC</td> <td>libstdc++, libc++</td> <td></td>
<tr><td>std::unordered_map(pum, &mr)</td> <td>MSVC, libstdc++</td> <td>libc++</td> <td></td>
<tr><td>std::unordered_multimap(pumm, &mr)</td> <td>MSVC, libstdc++</td> <td>libc++</td> <td></td>
<tr><td>std::unordered_multiset(pums, &mr)</td> <td>MSVC, libstdc++</td> <td>libc++</td> <td></td>
<tr><td>std::unordered_set(pus, &mr)</td> <td>MSVC, libstdc++</td> <td>libc++</td> <td></td>
<tr><td>std::vector(pv, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr></tr>
<tr><td>std::priority_queue(ppq, &mr)</td> <td>MSVC, libstdc++, libc++</td> <td></td> <td></td>
<tr><td>std::queue(pq, &mr)</td> <td>MSVC, libstdc++, libc++</td> <td></td> <td></td>
<tr><td>std::stack(ps, &mr)</td> <td>MSVC, libstdc++, libc++</td> <td></td> <td></td>
<tr></tr>
<tr><td>std::priority_queue(pv, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::queue(pd, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::stack(pv, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
</table>
</small>


# The explanation # {#explanation}

## How deduction fails for `vector` ## {#explanation-vector}

`vector` has only one deduction guide, and it's not relevant to what happens here. Here, we end up
looking at the implicit guide generated from the constructor

```c++
    template<class T, class Allocator>
    class vector {
        vector(const vector<T, Allocator>&, const Allocator&);
    };
```

From the first parameter, we deduce `T=int` and `Allocator=std::pmr::polymorphic_allocator<int>`.
From the second parameter, we deduce `Allocator=std::monotonic_buffer_resource*`.
We've deduced conflicting types for `Allocator`, so deduction fails.


## How deduction succeeds for `unordered_set` ## {#explanation-unordered-set}

It should work the same as for `vector`.
We should end up looking at the implicit guide generated from the constructor

```c++
    template<class Key, class Hash, class Pred, class Allocator>
    class unordered_set {
        unordered_set(const unordered_set<Key, Hash, Pred, Allocator>&, const Allocator&);
    };
```

From the first parameter, we deduce `Key=int`, `Hash=std::hash<int>`, `Pred=std::equal_to<int>`,
and `Allocator=std::pmr::polymorphic_allocator<int>`.
From the second parameter, we should deduce `Allocator=std::monotonic_buffer_resource*`.
We've deduced conflicting types for `Allocator`, so deduction fails.

However, in practice, both MSVC and libstdc++ launder the `Allocator` type through a typedef
that is opaque to deduction, so
that the constructor seen by the compiler in practice is equivalent to

```c++
    template<class Key, class Hash, class Pred, class Allocator>
    class unordered_set {
        using allocator_type = typename type_identity<Allocator>::type;
        unordered_set(const unordered_set<Key, Hash, Pred, Allocator>&, const allocator_type&);
    };
```

From the first parameter, we deduce `Key=int`, `Hash=std::hash<int>`, `Pred=std::equal_to<int>`,
and `Allocator=std::pmr::polymorphic_allocator<int>`.
From the second parameter, we don't deduce anything.
In practice, therefore, deduction succeeds.


## How deduction fails for `stack` ## {#explanation-stack}

`stack` has one relevant deduction guide.

```c++
    template<class T, class Container>
    class stack {
        template<class Alloc> stack(const Container&, const Alloc&);
    };

    template<class Container, class Allocator>
    stack(Container, Allocator) -> stack<typename Container::value_type, Container>;
```

However, both the constructor and the deduction guide are constrained.

[[stack.cons.alloc](http://eel.is/c++draft/stack.cons.alloc)] says:
<small><blockquote>
If `uses_allocator_v<container_type, Alloc>` is `false`
the constructors in this subclause shall not participate in overload resolution.
</blockquote></small>

[[container.adaptors.general](http://eel.is/c++draft/container.adaptors.general)] says:
<small><blockquote>
A deduction guide for a container adaptor shall not participate in overload resolution if
any of the following are true: ...

    - <b>It has an `Allocator` template parameter and a type that does not qualify as an allocator
          is deduced for that parameter.</b>

    - It has both `Container` and `Allocator` template parameters, and
          `uses_allocator_v<Container, Allocator>` is `false`.

</blockquote></small>

To qualify as an allocator, a type `A` must have a nested typedef `A::value_type`
<small>([[container.requirements.general](http://eel.is/c++draft/container.requirements.general#17)]/17)</small>.
Since `std::pmr::monotonic_buffer_resource*` has no such nested typedef,
`std::pmr::monotonic_buffer_resource*` doesn't qualify as an allocator.
However, `uses_allocator_v<std::pmr::vector<int>, std::pmr::monotonic_buffer_resource*>` is `true`.

Because the type of `&mr` doesn't qualify as an allocator, the deduction guide drops out
of overload resolution. The implicit guide generated from the constructor template, however,
remains. From the first parameter we deduce `Container=std::pmr::vector<int>`. From the
second parameter, we deduce `Alloc=std::pmr::monotonic_buffer_resource*`. So far so good.
But CTAD's job is not done! We have successfully deduced the `Container` type in
`template<class T, class Container> class stack`; but we have not deduced anything about
the type parameter `T`. Therefore deduction fails.


# The solution # {#solution}

Note: Most of the wording being touched here was added by [[P0433R3]], on which Mike Spertus
was the primary author. If we'd thought of these cases at the time, this is how we would have
done these deduction guides from the beginning.


## How to fix the container adaptors ## {#solution-stack}

To fix all three container adaptors, modify
[[container.adaptors.general](http://eel.is/c++draft/container.adaptors.general)] as follows:

<small><blockquote>
A deduction guide for a container adaptor shall not participate in overload resolution if any of the following are true:

- It has an `InputIterator` template parameter and a type that does not qualify as an
     input iterator is deduced for that parameter.

- It has a `Compare` template parameter and a type that qualifies as an allocator is deduced
     for that parameter.

- It has a `Container` template parameter and a type that qualifies as an allocator is deduced
     for that parameter.

- <del>It has an `Allocator` template parameter and a type that does not qualify as an allocator
     is deduced for that parameter.</del>

- It has both `Container` and `Allocator` template parameters, and
     `uses_allocator_v<Container, Allocator>` is `false`.

</blockquote></small>

Note: The rationale is that if the `Container` advertises that it can "use" the supplied allocator,
we shouldn't interrogate it any more closely. Trust the `Container`'s specialization of `uses_allocator`.

Note: No container adaptor deduction guide has an `Allocator` template parameter without also having
a `Container` template parameter.


## How to fix the containers (option 1) ## {#solution-vector-option1}

A non-invasive, but subtle, way to fix the containers would be to carefully rewrite each
uses-allocator constructor to use a typedef that was opaque to deduction.
For example, modify [[deque.overview](http://eel.is/c++draft/deque.overview)] as follows:

<small><blockquote>
<pre>
    deque(deque&&);
    <del>deque(const deque&, const Allocator&);</del>
    <ins>deque(const deque&, const type_identity_t&lt;Allocator>&);</ins>
    <del>deque(deque&&, const Allocator&);</del>
    <ins>deque(deque&&, const type_identity_t&lt;Allocator>&);</ins>
    deque(initializer_list<T>, const Allocator& = Allocator());
</pre>
</blockquote></small>


## How to fix the containers (option 2) ## {#solution-vector-option2}

First modify
[ [sequence.reqmts](http://eel.is/c++draft/sequence.reqmts#13)]/13 as follows:

<small><blockquote>
A deduction guide for a sequence container shall not participate in overload resolution
if it has an `InputIterator` template parameter and a type that does not qualify as an
input iterator is deduced for that parameter, or if it has an `Allocator` template parameter
and a type that does not qualify as an allocator is deduced for that parameter<ins>,
or if it has an `Alloc` template parameter and `uses_allocator_v<X, Alloc>` is `false`
where `X` is the deduced type of the sequence container</ins>.
</blockquote></small>

(I think that change is not strictly necessary, but it clarifies our intent.)

Add one new deduction guide for each sequence container. For example, modify
[[deque.overview](http://eel.is/c++draft/deque.overview)] as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator, class Allocator = allocator&lt;<i>iter-value-type</i>&lt;InputIterator>>>
        deque(InputIterator, InputIterator, Allocator = Allocator())
          -> deque&lt;<i>iter-value-type</i>&lt;InputIterator>, Allocator>;

    <ins>template&lt;class T, class Allocator, class Alloc>
        deque(deque&lt;T, Allocator>, Alloc)
          -> deque&lt;T, Allocator>;</ins>
</pre>
</blockquote></small>

Then, modify
[ [associative.reqmts](http://eel.is/c++draft/associative.reqmts#15)]/15 as follows:

<small><blockquote>
A deduction guide for an associative container shall not participate in overload resolution
if any of the following are true:

- It has an `InputIterator` template parameter and a type that does not qualify as an input iterator
        is deduced for that parameter.

- It has an `Allocator` template parameter and a type that does not qualify as an allocator
        is deduced for that parameter.

- It has a `Compare` template parameter and a type that qualifies as an allocator is
        deduced for that parameter.

- <ins>It has an `Alloc` template parameter and `uses_allocator_v<X, Alloc>` is `false`
        where `X` is the deduced type of the associative container</ins>.

</blockquote></small>

(I think that change is not strictly necessary, but it clarifies our intent.)

Add one new deduction guide for each associative container. For example, modify
[[set.overview](http://eel.is/c++draft/set.overview)] as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator,
             class Compare = less&lt;<i>iter-value-type</i>&lt;InputIterator>>,
             class Allocator = allocator&lt;<i>iter-value-type</i>&lt;InputIterator>>>
      set(InputIterator, InputIterator,
          Compare = Compare(), Allocator = Allocator())
        -> set&lt;<i>iter-value-type</i>&lt;InputIterator>, Compare, Allocator>;

    template&lt;class Key, class Compare = less&lt;Key>, class Allocator = allocator&lt;Key>>
      set(initializer_list&lt;Key>, Compare = Compare(), Allocator = Allocator())
        -> set&lt;Key, Compare, Allocator>;

    template&lt;class InputIterator, class Allocator>
      set(InputIterator, InputIterator, Allocator)
        -> set&lt;<i>iter-value-type</i>&lt;InputIterator>,
               less&lt;<i>iter-value-type</i>&lt;InputIterator>>, Allocator>;

    template&lt;class Key, class Allocator>
      set(initializer_list&lt;Key>, Allocator) -> set&lt;Key, less&lt;Key>, Allocator>;

    <ins>template&lt;class Key, class Compare, class Allocator, class Alloc>
      set(set&lt;Key, Compare, Allocator>, Alloc) -> set&lt;Key, Compare, Allocator>;</ins>
</pre>
</blockquote></small>

Then, modify [ [unord.req](http://eel.is/c++draft/unord.req#18)]/18 as follows:

<small><blockquote>
A deduction guide for an unordered associative container shall not participate in overload resolution
if any of the following are true:

- It has an `InputIterator` template parameter and a type that does not qualify as an input iterator
        is deduced for that parameter.

- It has an `Allocator` template parameter and a type that does not qualify as an allocator
        is deduced for that parameter.

- It has a `Hash` template parameter and an integral type or a type that qualifies as an allocator
        is deduced for that parameter.

- It has a `Pred` template parameter and a type that qualifies as an allocator is
        deduced for that parameter.

- <ins>It has an `Alloc` template parameter and `uses_allocator_v<X, Alloc>` is `false`
        where `X` is the deduced type of the associative container</ins>.

</blockquote></small>

(I think that change is not strictly necessary, but it clarifies our intent.)

Add one new deduction guide for each unordered associative container. For example, modify
[[unord.set.overview](http://eel.is/c++draft/unord.set.overview)] as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator,
             class Hash = hash&lt;<i>iter-value-type</i>&lt;InputIterator>>,
             class Pred = equal_to&lt;<i>iter-value-type</i>&lt;InputIterator>>,
             class Allocator = allocator&lt;<i>iter-value-type</i>&lt;InputIterator>>>
      unordered_set(InputIterator, InputIterator, typename <i>see below</i>::size_type = <i>see below</i>,
                    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -> unordered_set&lt;<i>iter-value-type</i>&lt;InputIterator>,
                         Hash, Pred, Allocator>;

    template&lt;class T, class Hash = hash&lt;T>,
             class Pred = equal_to&lt;T>, class Allocator = allocator&lt;T>>
      unordered_set(initializer_list&lt;T>, typename <i>see below</i>::size_type = <i>see below</i>,
                    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -> unordered_set&lt;T, Hash, Pred, Allocator>;

    template&lt;class InputIterator, class Allocator>
      unordered_set(InputIterator, InputIterator, typename <i>see below</i>::size_type, Allocator)
        -> unordered_set&lt;<i>iter-value-type</i>&lt;InputIterator>,
                         hash&lt;<i>iter-value-type</i>&lt;InputIterator>>,
                         equal_to&lt;<i>iter-value-type</i>&lt;InputIterator>>,
                         Allocator>;

    template&lt;class InputIterator, class Hash, class Allocator>
      unordered_set(InputIterator, InputIterator, typename <i>see below</i>::size_type,
                    Hash, Allocator)
        -> unordered_set&lt;<i>iter-value-type</i>&lt;InputIterator>, Hash,
                         equal_to&lt;<i>iter-value-type</i>&lt;InputIterator>>,
                         Allocator>;

    template&lt;class T, class Allocator>
      unordered_set(initializer_list&lt;T>, typename <i>see below</i>::size_type, Allocator)
        -> unordered_set&lt;T, hash&lt;T>, equal_to&lt;T>, Allocator>;

    template&lt;class T, class Hash, class Allocator>
      unordered_set(initializer_list&lt;T>, typename <i>see below</i>::size_type, Hash, Allocator)
        -> unordered_set&lt;T, Hash, equal_to&lt;T>, Allocator>;

    <ins>template&lt;class T, class Hash, class Pred, class Allocator, class Alloc>
      unordered_set(set&lt;T, Hash, Pred, Allocator>, Alloc)
        -> unordered_set&lt;T, Hash, Pred, Allocator>;</ins>
</pre>
</blockquote></small>



<pre class=biblio>
{
  "P0433R3": {
    "authors": [
      "Mike Spertus", "Walter Brown", "Stephan T. Lavavej"
    ],
    "title": "Toward a resolution of US7 and US14: Integrating template deduction for class templates into the standard library",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0433r3.html",
    "date": "June 2017"
  }
}
</pre>
