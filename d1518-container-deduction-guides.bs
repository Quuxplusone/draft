<pre class='metadata'>
Title: Stop overconstraining allocators in container deduction guides
Shortname: D1518
Revision: 0
!Draft Revision: 4
Audience: LEWG
Status: D
Group: WG21
URL:
!Current Source: <a href="https://github.com/Quuxplusone/draft/blob/gh-pages/stack-ctad.bs">github.com/Quuxplusone/draft/blob/gh-pages/stack-ctad.bs</a>
!Current: <a href="https://rawgit.com/Quuxplusone/draft/gh-pages/stack-ctad.html">rawgit.com/Quuxplusone/draft/gh-pages/stack-ctad.html</a>
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Editor: Mike Spertus, mike_spertus@symantec.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  Discussion of flatmap’s deduction guides revealed that the deduction guides for sequence
  containers and container adaptors are needlessly overconstrained, making use cases such as
  pmr containers unnecessarily difficult. We fix this.
Date: 2019-03-09
</pre>

<style>
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>


# Stop overconstraining allocators that do not participate in deduction # {#overconst1}

## The problem ## {#problem1}

Consider this code:

```c++
std::pmr::monotonic_buffer_resource mr;
std::pmr::polymorphic_allocator<int> a = &mr;
std::pmr::vector<int> pv(a);

auto s1 = std::stack<int, std::pmr::vector<int>>(pv);
auto s2 = std::stack<int, std::pmr::vector<int>>(pv, a);
auto s3 = std::stack<int, std::pmr::vector<int>>(pv, &mr);

auto ds1 = std::stack(pv);
auto ds2 = std::stack(pv, a);
auto ds3 = std::stack(pv, &mr);
```

The initializers of `s1`, `s2`, and `s3` (which do not use CTAD) are all well-formed,
as are the initializers of `ds1` and `ds2` (which do).

However, the natural and useful `ds3` is ill-formed, even though the `&mr` argument is irrelevant to determining the
template arguments for `stack`! It seems clearly wrong that we give all the right information to unambiguously deduce
the desired specialization of stack and then reject what would be a perfectly valid constructor invocation for that
class. The allocator parameter’s type does not *contribute* to class template argument deduction in these cases;
it brings no new information, and therefore should be treated no differently than it is in the non-CTAD case.
Indeed, we believe this is an oversight and should simply be fixed.


## The explanation ## {#explanation1}

`stack` has one relevant deduction guide.

```c++
    template<class Container, class Allocator>
    stack(Container, Allocator) -> stack<typename Container::value_type, Container>;
```

This deduction guide satisfies the following constraints.

[container.adaptors.general] says:
<small><blockquote>
A deduction guide for a container adaptor shall not participate in overload resolution if
any of the following are true: ...

    - <b>It has an `Allocator` template parameter and a type that does not qualify as an allocator
          is deduced for that parameter.</b>

    - It has both `Container` and `Allocator` template parameters, and
          `uses_allocator_v<Container, Allocator>` is `false`.

</blockquote></small>

To qualify as an allocator, a type `A` must have a nested typedef `A::value_type`
<small>([container.requirements.general]/17)</small>.
Since `std::pmr::monotonic_buffer_resource*` has no such nested typedef,
`std::pmr::monotonic_buffer_resource*` doesn't qualify as an allocator.
However, `uses_allocator_v<std::pmr::vector<int>, std::pmr::monotonic_buffer_resource*>` is `true`.

Because the type of `&mr` doesn't qualify as an allocator, the deduction guide drops out
of overload resolution, failing deduction even though it has all the information
needed to safely deduce the correct template arguments for `stack`.


## The solution ## {#solution1}

To fix all three container adaptors, modify
[[container.adaptors.general](http://eel.is/c++draft/container.adaptors.general)] as follows:

<small><blockquote>
A deduction guide for a container adaptor shall not participate in overload resolution if any of the following are true:

- It has an `InputIterator` template parameter and a type that does not qualify as an
     input iterator is deduced for that parameter.

- It has a `Compare` template parameter and a type that qualifies as an allocator is deduced
     for that parameter.

- It has a `Container` template parameter and a type that qualifies as an allocator is deduced
     for that parameter.

- <del>It has an `Allocator` template parameter and a type that does not qualify as an allocator
     is deduced for that parameter.</del>

- It has both `Container` and `Allocator` template parameters, and
     `uses_allocator_v<Container, Allocator>` is `false`.

</blockquote></small>

Note: The rationale is that if the `Container` advertises that it can "use" the supplied allocator,
we shouldn't interrogate it any more closely. Trust the `Container`'s specialization of `uses_allocator`.

Note: No container adaptor deduction guide has an `Allocator` template parameter without also having
a `Container` template parameter.


# Stop deducing from allocators that should not participate in deduction # {#overconst2}

## The problem ## {#problem2}

Consider the following code:
```c++
std::pmr::monotonic_buffer_resource mr;
std::pmr::polymorphic_allocator<int> a = &mr;
std::pmr::vector<int> pv(a);

auto v1 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv);
auto v2 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv, a);
auto v3 = std::vector<int, std::pmr::polymorphic_allocator<int>>(pv, &mr);

auto dv1 = std::vector(pv);
auto dv2 = std::vector(pv, a);
auto dv3 = std::vector(pv, &mr);

```
The initializers of `v1`, `v2`, and `v3` (which do not use CTAD) are all well-formed,
as are the initializers of `dv1` and `dv2` (which do).

But the initializer of `dv3` is ill-formed!

Again, we know from the `pv` argument that the correct type for the vector is `decltype(pv)`, i.e. `std::pmr::vector<int>`. Therefore we
know what is the possible range of types for the allocator parameter. The allocator parameter’s type does not *contribute*
to class template argument deduction in these cases; it brings no new information, and therefore should be treated no differently
than it is in the non-CTAD case.

The problem we see with `vector` also occurs for all other sequence containers, associative containers, and unordered associative containers.


## The explanation ## {#explanation2}

`vector` has only one deduction guide, and it's not relevant to what happens here. Here, we end up
looking at the implicit guide generated from the constructor

```c++
    template<class T, class Allocator>
    class vector {
        vector(const vector<T, Allocator>&, const Allocator&);
    };
```

From the first parameter, we deduce `T=int` and `Allocator=std::pmr::polymorphic_allocator<int>`.
From the second parameter, we deduce `Allocator=std::monotonic_buffer_resource*`.
We've deduced conflicting types for `Allocator`, so deduction fails.

In this case, the second argument unnecessarily participates in deduction, and again unexpectedly
prevents natural and useful code from working as desired.


## The solution ## {#solution2}

We present two approaches for changing the wording that are equivalent in effect.

### Wording option 1 ### {#option1}

If we were introducing the containers from scratch today, the natural approach would be for the
constructors to indicate which arguments should be considered deducible, as is usual for function templates.
For example, modify [ [deque.overview](http://eel.is/c++draft/deque.overview)] as follows:

<small><blockquote>
<pre>
    deque(deque&&);
    <del>deque(const deque&, const Allocator&);</del>
    <ins>deque(const deque&, const type_identity_t&lt;Allocator>&);</ins>
    <del>deque(deque&&, const Allocator&);</del>
    <ins>deque(deque&&, const type_identity_t&lt;Allocator>&);</ins>
    deque(initializer_list&lt;T>, const Allocator& = Allocator());
</pre>
</blockquote></small>

(Notice that the constructor `deque(initializer_list&lt;T>, const Allocator&)` is not
changed, because its `Allocator` parameter actually does contribute to deduction: without
that parameter's type, we would not know what the `deque`'s allocator type should be.)

If this is not deemed to cause compatibility issues, we like this approach.


### Wording option 2 ### {#option2}

First modify
[ [sequence.reqmts](http://eel.is/c++draft/sequence.reqmts#13)]/13 as follows:

<small><blockquote>
A deduction guide for a sequence container shall not participate in overload resolution
if it has an `InputIterator` template parameter and a type that does not qualify as an
input iterator is deduced for that parameter, or if it has an `Allocator` template parameter
and a type that does not qualify as an allocator is deduced for that parameter<ins>,
or if it has an `Alloc` template parameter and `uses_allocator_v<X, Alloc>` is `false`
where `X` is the deduced type of the sequence container</ins>.
</blockquote></small>

(We think that change is not strictly necessary, but it clarifies our intent.)

Add one new deduction guide for each sequence container. For example, modify
[ [deque.overview](http://eel.is/c++draft/deque.overview)] as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator, class Allocator = allocator&lt;<i>iter-value-type</i>&lt;InputIterator>>>
        deque(InputIterator, InputIterator, Allocator = Allocator())
          -> deque&lt;<i>iter-value-type</i>&lt;InputIterator>, Allocator>;

    <ins>template&lt;class T, class Allocator, class Alloc>
        deque(deque&lt;T, Allocator>, Alloc)
          -> deque&lt;T, Allocator>;</ins>
</pre>
</blockquote></small>

Then, modify [ [associative.reqmts](http://eel.is/c++draft/associative.reqmts#15)]/15 as follows:

<small><blockquote>
A deduction guide for an associative container shall not participate in overload resolution
if any of the following are true:

- It has an `InputIterator` template parameter and a type that does not qualify as an input iterator
        is deduced for that parameter.

- It has an `Allocator` template parameter and a type that does not qualify as an allocator
        is deduced for that parameter.

- It has a `Compare` template parameter and a type that qualifies as an allocator is
        deduced for that parameter.

- <ins>It has an `Alloc` template parameter and `uses_allocator_v<X, Alloc>` is `false`
        where `X` is the deduced type of the associative container</ins>.

</blockquote></small>

(We think that change is not strictly necessary, but it clarifies our intent.)

Add one new deduction guide for each associative container. For example, modify
[ [set.overview](http://eel.is/c++draft/set.overview)] as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator,
             class Compare = less&lt;<i>iter-value-type</i>&lt;InputIterator>>,
             class Allocator = allocator&lt;<i>iter-value-type</i>&lt;InputIterator>>>
      set(InputIterator, InputIterator,
          Compare = Compare(), Allocator = Allocator())
        -> set&lt;<i>iter-value-type</i>&lt;InputIterator>, Compare, Allocator>;

    template&lt;class Key, class Compare = less&lt;Key>, class Allocator = allocator&lt;Key>>
      set(initializer_list&lt;Key>, Compare = Compare(), Allocator = Allocator())
        -> set&lt;Key, Compare, Allocator>;

    template&lt;class InputIterator, class Allocator>
      set(InputIterator, InputIterator, Allocator)
        -> set&lt;<i>iter-value-type</i>&lt;InputIterator>,
               less&lt;<i>iter-value-type</i>&lt;InputIterator>>, Allocator>;

    template&lt;class Key, class Allocator>
      set(initializer_list&lt;Key>, Allocator) -> set&lt;Key, less&lt;Key>, Allocator>;

    <ins>template&lt;class Key, class Compare, class Allocator, class Alloc>
      set(set&lt;Key, Compare, Allocator>, Alloc) -> set&lt;Key, Compare, Allocator>;</ins>
</pre>
</blockquote></small>

Then, modify [ [unord.req](http://eel.is/c++draft/unord.req#18)]/18 as follows:

<small><blockquote>
A deduction guide for an unordered associative container shall not participate in overload resolution
if any of the following are true:

- It has an `InputIterator` template parameter and a type that does not qualify as an input iterator
        is deduced for that parameter.

- It has an `Allocator` template parameter and a type that does not qualify as an allocator
        is deduced for that parameter.

- It has a `Hash` template parameter and an integral type or a type that qualifies as an allocator
        is deduced for that parameter.

- It has a `Pred` template parameter and a type that qualifies as an allocator is
        deduced for that parameter.

- <ins>It has an `Alloc` template parameter and `uses_allocator_v<X, Alloc>` is `false`
        where `X` is the deduced type of the associative container</ins>.

</blockquote></small>

(We think that change is not strictly necessary, but it clarifies our intent.)

Add one new deduction guide for each unordered associative container. For example, modify
[ [unord.set.overview](http://eel.is/c++draft/unord.set.overview)] as follows:

<small><blockquote>
<pre>
    template&lt;class InputIterator,
             class Hash = hash&lt;<i>iter-value-type</i>&lt;InputIterator>>,
             class Pred = equal_to&lt;<i>iter-value-type</i>&lt;InputIterator>>,
             class Allocator = allocator&lt;<i>iter-value-type</i>&lt;InputIterator>>>
      unordered_set(InputIterator, InputIterator, typename <i>see below</i>::size_type = <i>see below</i>,
                    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -> unordered_set&lt;<i>iter-value-type</i>&lt;InputIterator>,
                         Hash, Pred, Allocator>;

    template&lt;class T, class Hash = hash&lt;T>,
             class Pred = equal_to&lt;T>, class Allocator = allocator&lt;T>>
      unordered_set(initializer_list&lt;T>, typename <i>see below</i>::size_type = <i>see below</i>,
                    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -> unordered_set&lt;T, Hash, Pred, Allocator>;

    template&lt;class InputIterator, class Allocator>
      unordered_set(InputIterator, InputIterator, typename <i>see below</i>::size_type, Allocator)
        -> unordered_set&lt;<i>iter-value-type</i>&lt;InputIterator>,
                         hash&lt;<i>iter-value-type</i>&lt;InputIterator>>,
                         equal_to&lt;<i>iter-value-type</i>&lt;InputIterator>>,
                         Allocator>;

    template&lt;class InputIterator, class Hash, class Allocator>
      unordered_set(InputIterator, InputIterator, typename <i>see below</i>::size_type,
                    Hash, Allocator)
        -> unordered_set&lt;<i>iter-value-type</i>&lt;InputIterator>, Hash,
                         equal_to&lt;<i>iter-value-type</i>&lt;InputIterator>>,
                         Allocator>;

    template&lt;class T, class Allocator>
      unordered_set(initializer_list&lt;T>, typename <i>see below</i>::size_type, Allocator)
        -> unordered_set&lt;T, hash&lt;T>, equal_to&lt;T>, Allocator>;

    template&lt;class T, class Hash, class Allocator>
      unordered_set(initializer_list&lt;T>, typename <i>see below</i>::size_type, Hash, Allocator)
        -> unordered_set&lt;T, Hash, equal_to&lt;T>, Allocator>;

    <ins>template&lt;class T, class Hash, class Pred, class Allocator, class Alloc>
      unordered_set(set&lt;T, Hash, Pred, Allocator>, Alloc)
        -> unordered_set&lt;T, Hash, Pred, Allocator>;</ins>
</pre>
</blockquote></small>

## Implementation note ## {#implementation}
While implementers may of course implement this proposal exactly as described in the wording options above,
we wish to point out that a number of library implementations already behave in many cases as we are
proposing here as shown in the following table and [this Godbolt](https://godbolt.org/z/1QepHG):

<small>
<table class="def">
<tr><th>Construct</th><th>Well-formed</th><th>SFINAE-friendly<br> ill-formed</th><th>Hard error</th></tr>

<tr><td>std::deque(pd, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::forward_list(pfl, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::list(pl, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::vector(pv, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::map(pm, &mr)</td> <td>MSVC</td> <td>libstdc++, libc++</td> <td></td>
<tr><td>std::multimap(pmm, &mr)</td> <td>MSVC</td> <td>libstdc++, libc++</td> <td></td>
<tr><td>std::multiset(pms, &mr)</td> <td>MSVC</td> <td>libstdc++, libc++</td> <td></td>
<tr><td>std::set(ps, &mr)</td> <td>MSVC</td> <td>libstdc++, libc++</td> <td></td>
<tr><td>std::unordered_map(pum, &mr)</td> <td>MSVC, libstdc++</td> <td>libc++</td> <td></td>
<tr><td>std::unordered_multimap(pumm, &mr)</td> <td>MSVC, libstdc++</td> <td>libc++</td> <td></td>
<tr><td>std::unordered_multiset(pums, &mr)</td> <td>MSVC, libstdc++</td> <td>libc++</td> <td></td>
<tr><td>std::unordered_set(pus, &mr)</td> <td>MSVC, libstdc++</td> <td>libc++</td> <td></td>
<tr></tr>
<tr><td>std::priority_queue(ppq, &mr)</td> <td>MSVC, libstdc++, libc++</td> <td></td> <td></td>
<tr><td>std::queue(pq, &mr)</td> <td>MSVC, libstdc++, libc++</td> <td></td> <td></td>
<tr><td>std::stack(ps, &mr)</td> <td>MSVC, libstdc++, libc++</td> <td></td> <td></td>
<tr></tr>
<tr><td>std::priority_queue(pv, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::queue(pd, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
<tr><td>std::stack(pv, &mr)</td> <td></td> <td>MSVC, libstdc++, libc++</td> <td></td>
</table>
</small>

The following analysis explains why MSVC, in effect, already implements
the approach described in [wording option 1](#option1) above.
Consider the implicit guide generated from the constructor

```c++
    template<class Key, class Hash, class Pred, class Allocator>
    class unordered_set {
        unordered_set(const unordered_set<Key, Hash, Pred, Allocator>&,
                      const Allocator&);
    };
```

From the first parameter, we deduce `Key=int`, `Hash=std::hash<int>`, `Pred=std::equal_to<int>`,
and `Allocator=std::pmr::polymorphic_allocator<int>`.
From the second parameter, we should deduce `Allocator=std::monotonic_buffer_resource*`.
We've deduced conflicting types for `Allocator`, so deduction fails.

However, in practice, both MSVC and libstdc++ launder the `Allocator` type through a typedef
that is opaque to deduction, so
that the constructor seen by the compiler in practice is equivalent to

```c++
    template<class Key, class Hash, class Pred, class Allocator>
    class unordered_set {
        using allocator_type = typename type_identity<Allocator>::type;
        unordered_set(const unordered_set<Key, Hash, Pred, Allocator>&,
                      const allocator_type&);
    };
```

From the first parameter, we deduce `Key=int`, `Hash=std::hash<int>`, `Pred=std::equal_to<int>`,
and `Allocator=std::pmr::polymorphic_allocator<int>`.
From the second parameter, we don't deduce anything.
In practice, therefore, deduction succeeds.

Implementers who have taken the above approach can use that to simplify their
implementation of this proposal, as an alternative to directly implementing the above wording
(which is of course also perfectly fine).

<pre class=biblio>
{
  "P0433R3": {
    "authors": [
      "Mike Spertus", "Walter Brown", "Stephan T. Lavavej"
    ],
    "title": "Toward a resolution of US7 and US14: Integrating template deduction for class templates into the standard library",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0433r3.html",
    "date": "June 2017"
  }
}
</pre>
