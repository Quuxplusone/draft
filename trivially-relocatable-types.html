<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<style type="text/css">

body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5empadding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.8em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.8em; border: none; }

</style>

<title>Trivially relocatable types</title>
</head>
<body>

<b>Document number:</b> D1144R0 <br>
<b>Date:</b> 2018-07-05 <br>
<b>Project:</b> ISO JTC1/SC22/WG21, Programming Language C++ <br>
<b>Audience:</b> Evolution Working Group, Library Evolution Working Group <br>
<b>Reply to:</b>
    Arthur O'Dwyer &lt;arthur.j.odwyer@gmail.com&gt;,
    Mingxin Wang &lt;wmx16835vv@163.com&gt;
<br>


<h1>Object relocation in terms of move plus destroy</h1>

<p>
<a href="#Introduction">1. Introduction and motivation</a><br>
<a href="#Design">2. Design goals</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#use1">Important use case #1: Standard library types such as <code>std::string</code></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#use2">Important use case #2: Program-defined types with defaulted special members</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#use3">Lesser use case #3: Program-defined types with non-defaulted special members</a><br>
<a href="#Proposal">3. Proposed language and library features</a><br>
<a href="#Wording">4. Proposed wording for C++20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#">TODO FIXME BUG HACK</a><br>
<a href="#Further">5. Further considerations and directions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#swap">5a. Trivially swappable types</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#hetero">5b. Heterogeneous relocation</a><br>
<a href="#References">6. References</a><br>
</p>


<h2><a name="Introduction">1. Introduction and motivation</a></h2>

<p>
If you are reading this paper, and you have not yet watched Arthur's session from C++Now 2018
on "The Best Type Traits C++ Doesn't Have," it will help if you immediately stop reading and
<a href="https://www.youtube.com/watch?v=MWBfmmg8-Yo">go watch</a>
the first 30 minutes of that video at 2x speed with the captions turned on.<sup><a href="#fn_Best">[Best]</a></sup>
It's going to be worth your 15 minutes. I'll wait.
</p>

<p>
In the video, besides showing implementation techniques and benchmark results, we defined our
terms. These terms are summarized briefly below.
</p>

<p>
C++ has the verbs "move," "copy," and "destroy." To this list we propose to add the verb "relocate."
Given an object type <code>T</code> and memory addresses <code>src</code> and <code>dst</code>,
the phrase "<em>relocate</em> a <code>T</code> from <code>src</code> to <code>dst</code>" means no more and no
less than "<em>move-construct</em> <code>dst</code> from <code>src</code>, and then immediately
<em>destroy</em> the object at <code>src</code>."
From this verb, we get the adjective "relocatable." Any type which is both move-constructible and
destructible is <i>relocatable</i>. The notion can be modified by adverbs: we say that a type
is "nothrow relocatable" if its relocation operation is noexcept, and we say that a type
is "trivially relocatable" if its relocation operation is trivial (which, just like trivial move-construction
and trivial copy-construction, means "the operation is tantamount to a <code>memcpy</code>").
</p>

<p>
Almost all relocatable types are trivially relocatable: <code>std::unique_ptr&lt;int&gt;</code>,
<code>std::vector&lt;int&gt;</code>, <code>std::string</code>, <code>std::any</code>. Non-trivially relocatable
types exist but are rare: <code>boost::interprocess::offset_ptr&lt;int&gt;</code>, TODO FIXME BUG HACK.
</p>

<p>
Arthur has established (via benchmarks<sup><a href="#fn_Bench">[Bench]</a></sup> such as those shown in the video)
that if standard library code had a reliable way of detecting "trivial relocatability," we could optimize
that case and get a speed boost of up to 3x on routines that perform reallocation, such as
<pre>
    std::vector&lt;R>::resize
    std::vector&lt;R>::reserve
    std::vector&lt;R>::emplace_back
    std::vector&lt;R>::push_back
</pre>
</p>

<p>
Furthermore, Mingxin Wang points out that we can use the same "trivially relocatability" property to shrink the code
generated by small-buffer-optimized (SBO) type-erasing wrappers such as <code>std::function</code> and <code>std::any</code>.
For these types, a <i>move</i> of the wrapper object is implemented in terms of a
<i>relocation</i> of the contained object. (See for example
<a href="https://github.com/llvm-mirror/libcxx/blob/8fdc491860efbccb65ab2f01ec25e13b024da538/include/any#L389-L394">libc++'s <code>std::any</code></a>,
where the function that performs the relocation operation is confusingly named <code>__move</code>.)
In general, the <i>relocate</i> operation for a contained type <code>C</code> involves calls to <code>C</code>'s
move constructor and destructor, which must be uniquely codegenned for each different <code>C</code>; the
number of instantiations of <i>relocate</i> scales linearly with the count of distinct types <code>C</code>
in the program.
But for any trivially relocatable <code>C</code>, its <i>relocate</i> operation depends only on the number of
bytes being <code>memcpy</code>ed, and so the number of instantiations of <i>relocate</i> scales linearly with the count
of distinct <em>sizes</em> of <code>C</code> being used in the program; or indeed, linearly with the count
of distinct <em>sizes of SBO buffer</em> being used in the program.
</p>

<p>
A smaller number of instantiations means faster compile times, a smaller text section, and perhaps
"hotter" code (because a relatively higher proportion of your code now fits in icache).
</p>

<p>
In between these two scenarios, we also find the move-constructor of <code>fixed_capacity_vector&lt;R,N></code>,
which can be implemented as an element-by-element <i>move</i> (leaving the source vector's elements in their
moved-from state), or can be implemented more efficiently as an element-by-element <i>relocate</i> (leaving
the source vector empty).<sup><a href="#fn_SV">[SV]</a></sup>
</p>


<h2><a name="Design">2. Design goals</a></h2>

<p>
Every C++ type already <i>is</i> or <i>is not</i> trivially relocatable. This proposal is not about
"making more types trivially relocatable."
</p>

<p>
The optimizations discussed above are purely in the domain of library vendors. If you're writing
a vector, and you detect that your element type <code>T</code> is trivially relocatable, then
whether you do any special optimization in that case is merely a Quality of Implementation (QoI) issue.
This proposal is not about "standardizing certain library optimizations."
</p>

<p>
What C++ lacks is a standard way for library vendors to <i>detect</i> the (existing) trivial relocatability
of a type <code>T</code>, so that they can reliably apply their (existing) optimizations.
All we really need is to add <i>detection</i>, and then all the optimizations described above will naturally
emerge without any further special effort by WG21.
</p>

<p>
Today we can detect the trivial relocatability of several of these categories, via the following definition.
We'll take this as our starting point.
<pre>
    #include &lt;type_traits>
    template&lt;class T>
    struct is_trivially_relocatable : bool_constant&lt;
        is_trivially_move_constructible_v&lt;T> and
        is_trivially_destructible_v&lt;T>
    > {};

    auto lam = [x=42]{};
    static_assert(is_trivially_relocatable&lt; int >::value);
    static_assert(is_trivially_relocatable&lt; decltype(lam) >::value);
</pre>
</p>


<h3><a name="use1">Important use case #1: Standard library types such as <code>std::string</code></a></h3>

<p>
In order to optimize <code>std::vector&lt;std::string>::resize</code>, we must come up with a way to achieve
<pre>
    #include &lt;string>
    static_assert(is_trivially_relocatable&lt; std::string >::value);
</pre>
This could be done unilaterally by the library vendor, via a non-standard attribute
(<code>[[clang::trivially_relocatable]]</code>), or a member typedef with a reserved name
(<code>using __is_triv_relocatable = void</code>), or simply a vendor-provided specialization
of <code>std::is_trivially_relocatable&lt;std::string></code>.
</p>

<p>
That is, we can solve this use-case with "magic" that is confined to the headers of the implementation itself.
The programmer doesn't have to learn anything new, so far.
</p>

<h3><a name="use2">Important use case #2: Program-defined types<sup><a href="#fn_LWG2139">[LWG2139]</a></sup> with defaulted special members</a></h3>

<p>
In order to optimize the SBO <code>std::function</code> in any meaningful sense,
we must come up with a way to achieve
<pre>
    #include &lt;string>
    auto lam2 = [x=std::string("hello")]{};
    static_assert(is_trivially_relocatable&lt; decltype(lam2) >::value);
</pre>
Lambdas are not a special case in C++; they are simply class types with all their special members defaulted.
Therefore, presumably we should be able to use the same solution for lambdas as for
<pre>
    #include &lt;string>
    struct A {
        std::string s;
    };
    static_assert(is_trivially_relocatable&lt; A >::value);
</pre>
Here <code>struct A</code> follows the Rule of Zero: its move-constructor and destructor are both defaulted.
If they were also <i>trivial</i>, then we'd be done. In fact they are non-trivial; and yet, because the type
is composited from trivially relocatable types, the type as a whole <em>is</em> trivially relocatable.
</p>

<p>
This use-case asks specifically that we achieve the program above without breaking the "Rule of Zero."
We do not want to require the programmer to annotate <code>struct A</code> with a special attribute, or
a special member typedef, or anything like that. We want it to Just Work. Even for lambda types.
This is a much uglier problem than use-case #1. It requires core-language support.
</p>

<h3><a name="use3">Lesser use case #3: Program-defined types with non-defaulted special members</a></h3>

<p>
In order to optimize <code>std::vector&lt;boost::shared_ptr&lt;T>>::resize</code>,
we must come up with a way to achieve
<pre>
    struct B {
        B(B&amp;&amp;);  // non-trivial
        ~B();  // non-trivial
    };
    [SOME ADDITIONAL CODE HERE]
    static_assert(is_trivially_relocatable&lt; B >::value);
</pre>
The <code>[SOME ADDITIONAL CODE HERE]</code> cannot possibly be "no code at all," because there exist
examples of types that look just like <code>B</code> and <em>are</em> trivially relocatable (for example,
<code>boost::unique_ptr&lt;int></code>) and there exist types that look just like <code>B</code> and are
<em>not</em> trivially relocatable (for example, <code>boost::interprocess::offset_ptr&lt;int></code>).
The compiler cannot "crack open" the definitions of <code>B(B&amp;&amp;)</code> and <code>~B()</code> to see if
they combine to form a trivial operation. For one thing, that's the Halting Problem; for another thing,
the definitions of <code>B(B&amp;&amp;)</code> and <code>~B()</code> might not be available in this translation
unit.
</p>

<p>
(For another thing, the definitions of <code>B(B&amp;&amp;)</code> and <code>~B()</code> might actually be
available and "crackable" in <em>this</em> translation unit, but unavailable in some other translation unit!
This would lead to ODR violations and generally really bad stuff. So we can't possibly achieve this
without <code>[SOME ADDITIONAL CODE HERE]</code>.)
</p>

<p>
I call this a "lesser" case because it is the only one that requires us to design the syntax of
<code>[SOME ADDITIONAL CODE HERE]</code>. In use-case #1, any special syntax is hidden inside the
implementation's own headers. In use-case #2, our design goal is to <em>avoid</em> special syntax.
In use-case #3, we must design syntax.
</p>

<p>
Therefore, I believe it would be acceptable to punt on use-case #3 and come back to it later.
We say, "Sure, that would be nice, but there's no syntax for it. Be glad that it works for
core-language and library types. Ask again in three years."  And as long as we leave the design
space open, I believe we wouldn't lose anything by delaying a solution to use-case #3.
</p>

<p>
This paper does propose a solution for use-case #3 — which in turn provides a
<em>simple and portable</em> solution to use-case #1 for library vendors. However, this
solution is detachable from the rest of this paper.
</p>

<h2><a name="Proposal">3. Proposed language and library features</a></h2>

<p>
This paper proposes five essentially orthogonal additions to C++. They combine to produce
a solution to each of the three use-cases above. However, it is okay to consider and accept
or reject each addition on its own merits.  For example, if the <code>[[trivially_relocatable]]</code>
attribute is adopted, library vendors will certainly use it in their implementations;
but if the attribute is rejected, library vendors could still achieve use-case #1
by adding partial specializations of <code>is_trivially_relocatable</code>.
</p>

<ol>
  <li>
  A new type trait, <code>is_trivially_relocatable&lt;T></code>, in the <code>&lt;type_traits></code>
  header. This is the <em>detection</em> mechanism.
  </li>
  <li>
  A new attribute, <code>[[trivially_relocatable]]</code>, in the core language.
  This is the <em>opt-in</em> mechanism for program-defined types.
  </li>
  <li>
  A new core-language rule by which the <code>[[trivially_relocatable]]</code> attribute
  is "inherited" according to the Rule of Zero.
  </li>
  <li>
  A new standard algorithm, <code>uninitialized_relocate(first, last, d_first)</code>,
  in the <code>&lt;memory></code> header.
  </li>
  <li>
  Additional type traits, <code>is_relocatable&lt;T></code> and <code>is_nothrow_relocatable&lt;T></code>,
  in the <code>&lt;type_traits></code> header.
  </li>
</ol>

<p>
The first and third bullets in that list motivate the second bullet. In order to achieve use-case #2,
we <em>must</em> define a core-language mechanism by which we can "inherit" trivial relocatability.
<pre>
    template&lt;class T>
    struct D {
        T t;
    };

    // class C comes in from outside, already marked, via whatever mechanism
    constexpr bool c = is_trivially_relocatable&lt; C >::value;
    constexpr bool dc = is_trivially_relocatable&lt; D&lt;C> >::value;
    static_assert(dc == c);
</pre>
I propose that <code>std::is_trivially_relocatable&lt;T></code> should be just a plain old
class template, exactly like <code>std::is_trivially_destructible&lt;T></code> and so on.
The core language <em>should not know or care</em><sup><a href="#fn_Contra">[Contra]</a></sup> that this class template exists.
</p>

<p>
I propose that the opt-in mechanism should be an attribute. The programmer will mark
<code>C</code> trivially relocatable like this:
<pre>
    struct [[trivially_relocatable]] C {
        C(C&amp;&amp;);  // defined elsewhere
        ~C(); // defined elsewhere
    };
    static_assert(is_trivially_relocatable&lt; C >::value);
</pre>
I expect that, just like <code>is_trivially_destructible</code>, the library vendor will
implement <code>std::is_trivially_relocatable</code> in terms of a non-standard compiler
builtin, whose natural spelling is <code>__is_trivially_relocatable(T)</code>. The compiler
computes the value of <code>__is_trivially_relocatable(T)</code> by inspecting the
definition of <code>T</code> (and the definitions of its base classes and members,
recursively, in the case that both of its special members are defaulted).
</p>

<p>
The fourth and fifth bullets are completely "unnecessary," but should be provided for symmetry with the
other uninitialized-memory algorithms in the <code>&lt;memory></code> header
(<code>uninitialized_copy</code>, <code>uninitialized_move</code>, and <code>destroy</code>)
and the other trios of type-traits in the <code>&lt;type_traits></code> header
(one such trio being <code>is_destructible</code>, <code>is_nothrow_destructible</code>,
<code>is_trivially_destructible</code>). I do not expect these templates to be generally useful,
but I believe they must be provided, so as not to unpleasantly surprise the programmer
by their absence.
</p>


<h2><a name="Wording">4. Proposed wording for C++20</a></h2>

<p>
The wording in this section is relative to WG21 draft N4750,<sup><a href="#N4750">[N4750]</a></sup>
that is, the current draft of the C++17 standard.
</p>

<h1>TODO FIXME BUG HACK</h1>


<h2><a name="Further">5. Further considerations and directions</a></h2>

<h3><a name="swap">5a. Trivially swappable types</a></h3>

<p>
Mingxin Wang<sup><a href="#fn_Wang">[Wang]</a></sup> has proposed that "swap"
could be expressed in terms of "relocate". <code>std::swap</code> today is
typically implemented in terms of one move-construction, two move-assignments,
and one destruction; but there is nothing in the Standard that prevents a library
vendor from implementing it as three relocations, which in the trivially-relocatable
case (the usual case for most types) could be optimized into three calls to
<code>memcpy</code>.
</p>

<p>
For reasons described elsewhere,<sup><a href="#fn_Sane">[Sane]</a></sup> it seems reasonable
to claim that move-assignment must always "do the sane thing," and therefore we
might propose to define
<pre>
    template&lt;class T>
    struct is_trivially_swappable : bool_constant&lt;
        is_trivially_relocatable_v&lt;T> and
        is_move_assignable_v&lt;T>
    > {};
</pre>
thus completing the currently-incomplete trio with
<code>is_swappable</code> and <code>is_nothrow_swappable</code>.
</p>

<p>
However, we do not propose "trivially swappable" at the present time.
It can easily be added in a later paper.
</p>

<h3><a name="hetero">5b. Heterogeneous relocation</a></h3>

<p>
Consider that <code>is_relocatable_v&lt;T></code> means
<code>is_constructible_v&lt;T,T&amp;&amp;> and is_destructible_v&lt;T></code>.
We have access to a heterogeneous <code>is_constructible&lt;T,Us...></code>,
and we have the precedent of a heterogeneous <code>is_swappable_with&lt;T,U></code>.
So, should we add a heterogeneous <code>is_relocatable_from</code>?
</p>

<p>
Notice that <code>uninitialized_copy</code> and <code>uninitialized_move</code>
are already heterogeneous.
Here is what a heterogeneous <code>uninitialized_relocate</code> would look like.
<pre>
template&lt;class FwdIt, class OutIt>
void uninitialized_relocate(FwdIt first, FwdIt last, OutIt d_first) {
    using SrcT = remove_cvref_t&lt;decltype(*first)>;
    using DstT = remove_cvref_t&lt;decltype(*d_first)>;
    static_assert(is_relocatable_from_v&lt;DstT, SrcT>);
    if constexpr (is_trivially_relocatable_from_v&lt;DstT, SrcT>) {
        static_assert(sizeof (SrcT) == sizeof(DstT));
        if constexpr (is_pointer_v&lt;FwdIt> &amp;&amp; is_pointer_v&lt;OutIt>) {
            // Trivial relocation + contiguous iterators = memcpy
            size_t n = last - first;
            if (n) memcpy(d_first, first, n * sizeof (SrcT));
            d_first += n;
        } else {
            while (first != last) {
                memcpy(addressof(*d_first), addressof(*first), sizeof (SrcT));
                ++d_first; ++first;
            }
        }
    } else {
        while (first != last) {
            ::new ((void*)addressof(*d_first)) DstT(move(*first));
            (*first).~SrcT();
            ++d_first; ++first;
        }
    }
    return d_first;
}
</pre>
This implementation could be used to quickly relocate an array of
<code>int*</code> into an array of <code>unique_ptr&lt;int></code>
(but not vice versa). It could also be used to quickly relocate an array of
<code>T</code> into an array of <code>tombstone::optional&lt;T></code>.<sup><a href="#fn_Best">[Best]</a></sup>
All we'd need is for somebody to set the value of <code>is_trivially_relocatable_from</code>
appropriately for each pair of types in the program.
</p>

<p>
I think this is a very intriguing idea. The detection syntax is fairly obvious:
<code>is_trivially_relocatable_from</code>. But I don't see what the opt-in syntax
would look like on a program-defined class such as <code>tombstone::optional</code>.
Let's leave that problem alone for a few years and see what develops.
</p>

<p>
We could provide the detection trait <code>is_trivially_relocatable_from</code> today,
with deliberately curtailed semantics, e.g.:
<pre>
    template&lt;class T, class U>
    struct is_trivially_relocatable_from : bool_constant&lt;
        is_trivially_relocatable_v&lt;T> and
        is_same_v&lt;U, remove_cvref_t&lt;T>>
    > {};
    template&lt;class T, class U>
    struct is_trivially_relocatable_from&lt;T, U&amp;> : is_trivially_relocatable_from&lt;T, U> {};
    template&lt;class T, class U>
    struct is_trivially_relocatable_from&lt;T, U&amp;&amp;> : is_trivially_relocatable_from&lt;T, U> {};
</pre>
plus permission for vendors to extend the trait via partial specializations on
a QoI basis:
<pre>
    template&lt;class T>
    struct is_trivially_relocatable_from&lt;unique_ptr&lt;T>, T*> : true_type {};
    template&lt;class T>
    struct is_trivially_relocatable_from&lt;const T*, T*> : true_type {};
    struct is_trivially_relocatable_from&lt;int, unsigned> : true_type {};
    // and so on
</pre>
However, if we do this, we may soon find that programmers are adding specializations
of <code>is_trivially_relocatable_from</code> to their own programs, because they find it
makes their code run faster. It will become a de-facto customization point, and we will
never be able to "fix it right" for fear of breaking programmers' existing code.
</p>

<p>
Therefore, I believe that we should <em>not</em> pursue "heterogeneous" relocation
operations at the present time.
</p>

<p>
Note that vendors are already free to optimize heterogeneous operations inside
library algorithms, under the as-if rule. We lack a portable and generic detection
trait, but vendors are presumably well aware of specific special cases that they
<em>could</em> detect and optimize today —
for example, a <code>std::copy</code> from an array of <code>int*</code> into
an array of <code>const int*</code>, or from an array of 64-bit <code>long</code> into
an array of 64-bit <code>long long</code>.<sup><a href="#fn_TCF">[TCF]</a></sup>
Today vendors choose not to perform these optimizations.
</p>


<h2><a name="References">6. References</a></h2>

<dl>

<dt><a name="N4750">[N4750]</a></dt>
<dd>
"Working Draft, Standard for Programming Language C++" (May 2018).<br>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf">
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4750.pdf</a>.
</dd>

<dt><a name="fn_Best">[Best]</a></dt>
<dd>
Arthur O'Dwyer. "The Best Type Traits C++ Doesn't Have" (video, April 2018).</br>
<a href="https://www.youtube.com/watch?v=MWBfmmg8-Yo">
https://www.youtube.com/watch?v=MWBfmmg8-Yo</a>.
</dd>

<dt><a name="fn_Bench">[Bench]</a></dt>
<dd>
Benchmark code from "The Best Type Traits C++ Doesn't Have" (April 2018).</br>
<a href="https://github.com/Quuxplusone/from-scratch/blob/095b246d4dc9b88fbdbb6c38771866c0a25289db/cppnow2018/benchmark-relocatable.cc">
https://github.com/Quuxplusone/from-scratch/blob/095b246d4dc9b88fbdbb6c38771866c0a25289db/cppnow2018/benchmark-relocatable.cc</a>.
</dd>

<dt><a name="fn_Contra">[Contra]</a></dt>
<dd>
Arthur O'Dwyer. "<i>Contra</i> built-in library types" (April 2018).<br>
<a href="https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/">
https://quuxplusone.github.io/blog/2018/04/15/built-in-library-types/</a>.
</dd>

<dt><a name="fn_LWG2139">[LWG2139]</a></dt>
<dd>
<a href="https://cplusplus.github.io/LWG/issue2139">LWG 2139
"What is a user-defined type?"</a> resulted in the
adoption of the equally vague phrase "program-defined type" (June 2018).<br>
<a href="https://cplusplus.github.io/LWG/issue3119">LWG 3119
"Program-definedness of closure types"</a> points out that it is
unclear whether closure types count as "program-defined."<br>
For the purposes of this paper, I assume closure types do count
as "program-defined." If you disagree, simply replace the phrase
"program-defined" with "program-defined or closure"
everywhere it appears in this paper, and you won't miss anything.
</dd>

<dt><a name="fn_P1029">[P1029]</a></dt>
<dd>
Niall Douglas. P1029R0 "SG14 [[move_relocates]]" (May 2018).<br>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1029r0.pdf">
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1029r0.pdf</a>.
</dd>

<dt><a name="fn_Sane">[Sane]</a></dt>
<dd>
Arthur O'Dwyer. "Thoughts on 'sanely move-assignable'" (July 2018).<br>
<a href="https://quuxplusone.github.io/blog/2018/07/06/thoughts-on-sanely-move-assignable/">
https://quuxplusone.github.io/blog/2018/07/06/thoughts-on-sanely-move-assignable/</a>.
</dd>

<dt><a name="fn_SV">[SV]</a></dt>
<dd>
The name <code>fixed_capacity_vector</code> is my preferred name for the type
that Boost.Container calls <code>static_vector</code>.
<code>boost::container::static_vector&lt;R,N></code> implements the
less efficient element-by-element-move strategy; moving-out-of a
<code>boost::container::static_vector</code> will not make the source vector
<code>empty()</code>.
</dd>

<dt><a name="fn_TCF">[TCF]</a></dt>
<dd>
Arthur O'Dwyer. "Trivially-constructible-from" (July 2018).<br>
<a href="https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/">
https://quuxplusone.github.io/blog/2018/07/03/trivially-constructible-from/</a>.
</dd>

<dt><a name="fn_Wang">[Wang]</a></dt>
<dd>
Mingxin Wang. "Better Performance in Polymorphic Programming: Trivially Swappable" (June 2018).<br>
<a href="https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ">
https://groups.google.com/a/isocpp.org/d/msg/std-proposals/HGCHVSRwSMk/k7Ir-rmxBgAJ</a>.<br>
See also:<br>
Arthur O'Dwyer. "Trivially swappable" (June 2018).<br>
<a href="https://quuxplusone.github.io/blog/2018/06/29/trivially-swappable/">
https://quuxplusone.github.io/blog/2018/06/29/trivially-swappable/</a>.
</dd>

</dl>

</body>
</html>
