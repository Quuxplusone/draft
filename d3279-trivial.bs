<pre class='metadata'>
Title: CWG2463: What "trivially fooable" should mean
Shortname: D3279
Revision: 1
!Draft Revision: 2
Audience: EWGI
Status: D
Group: WG21
URL:
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  The core-language specification of "trivially copyable," "trivially copy constructible," and "trivially copy assignable"
  fail to match library-writers' expectations. In CWG2463, Core asked for a paper laying out the issues and proposing
  a direction. This is such a paper.
Date: 2024-05-26
</pre>

<style>
prins  {background-color: #DDFFDD; }
ins    {background-color: #CCFFCC; text-decoration: underline;}
del    {background-color: #FFCACA; text-decoration: line-through;}
p      {-moz-hyphens: none; -ms-hyphens: none; -webkit-hyphens: none; hyphens: none;}
</style>

# Changelog # {#changelog}

- R0 (May 2024):

    - Initial revision. See relevant minutes from
        <a href="https://wiki.edg.com/bin/view/Wg21kona2022/CoreWorkingGroup#A_2463._Trivial_copyability_and_unions_with_non_45trivial_members">Kona 2022</a>,
        <a href="https://wiki.edg.com/bin/view/Wg21issaquah2023/NotesEWGCWG2463">Issaquah 2023</a>.

# A consistent mental model (CMM) of triviality # {#consistent}

<div style="float:right;">
<p>... et positae sunt, non quia sic sit, sed ut sentiat discens ...<br>
Dante Alighieri, <i>Quaestio de aquae et terrae</i>

<p>[A] noteworthy characteristic of this manual is that it doesn't always tell the truth.
When certain concepts of TeX are introduced informally, general rules will be stated;
afterwards you will find that the rules aren't strictly true. [...]
The author feels that this technique of deliberate lying will actually make it easier
for you to learn the ideas. Once you understand a simple but false rule,
it will not be hard to supplement that rule with its exceptions.<br>
Donald Knuth, <i>The TeXbook</i>
</div>

## Definition of triviality ## {#consistent-defn}

Certain special member functions are *trivial*. The notion of triviality makes sense
only in relation to some *operation*; for example, we might say that type `T` is trivially default-constructible,
or trivially equality-comparable, or trivially copy-assignable. What it means is precisely
"This operation, performed on `T`'s own value, generates exactly the same code as if we performed
that same operation on `T`'s object representation." (The *object representation* of a `T` object is
the array of bytes that make up its bit-pattern.) [Example:](https://godbolt.org/z/a8YoPznn4)

```c++
template<class T>
struct ObjectRepr {
  alignas(T) char data_[sizeof(T)];
  bool operator==(const ObjectRepr&) const = default;
};

struct TrivDefCt {
  int i;
};
template<class T> void default_construct(T *p) { ::new (p) T; }
template void default_construct(TrivDefCt *);
template void default_construct(ObjectRepr<TrivDefCt> *);
static_assert(__is_trivially_constructible(TrivDefCt));

struct TrivEqCmp {
  int i, j;
  friend bool operator==(TrivEqCmp, TrivEqCmp) = default;
};
template<class T> bool equality_compare(T& p, T& q) { return p == q; }
template bool equality_compare(TrivEqCmp&, TrivEqCmp&);
template bool equality_compare(ObjectRepr<TrivEqCmp>&, ObjectRepr<TrivEqCmp>&);
static_assert(__is_trivially_equality_comparable(TrivEqCmp));
```

It is possible to make a type `T` which is "Platonically" trivially
fooable — that is, `operation_foo(T*)` and `operation_foo(ObjectRepr<T>*)` generate the same code —
even though the compiler doesn't "know" that `T` is trivially fooable — that is, the type-trait returns
false rather than true. This happens for two reasons:

- The compiler never likes to "crack open the curly braces" of a user-defined function to inspect what
    it does — curly-braced bodies are "opaque" to the compiler. So if you implement a curly-braced body
    that does the same thing as `=default`, but you don't actually *spell* it as `=default`, you're
    basically hiding information from the compiler. ([Example.](https://godbolt.org/z/KdKsdvnhh))

- Certain compilers don't understand the notion of "trivially fooable" for certain operations "foo" at all.
    For example, Clang understands the notion of "trivially equality comparable," but GCC does not.
    WG21 occasionally sees proposals for new trivialities; for example, [[P2786]] proposes "relocate"
    as an operation that can be trivial; [[P2782]] proposes "value-initialize" as an operation that can
    be trivial. A compiler that doesn't recognize or track these properties at all, certainly will not
    be able to expose them to the programmer. ([Example.](https://godbolt.org/z/1zzjdaaes))

## Public reductionistic `<type_traits>` ## {#consistent-reductionistic}

Each individual operation that can be trivial, comes with a set of three dedicated type-traits
that expose the (1) accessibility, (2) nothrow-ness, and (3) triviality of that individual operation.

`is_fooable_v<T>` expresses that `T`'s foo operation is public and unambiguous; e.g. `is_copy_assignable_v<T>`
expresses that `t = t` is a well-formed expression.

`is_nothrow_fooable_v<T>` expresses that `T`'s foo operation is public and unambiguous and nothrow, i.e. `noexcept(t = t)`.

`is_trivially_fooable_v<T>` expresses that `T`'s foo operation is public and unambiguous and *trivial*, in the
sense defined above. This kind of trait is useful for algorithm authors, because it lets them optimize
some specific operation foo into memfoo. For example, `std::copy` wants to optimize copy-assignment:

```c++
template<class T>
void stl_copy(T *first, T *last, T *dest) {
  if constexpr (std::is_trivially_copy_assignable_v<T>) {
    memmove(dest, first, (last - first) * sizeof(T));
  } else {
    while (first != last) {
      *dest++ = *first++;
    }
  }
}
```

## Holistic `<type_traits>` ## {#consistent-holistic}

There is one very special type-trait: `is_trivially_copyable_v<T>`.
This exposes a *holistic property* of the type `T`: whether `T`'s *value semantics as a whole*
follow `T`'s object representation. This trait is useful for authors of more complicated
algorithms, like `std::sort`, where it's left unclear or deliberately underspecified exactly
what operations are going to be used. For a *trivially copyable* type `T`, the neat thing is
that it doesn't matter what operations you use to shuffle `T`-values from place to place:
whether you use construction or assignment or swap, copy or move, the values of the `T` objects
will simply follow their object representations.

For example, `std::sort` wants to optimize a conditional-swap function. For trivially copyable
types, we can do it branchlessly ([example](https://godbolt.org/z/z9f5qEjnj)):

```c++
template<class T>
void cond_swap(T *x, T *y) {
  if constexpr (std::is_trivially_copyable_v<T>) { 
    bool r = (*y < *x);
    alignas(T) char bigger[sizeof(T)];
    memcpy(bigger, r ? x : y, sizeof(T)); // cmovg
    memmove(x, r ? y : x, sizeof(T));     // cmovl
    memcpy(y, bigger, sizeof(T));
  } else {
    if (*y < *x) {
      std::swap(*x, *y);
    }
  }
}
```

`is_trivially_copyable` doesn't look at any one specific operation — it looks
at the entire array of value-semantic operations holistically. Therefore, knowing that
a type is trivially copyable doesn't tell you whether that type can actually *be copied*.
Its copy constructor might be `private`; it might be move-only; etc. Most algorithms
will want to check a type-trait (or use a `requires`-expression) to verify that the
caller's `T`'s public API meets their documented requirements. But that verification
is independent of our *optimized implementation*.

[[P1144]] proposes "`is_trivially_relocatable`" as a holistic trait: whether
`T`'s value semantics follow `T`'s object representation as long as `T` is treated
like an affine type (i.e. the `T`-values themselves are conserved, albeit perhaps
relocated from one memory address to another). This would be, by definition, a
superset of `is_trivially_copyable`: every trivially copyable type is trivially relocatable
by definition, but not necessarily vice versa.


# Today's C++ breaks the mental model # {#breaks}

The preceding section laid out a consistent mental model ("the CMM") for thinking about triviality.
This is the model taught and understood today in all codebases and organizations
to whom triviality is relevant.

But this is *not* the model defined in the C++ Standard!

Let's see some problems with the C++ Standard's model.

## `Leopard` ## {#breaks-leopard}

The C++ Standard starts with the term "trivial operation" — which it never defines.
The library defines e.g. `is_trivially_copy_assignable<T>` as true if and only if
the expression `t = t` is well-formed and "is known to call no operation that is not trivial"
(<a href="https://eel.is/c++draft/meta#tab:meta.unary.prop">[meta.unary.prop]</a>).

It is generally understood by vendors that calling a user-defined function is "not trivial";
that calling a defaulted but non-trivial special member function is "not trivial"; and that
any other operation at all *is* "trivial."

Notice the major difference between the Standard's notions and the CMM's. The CMM would say
that "`T` is trivially copy assignable" because of a *relationship* between
the operation `t = t` and the assignment operation of `T`'s object representation: namely,
that those two operations have the same *effect*. The Standard,
in contrast, says that "`T` is trivially copy assignable" because of a property of `t = t`
in isolation, regardless of what *effect* it has on the `T` object's value.

The CMM never needs to talk about whether a given *function implementation* is "trivial,"
except in the colloquial sense that if `t = t` calls `T`'s copy-assignment operator, and
`T` is in fact trivially copy-assignable, then we might colloquially say that `T` "has a
trivial copy-assignment operator" — that is, `T::operator=` implements an assignment operation
that is trivial *for `T`* (with respect to `T`'s object representation specifically).
The Standard, in contrast, lays much significance on the idea that any function at all
can "be trivial" in a vacuum.

[Example:](https://godbolt.org/z/16Y5zsscT)

```c++
struct Cat {};
struct Leopard : Cat {
    int spots_;
    void operator=(Leopard&) = delete;
    using Cat::operator=;
};
static_assert(__is_trivially_assignable(Leopard&, const Leopard&));
```

This `Leopard` has an assignment operator of the form `Cat& Cat::operator=(const Cat&)`,
which is not user-provided.
The expression `leopard = constleopard` calls that assignment operator; therefore it "calls
no operation that is not trivial." Therefore `Leopard` is trivially copy-assignable,
according to the C++ Standard.
Copy-assigning a `Leopard` generates visibly different code from copy-assigning its
object representation; namely, assigning to a `Leopard` does not change its `spots_`.
According to the CMM, `Leopard` *should not* be considered trivially copy-assignable.
Yet, in today's C++, it is.


## `is_trivially_assignable<int&, float>` ## {breaks-int-float}

Today's C++ Standard permits us to talk about whether an expression is "trivial,"
independent of its semantics. So for example the expression `myInt = myFloat` is
considered "trivial" because it "calls no operation that is not trivial" — in fact
it calls no operations at all.

```c++
static_assert(std::is_trivially_assignable_v<int&, float>); // (!)

struct Base { int i; };
struct Pad { int pad; };
struct Simple : Base {};
struct Offset : Pad, Base {};
static_assert(std::is_trivially_assignable_v<Base*&, Simple*>);
static_assert(std::is_trivially_assignable_v<Base*&, Offset*>); // (!)
```

There is a meaningful interpretation of `is_trivially_assignable<T, U>`: By the CMM
it *should* mean that assigning a value of type `U` into an object of type `T` can
be done by copying the object representation, and this will have the correct semantic
effect. But this isn't what it means in today's C++ Standard.

If we adopt the CMM, then we permit library authors to write e.g.

```c++
template<class T, class U>
void stl_copy(T *first, T *last, U *dest) {
  if constexpr (std::is_trivially_assignable_v<U&, T&>) {
    static_assert(sizeof(T) == sizeof(U));
    memmove(dest, first, (last - first) * sizeof(T));
  } else {
    while (first != last) {
      *dest++ = *first++;
    }
  }
}
```

This would permit efficient codegen for e.g. `stl_copy<int, unsigned>` and `stl_copy<Simple*, Base*>`,
while still giving correct (non-trivial) codegen for `stl_copy<float, int>` and `stl_copy<Offset*, Base*>`.
Library vendors can't do this today. [Example:](https://godbolt.org/z/EY7YdafbY)

```c++
void copy_same_type(int **p, int **q) {
    std::copy_n(p, 100, q); // optimal memmove codegen
}

void copy_similar_type(int **p, const int **q) {
    std::copy_n(p, 100, q); // bad looping codegen
}
```

We could give them the tools they need.


## Vendor divergence ## {#breaks-divergence}

```c++
static_assert(!is_trivially_constructible_v<void(*)(), decltype([]{})>);
static_assert(!is_trivially_assignable_v<void(*&)(), decltype([]{})>);
  // Clang, GCC, CMM: Succeed
  // EDG, MSVC: Fail
  // Today's Standard: Unspecified

struct X { int a = 42; };
struct Q { X a, b; };
static_assert(!is_trivially_constructible_v<Q, X>);
  // Clang, CMM: Succeed
  // GCC, EDG, MSVC: Fail
  // Today's Standard: Unclear?

int f();
struct X2 { int a = f(); };
struct Q2 { X2 a, b; };
static_assert(!is_trivially_constructible_v<Q2, X2>);
  // Clang, GCC, MSVC, Today's Standard, CMM: Succeed
  // EDG: Fail

struct E {};
struct R { E a; int b = 42; };
static_assert(!is_trivially_constructible_v<R>);
  // Clang, GCC, MSVC, EDG, Today's Standard, CMM: Succeed
static_assert(!is_trivially_constructible_v<R, E>);
  // CMM: Succeed
  // Clang, GCC, MSVC, EDG, Today's Standard: Fail
```

Notice the divergence on `is_trivially_constructible_v<P, int, int>` below.
This illustrates again the difference between the CMM's notion that only an
operation with meaningful value semantics can ever be implemented *trivially*,
versus the Standard's current notion that any expression at all can be "trivial"
in a vacuum. There is no value-semantic operation "construct `P` from two `int`s"
(because there's no accepted way to make one value out of two values, or one
object representation out of two object representations)
so the CMM doesn't think we ought even to ask whether that operation "is trivial."

```
struct P { int a, b; };
static_assert(is_trivially_constructible_v<P, int, int>);
  // Clang, GCC, MSVC, Today's Standard: Succeed
  // EDG: Fail
  // CMM: Meaningless, therefore deprecated
```









<small><blockquote>
<p>2. For any [complete object] of TC type `T` [...]
the underlying bytes making up the object can be copied into an array of char[, and when]
that array is copied back into the object, the object shall subsequently hold its original value.

<p>3. For two distinct [complete] objects `obj1` and `obj2` of TC type `T`,
if the underlying bytes making up `obj1` are copied into `obj2`,
`obj2` shall subsequently hold the same value as `obj1`.
</blockquote></small>

This means that (by some mystical process) you can use `memcpy` to perform the same Platonic operation as assignment,
even when `T` itself is not assignable. For example:

```c++
struct Stone {
  int i;
  Stone() {}
  Stone(Stone&&) = default;
  void operator=(const Stone&) = delete;
  void operator=(Stone&&) = delete;
  ~Stone() = default;
};

void via_assign(Stone& a, Stone& b) {
  a = b;  // ill-formed
}

void via_memcpy(Stone& a, Stone& b) {
  std::memcpy(&b, &a, sizeof(Stone));  // OK, b now holds the same value as a, by [basic.types.general]/3
}
```

Over the years, CWG participants have suggested different metaphysical explanations for how `memcpy`
does its job in such cases. For example, `memcpy` could "observe" that `Stone` is a TC type, and
decide to perform the abstract-machine operations

```c++
b.~Stone();  // trivial
::new (&b) Stone(std::move(a)); // trivial
```

Moving-from `a` doesn't modify `a`'s value, because its move constructor is trivial.

The abstract-machine-lawyer doesn't care about whether that trivial move-constructor is
selectable by overload resolution, whether it's ambiguous, or private, or anything else;
it suffices for the abstract machine that we have sufficient non-deleted Rule-of-Five members
for the abstract machine's `memcpy` to *somehow* take us from one state to the other.

[The minutes of CWG2463 discussion in Kona, November 2022](https://wiki.edg.com/bin/view/Wg21kona2022/CoreWorkingGroup#A_2463._Trivial_copyability_and_unions_with_non_45trivial_members)
capture the abstract-machine-lawyer's position perfectly:
"A class should be TC if there is a way [i.e., any way] to trivially copy or move it."

Consider again our `vector<T>::insert` from above, which in the library-writer's mind
"uses `memmove` to create an object." The abstract-machine-lawyer knows that what "really"
happens here is that `memmove` implicitly creates an object (<a href="https://eel.is/c++draft/cstring.syn#3">[cstring.syn]/3</a>,
<a href="https://eel.is/c++draft/intro.object#11">[intro.object]/11</a> so that when it copies the
bytes into that object, the new object will take on the proper value (<a href="https://eel.is/c++draft/basic.types#general-3">[basic.types.general]/3</a>).
The copying-of-bytes can still take place by destroying the implicitly created object
and reconstructing a new object; the implicitly created object is
"transparently replaceable" (<a href="https://eel.is/c++draft/basic.life#8">[basic.life]/8</a>)
by the new object.

Now, if our TC type is not an implicit-lifetime type (<a href="https://eel.is/c++draft/class.prop#9">[class.prop]/9</a>),
i.e. it is TC but has no eligible trivial constructors, then the above logic doesn't work;
but in that case we *must* have an eligible trivial copy- or move-assignment operator
(so `memcpy` can do its job by simply calling that assignment operator).

Unfortunately, as we'll see below, today it is possible to create a TC type that is copy-constructible
without giving it an eligible copy constructor. Such a TC type can be put into a `vector`,
and used with `vector::insert`, even though it is not an implicit-lifetime type.
This will be a problem for the abstract-machine-lawyer's intuition.

## Bottom line ## {#intuition-conclusion}

There is a tension between the library-writer's intuition and the abstract-machine-lawyer's intuition.

The library-writer wants C++ to report types as "TC" only if their Rule-of-Five operations
can be safely lowered to `memcpy`. False positives are deadly. Basically, the "TC" label
tells the library-writer that shuffling bytes instead of objects *preserves all library-relevant value-semantic behavior.*

The abstract-machine-lawyer wants C++ to report types as "non-TC" only if it would
never make sense to `memcpy` them at all, because today it is UB to `memcpy` anything
unless it's TC. Basically, the "TC" label is what permits legally shuffling bytes instead of objects *for any reason.*

The library-writer wants a strictly conservative "TC" label, with no false positives,
because each false positive means misbehavior at runtime.
(We'll see some false positives below.)
The abstract-machine-lawyer tends to want a liberal "TC" label, with as few as possible false negatives,
because each false negative means a program that works correctly in practice, but formally has UB.


# Context is important # {#context}

The previous section was about "trivial copyability" in particular; we move now to "trivial fooability"
in general. The C++ Standard doesn't currently recognize it, but *context* is important in two ways.

## SMF "trivial for `X`" ## {#trivial-for-x}

```
struct Cat {};
struct Leopard : Cat {
  int spots_;
  Leopard& operator=(Leopard&) = delete;
  using Cat::operator=;
};
static_assert(std::is_trivially_assignable<Leopard&, const Leopard&>);
```

Today, `Leopard` is `is_trivially_copy_assignable` because when you try to copy-assign a `Leopard`,
overload resolution selects the inherited `Cat::operator=(const Cat&)`. The assignment operator
`Cat::operator=(const Cat&)` is *trivial* (<a href="https://eel.is/c++draft/class.copy.assign#9">[class.copy.assign]/9</a>).
What we're missing is a sense that `Cat::operator=(const Cat&)` is trivial *for `Cat`* but not trivial
*for `Leopard`*.

What should matter to `is_trivially_assignable` (<a href="https://eel.is/c++draft/tab:meta.unary.prop">[meta.unary.prop]</a>)
is not merely that the assignment `declval<Cat&>() = declval<const Cat&>()` call no operation that is not trivial,
but that it call *only* an assignment operation that is *trivial for `Cat`.*

## Type "trivially fooable" in a context ## {#trivial-in-context}

```
class Secretive {
  Secretive(const Secretive&) = default;
  Secretive& operator=(const Secretive&) = default;
  friend class Leaker;
};
```

Today, `Secretive` is `is_trivially_copyable` because all of its special members are trivial.
But `Secretive` is not `is_trivially_copy_assignable`, because it is not `is_copy_assignable` at all.
It is not `is_copy_assignable` because `declval<Secretive&>() = declval<const Secretive&>()`
is not well-formed *in a context unrelated to `Secretive`.*

This is good behavior by the type-trait `is_trivially_copy_assignable`. When library authors use that type-trait,
that's what they're expecting: that a type `X` will be trivially fooable only if it is actually possible for
*my library* (unrelated to `X`) to foo it.

But — important! — this is *not* the behavior we care about when it comes to *propagating* the property.

```
struct Leaker {
  Secretive m_;
  Leaker(const Leaker&) = default;
  Leaker& operator=(const Leaker&) = default;
};
```

`Leaker::operator=(const Leaker&)` is a trivial assignment operator, because overload resolution
*in the context of `Leaker`* successfully selects the trivial `Secretive::operator=(const Secretive&)`
to copy member `m_`.

So `Leaker` is `is_trivially_copy_assignable`, even though it has a member of type `Secretive` which is
not `is_trivially_copy_assignable`.


# Status quo # {#status-quo}

The status quo in the draft Standard today is effectively modified by the proposed resolutions of a lot of CWG issues:

- [CWG 1928](https://cplusplus.github.io/CWG/issues/1928.html) "CWG feels that the triviality of a deleted function should be irrelevant"
- [CWG 2885](https://cplusplus.github.io/CWG/issues/2885.html) "A default constructor for class `X` is *trivial* if..."
- [CWG 2859](https://cplusplus.github.io/CWG/issues/2859.html) "A variable is said to have *vacuous initialization* if..."
- [[P3247]] "Deprecate the notion of trivial types" (i.e. `is_trivial`)


<b>2.</b> `is_trivially_copyable<T>` (<a href="https://eel.is/c++draft/class.prop#1">[class.prop]/1</a>,
<a href="https://eel.is/c++draft/basic#def:type,trivially_copyable">[basic.types.general]/9</a>,
<a href="https://eel.is/c++draft/meta#tab:meta.unary.prop">[meta.unary.prop]</a>).

<small><blockquote>
A *trivially copyable class* is a class:

- that has at least one eligible copy constructor, move constructor, copy assignment operator, or move assignment operator,
- where each eligible copy constructor, move constructor, copy assignment operator, and move assignment operator is trivial, and
- that has a trivial, non-deleted destructor.

Scalar types, trivially copyable class types, arrays of such types, and cv-qualified versions of these types
are collectively called *trivially copyable types.*
</blockquote></small>

<b>3.</b> `is_trivially_constructible<T, Args...>` (<a href="https://eel.is/c++draft/meta#tab:meta.unary.prop">[meta.unary.prop]</a>,
<a href="https://eel.is/c++draft/meta#unary.prop-9">[meta.unary.prop]/9</a>) and
`is_trivially_assignable<T, U>` (<a href="https://eel.is/c++draft/meta#tab:meta.unary.prop">[meta.unary.prop]</a>).

<small><blockquote>
[`is_trivially_constructible<T, Args...>` is true whenever]
the variable definition `T t(declval<Args>()...);` is well-formed
and is known to call no operation that is not trivial.
Access checking is performed as if in a context unrelated to `T` and any of the `Args`.

[`is_trivially_assignable<T, U>` is true whenever]
the expression `declval<T>() = declval<U>()` is well-formed when treated as an unevaluated operand.
and is known to call no operation that is not trivial.
Access checking is performed as if in a context unrelated to `T` and `U`.
</blockquote></small>

Now, this wording depends on the definition of "trivial operation," which the Standard conspicuously fails to define.
In practice, compiler vendors treat every operation as trivial *unless* it is a function call, in which case it
is trivial if-and-only-if it calls a trivial special member function (as defined below).
Notably, `is_trivially_constructible<int, float>` and `is_trivially_constructible<bool, int>` are true
(because they do not call functions) despite not doing anything like a memcpy. Aggregate initialization is
also trivial:

```c++
struct Agg { int i; };
static_assert(std::is_trivially_constructible_v<Agg, int>);
static_assert(std::is_trivially_constructible_v<Agg, float>);
```

Note: There is implementation divergence on lambda conversions, which are arguably "known" to the compiler
despite acting like user-defined conversion functions.
EDG+MSVC say that `is_trivially_constructible<void(*)(), decltype([]{})>` is true; Clang+GCC say false.
EDG+MSVC say that `is_trivially_assignable<void(*&)(), decltype([]{})>` is true; Clang+GCC say false.

Note: There is implementation divergence on NSDMIs, which are arguably "known" to the compiler.
Given `struct X { int a=42; }` and `struct Q { X a, b; }`,
EDG+GCC+MSVC say that `is_trivially_constructible<Q, X>` is true; Clang says that it's false.
(EDG keeps it true even when you change `42` to any arbitrary computation `f()`; that's likely accidental.)
<br>Given `struct E {}` and `struct R { E a; int b=42; }`,
all vendors agree that `is_trivially_constructible<R, E>` is true. Yet
`is_trivially_constructible<R>` is false, because it calls a non-trivial default constructor
(<a href="https://eel.is/c++draft/class.mem#class.default.ctor-3">[class.default.ctor]/3</a>).

Note: There is likely-accidental implementation divergence on aggregate initialization from
multiple arguments.
Given `struct P { int a, b; }`,
EDG says that `is_trivially_constructible<P, int, int>` is false; Clang+GCC+MSVC say true.
We propose to deprecate the three-argument type trait, anyway.

<b>5.</b> A special member function is *trivial* in specific circumstances
(<a href="https://eel.is/c++draft/class.mem#class.default.ctor-3">[class.default.ctor]/3</a>,
<a href="https://eel.is/c++draft/class.mem#class.copy.ctor-11">[class.copy.ctor]/11</a>,
<a href="https://eel.is/c++draft/class.mem#class.copy.assign-9">[class.copy.assign]/9</a>,
<a href="https://eel.is/c++draft/class.mem#class.dtor-8">[class.dtor]/8</a>).

This wording is <prins>modified</prins> by <a href="https://cplusplus.github.io/CWG/issues/2885.html">CWG 2885</a>.

<small><blockquote>
A default constructor is *trivial* if it is not user-provided and if:

- <prins title="CWG 2885">`X`</prins> has no virtual functions and no virtual base classes, and
- no non-static data member of <prins>`X`</prins> has a default member initializer, and
- <prins title="CWG 2885">the constructor selected to default-initialize each direct base class subobject of X is trivial,</prins> and
- for all the non-static data members of its class that are of class type (or array
    thereof), <prins title="CWG 2885">the constructor selected to default-initialize that member (or an array element of that member) is trivial</prins>.

A copy/move constructor for class `X` is *trivial* if it is not user-provided and if:

- class `X` has no virtual functions and no virtual base classes, and
- the constructor selected to copy/move each direct base class subobject is trivial, and
- for each non-static data member of `X` that is of class type (or array thereof),
    the constructor selected to copy/move that member is trivial.

A copy/move assignment operator for class `X` is *trivial* if it is not user-provided and if:

- class `X` has no virtual functions and no virtual base classes, and
- the assignment operator selected to copy/move each direct base class subobject is trivial, and
- for each non-static data member of `X` that is of class type (or array thereof), the assignment
    operator selected to copy/move that member is trivial.

A destructor is *trivial* if it is not user-provided and if:

- the destructor is not virtual,
- all of the direct base classes of its class have trivial destructors, and
- for all of the non-static data members of its class that are of class type (or array thereof),
    each such class has a trivial destructor.

</blockquote></small>

Two more critical things to keep in mind for the following examples:

* A copy constructor, copy assignment operator, etc, is never a template. So you can have a poorly-matching
    trivial copy constructor living alongside a non-trivial constructor template that is a better match;
    yet this will not cause `is_trivially_copyable` to become false, because a constructor template
    is not a copy constructor. All of your copy constructors remain trivial.

* The current Standard lacks the notion of "trivial *for* `X`" that we introduced in [[#trivial-for-x]].
    An inherited member will continue to be "trivial" in the child just as it was (correctly) trivial in
    the parent.

# Surprising behaviors # {#surprise}

## TC types can have non-TC members ## {#surprise-cwg2463}

This is [[CWG2463]] ([Godbolt](https://godbolt.org/z/jhaEd6YYY)):

```c++
struct Hamlet {
  Hamlet(const Hamlet&) { puts("copied"); }
  Hamlet(Hamlet&&) = default;
  Hamlet& operator=(Hamlet&&) = default;
};
struct Nutshell {
  Hamlet h_;
  Nutshell(Nutshell&&) = default;
  Nutshell& operator=(Nutshell&&) = default;
};
static_assert(!std::is_trivially_copyable_v<Hamlet>);
static_assert(std::is_trivially_copyable_v<Nutshell>);
```

Note: There is implementation divergence. EDG+MSVC say `std::is_trivially_copyable<Nutshell>` is true; Clang+GCC say false.
EDG+MSVC are certainly correct according to the Standard.

To paraphrase Daveed Vandevoorde's comment on that issue:
"It is unclear why a complete object of type `Hamlet` cannot be memcpyed but such an object can be memcpyed when embedded in a `Nutshell`."
That is, this example is problematic to the abstract-machine-lawyer intuition that TC-ness ought to follow the *definedness* of `memcpy`.
It doesn't really make sense to say that `memcpy` is capable of transferring the value of a `Hamlet` object only
when it's a subobject of a `Nutshell` and not otherwise.

But to the library-writer intuition, this example is perfectly sane: TC means "all provided operations are tantamount to `memcpy`,"
which is clearly untrue of `Hamlet` and clearly true of `Nutshell` — because `Nutshell` provides fewer operations. `Nutshell` snips away
`Hamlet`'s non-trivial copy constructor, so that all the remaining operations are in fact trivial.
We need `Hamlet` to remain non-TC so that we don't misoptimize `std::uninitialized_copy(Hamlet)`; but we are
happy for `Nutshell` to be TC so that we can optimize `std::uninitialized_move(Nutshell)`. We aren't worried about misoptimizing
`std::uninitialized_copy(Nutshell)` because that's already ill-formed diagnostic required.

Finally, this example is problematic for the compiler-writer intuition. We want to be able to track a single bit, "`Hamlet` is non-TC,"
and propagate that down into `Nutshell`. But this example shows that we must track *exactly why* `Hamlet` is non-TC!
This `Hamlet2` differs only in that it has a non-trivial move-assignment operator ([Godbolt](https://godbolt.org/z/a86Kd1Y73)):

```c++
struct Hamlet2 {
  Hamlet2(const Hamlet2&) { puts("copied"); }
  Hamlet2(Hamlet2&&) = default;
  Hamlet2& operator=(Hamlet2&&); // not defaulted
};
struct Nutshell {
  Hamlet2 h_;
  Nutshell(Nutshell&&) = default;
  Nutshell& operator=(Nutshell&&) = default;
};
static_assert(!std::is_trivially_copyable_v<Hamlet2>);
static_assert(!std::is_trivially_copyable_v<Nutshell>);
```

Non-TC `Hamlet` embedded in a `Nutshell` becomes TC; non-TC `Hamlet2` embedded in the same `Nutshell` stubbornly remains non-TC.
So it's not the TC-ness of `Hamlet` that matters; it's something else — something that takes more than one bit to represent
in the compiler.


## Types can act non-trivially while publicly advertising TC ## {#surprise-false-advertising}

Microsoft STL's `std::pair<int&, int&>` advertises itself as TC, despite not modeling trivial copyability.
To falsely advertise yourself as TC, recall that there are several possible signatures for a "copy assignment operator,"
and user-declaring any such signature (even an out-of-the-way one, even deleted) suffices to keep the compiler
from implicitly generating any defaulted `operator=` for your class. Meanwhile, you provide assignment from
`const Plum&` via a template (recall that the compiler never considers a template to be a Rule-of-Five special
member). [Godbolt](https://godbolt.org/z/Mo95zjTsc):
```c++
struct Plum {
  int *ptr_;
  explicit Plum(int& i) : ptr_(&i) {}
  Plum(const Plum&) = default;
  void operator=(const volatile Plum&) = delete;
  template<class=void> void operator=(const Plum& rhs) {
    *ptr_ = *rhs.ptr_;
  }
};
static_assert(std::is_trivially_copyable_v<Plum>);
static_assert(std::is_assignable_v<Plum&, const Plum&>);
static_assert(!std::is_trivially_assignable_v<Plum&, const Plum&>);
```

Microsoft STL's `std::reverse_copy` will see that `Plum` is trivially copyable and assume (following the library-writer's
intuition) that it can be lowered to `memcpy`. So `std::reverse_copy(Plum)` is miscompiled. (By luck, `std::reverse_copy(pair)` is
miscompiled only on 32-bit platforms, because Microsoft's `reverse_copy` optimization is also gated on `sizeof(T) <= 8`.)
libstdc++ will miscompile `std::copy(Plum)` ([bug #114817](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=114817))
and several other algorithms.

This example isn't problematic for the compiler-writer nor the abstract-machine-lawyer. But it is shocking to
everyone's intuition because it shows that we can easily use corner cases in the wording to decouple the
"advertised" TC-ness of a type from its "proper" semantic TC-ness. (See [[Müller]] and [[ODwyer]].)

Show this example to the library-writer and when they recover from the shock they'll say:
"Okay, so we shouldn't gate our `copy` and `reverse_copy` optimizations on TC. We'll gate them on
the more granular `is_trivially_copy_assignable` trait, instead." The next section shows how that
gate, also, is broken.


## "Trivial" Rule-of-Five functions can act unlike memcpy ## {#surprise-leopard}

The rule for calling a special member function "trivial" lacks context. Once trivial, always trivial.
So if you inherit a member function from your base class, it will continue to "be trivial" for you,
just like it was trivial for your base class. This allows us to make class `Leopard` which never
changes its `spots_` — and yet, the type-traits report that everything about it is trivial
([Godbolt](https://godbolt.org/z/GGP4e7Wqz)):
```c++
struct Cat {};
struct Leopard : Cat {
    int spots_;
    Leopard& operator=(Leopard&) = delete;
    using Cat::operator=;
};
static_assert(is_trivially_copyable_v<Leopard>);
static_assert(is_trivially_assignable_v<Leopard&, const Leopard&>);

void test(Leopard& a, const Leopard& b) {
  a = b; // absolutely no data is copied
}
```

This is supremely problematic for the library-writer. Every STL vendor miscompiles `std::copy(Leopard)` —
they assume that because `is_trivially_copy_assignable_v<Leopard>`, therefore copying a contiguous range
of `Leopard` can be lowered to `memmove`. But in fact that's wrong.

I see no way to fix everybody's `std::copy(Leopard)` on the library side. The only way forward
is to fix the definition of triviality in the core language.


# Proposal # {#proposal}

Basically, we propose to respecify all of the traits to conform with the library-writer's intuition.
(For each case below, read "can be" as "is known to the compiler to be able to be".)

- `is_trivially_constructible<T>` should mean precisely that constructing a `T` from no arguments
    can be lowered to a no-op. (This is basically the status quo in practice.)

- `is_trivially_constructible<To, From>` should mean precisely that constructing a (complete) `To` from a `From`
    can be lowered to memcpy. (E.g. `is_trivially_constructible<float, int>` should become false; but
    `is_trivially_copy_constructible<Polymorphic>` should become frequently true.)

- `is_trivially_constructible<To, Args...>` for any number of `Args...` greater than 1 should be invariably false,
    and we should deprecate it. That trait is useless because it corresponds to nothing physical.

- `is_trivially_destructible<T>` should mean precisely that destroying a `T` can be lowered to a no-op.
    (This is the status quo in practice.)

- `is_trivially_assignable<To, From>` should mean precisely that assigning a (complete) `To` from a `From`
    can be lowered to memcpy. (E.g. `is_trivially_assignable<float&, int&>` should become false.)

- `is_trivially_copyable<T>` should mean that all the Rule-of-Five operations that `T` supports,
    no matter the cvref-qualification of the arguments, can be lowered to memcpy. That is,
    it should mean exactly:

<small>
```c++
constexpr bool implies(bool a, bool b) { return b || !a; }
template<class T>
inline constexpr bool is_trivially_copyable_v = 
  implies(is_constructible_v<T, T&>,        is_trivially_constructible_v<T, T&>) &&
  implies(is_constructible_v<T, T&&>,       is_trivially_constructible_v<T, T&&>) &&
  implies(is_constructible_v<T, const T&>,  is_trivially_constructible_v<T, const T&>) &&
  implies(is_constructible_v<T, const T&&>, is_trivially_constructible_v<T, const T&&>) &&
  implies(is_assignable_v<T&, T&>,          is_trivially_assignable_v<T&, T&>) &&
  implies(is_assignable_v<T&, T&&>,         is_trivially_assignable_v<T&, T&&>) &&
  implies(is_assignable_v<T&, const T&>,    is_trivially_assignable_v<T&, const T&>) &&
  implies(is_assignable_v<T&, const T&&>,   is_trivially_assignable_v<T&, const T&&>) &&
  implies(is_destructible_v<T>,             is_trivially_destructible_v<T>);
```
</small>

Each of the above definitions models the library-writer's intuition that "`T` is trivially fooable"
means no more or less than "the foo operation on `T` can be lowered to the foo operation on `T`'s object
representation." (With the special case that TC refers to *all* supported value-semantic operations, as a package deal.
Something like this definition of TC was independently suggested by Casey Carter in
<a href="https://reviews.llvm.org/D86126#2223156">an August 2020 PR comment</a>.)
This intuition applies uniformly to every "triviality" trait in today's Standard Library,
and several more that have been proposed and/or implemented by vendors:

<small>

- trivially default-constructible (*sic*; read "default-initializable")
- trivially value-initializable ([[P2782]])
- trivially (copy|move)-constructible
- trivially (copy|move)-assignable
- trivially destructible
- trivially equality-comparable (Clang's `__is_trivially_equality_comparable` builtin)
- trivially lexicographically-comparable (defined internally by libc++)
- trivially swappable

</small>

The wording might look like:

<blockquote><small>
[`is_trivially_constructible<T, Args...>` is true if and only if]
`is_constructible_v<T, Args...>` is `true` and the variable definition for `is_constructible`,
as defined below, is known to <del>call no operation that is not trivial</del> <ins>be equivalent
in its observable effects to a simple copy of the complete object representation (when `sizeof...(Args) == 1`)
or to have no observable effects (when `sizeof...(Args) == 0`)</ins>. <ins>When
`sizeof...(Args) >= 2`, yields `false`; this usage is deprecated.</ins>

[`is_trivially_assignable<T, U>` is true if and only if]
`is_assignable_v<T, U>` is `true` and the assignment, as defined by `is_assignable`,
is known to <del>call no operation that is not trivial</del> <ins>be equivalent
in its observable effects to a simple copy of the complete object representation</ins>.

[`is_trivially_destructible<T>` is true if and only if]
`is_destructible_v<T>` is `true` and `remove_all_extents_t<T>` is <del>either a non-class type
or a class type with a trivial destructor</del> <ins>a type whose destructor is known to have
no observable effects</ins>.
</small></blockquote>

Note: I haven't found a way to break `is_trivially_destructible` yet, so maybe it doesn't
need to change. Here I'm just making it consistent with the others.

This proposal breaks a lot of eggs, but it makes a good omelet.

It would allow the following naïve code to Just Work, even though it is buggy today
([Godbolt](https://godbolt.org/z/6o388YTzd)):

```c++
template<class T, class U>
U *simple_copy(T *first, T *last, U *dfirst) {
  static_assert(std::is_assignable_v<T&, U&>);
  if constexpr (std::is_trivially_assignable_v<T&, U&>) {
    static_assert(sizeof(T) == sizeof(U));
    std::memmove(dfirst, first, (last - first) * sizeof(T));
    return dfirst + (last - first);
  } else {
    while (first != last) *dfirst++ = *first++;
  }
}

int main() {
  int source[] = {1,2,3};
  float dest[] = {1,2,3};
  simple_copy(source, source+3, dest);
  printf("%f %f %f\n", dest[0], dest[1], dest[2]);
}
```

Note: Okay, to really make `std::copy` work, you also need a special case for `n == 1` and/or `__datasizeof`,
because a single-object range might consist of a single potentially overlapping subobject. But vendors already
know that pitfall, and deal with it. See <a href="https://quuxplusone.github.io/blog/2018/07/13/trivially-copyable-corner-cases/">my blog post of July 2018</a>.

This proposal opens the door for vendor-specific extensions to permit e.g. `is_trivially_constructible<unique_ptr<int>, int*>`.
This is perfectly safe by the library-writer's intuition, since `uninitialized_copy`'ing a range
of `unique_ptr<int>` from a range of `int*` can indeed be safely lowered to memcpy. How should the author of `unique_ptr`
warrant triviality to the compiler, so that the compiler can reflect it back to the author of `uninitialized_copy`?—
We should leave that up to the vendor to figure out; but one possible extension would be

```c++
struct UniquePtr {
  int *p_;
  [[clang::trivial]] explicit UniquePtr(int *p);
  ~UniquePtr();
};
```

I believe this proposal completely eliminates all references to "trivial operations" and "trivial functions"
(other than trivial special members). That's nice, because the Standard never defines what those are.
By removing all references to them, we *never* have to define what they are.

By permitting vendors to define `is_trivially_copy_constructible<FinalPolymorphic>`, this proposal solves an issue
recently raised for Clang by Haojian Wu; see [[BitwiseCopyable]]. Library authors really want to be able to
memcpy and/or start-the-lifetime-of polymorphic types. That works in practice, but today it's technically UB
because polymorphic types never have any trivial constructors and therefore are never implicit-lifetime types
(<a href="https://eel.is/c++draft/class.prop#9">[class.prop]/9</a>). But the compiler knows that a `final`
polymorphic type can be trivially copied, and therefore could consider it to be implicit-lifetime. This
could solve a large swath of Haojian's problem without needing Clang to provide a separate builtin,
although it probably doesn't solve the whole problem.

Note: Non-`final` polymorphic types can never be trivially copied nor trivially assigned, because of slicing.
See <a href="https://quuxplusone.github.io/blog/2023/06/24/polymorphic-types-arent-trivially-relocatable/">my blog post of June 2023</a>.

Finally, we need to do something with <a href="https://eel.is/c++draft/basic.types#general-2">[basic.types.general]/2–3</a>.
Given the proposed wording above, I think we could just
strike [basic.types.general]/2–3 as redundant:
obviously, *if* a type is trivially copy-assignable by the new wording (let alone TC), then copying its object representation
also copies its value, by definition. Striking those two paragraphs would also save us from having to define
what the "[original] value" of an object means, standardese-wise.

<a href="https://eel.is/c++draft/basic.types#general-4">[basic.types.general]/4</a> says:
"For trivially copyable types, the *value representation* is a set of bits in the object representation
that determines a value, which is one discrete element of an implementation-defined set of values."
This sentence doesn't seem useful, but also isn't harmful; we can let it be.


## Conclusion ## {#conclusion}

This proposal is drastic and breaks a lot of eggs, but makes a good omelet.
We would come out the other side with a type-traits library that is actually usable
by library-writers. Library-writers are already quietly assuming that the traits
work this way, so bringing the Standard into line with those assumptions would
immediately close a lot of library bugs.

I plan to bring an R1 with formal wording, and hope to also gain some implementation
experience in my fork of Clang. Assistance will be gratefully accepted.


# Acknowledgments # {#acknowledgments}

Thanks to Ville Voutilainen and Giuseppe D'Angelo for their encouragement and discussion.

Thanks to the regulars on the cpplang Slack for rubber-ducking a lot of these examples.


<pre class=biblio>
{
  "BitwiseCopyable": {
    "title": "[clang] Implement a bitwise_copyable builtin type trait",
    "authors": [
      "Haojian Wu"
    ],
    "href": "https://github.com/llvm/llvm-project/pull/86512",
    "date": "March 2024—"
  },
  "CWG1734": {
    "title": "Nontrivial deleted copy functions",
    "authors": [
      "James Widman"
    ],
    "href": "https://cplusplus.github.io/CWG/issues/1734.html",
    "date": "August 2013–February 2016"
  },
  "CWG2463": {
    "title": "Trivial copyability and unions with non-trivial members",
    "authors": [
      "Daveed Vandevoorde"
    ],
    "href": "https://cplusplus.github.io/CWG/issues/2463.html",
    "date": "November 2020—"
  },
  "Müller": {
    "title": "Trivially copyable does not mean trivially copy constructible",
    "authors": [
      "Jonathan Müller"
    ],
    "href": "https://www.foonathan.net/2021/03/trivially-copyable/",
    "date": "March 2021"
  },
  "ODwyer": {
    "title": "Types that falsely advertise trivial copyability",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://quuxplusone.github.io/blog/2024/05/15/false-advertising/",
    "date": "May 2024"
  },
  "P2782": {
    "title": "A type trait to detect if value initialization can be achieved by zero-filling",
    "authors": [
      "Giuseppe D'Angelo"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2782r0.html",
    "date": "January 2023"
  },
  "P3247": {
    "title": "Deprecate the notion of trivial types",
    "authors": [
      "Jens Maurer"
    ],
    "href": "https://open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3247r0.html",
    "date": "April 2024"
  }
}
</pre>
