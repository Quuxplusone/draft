<pre class='metadata'>
Title: Resolve inconsistencies in begin/end for <code>valarray</code> and braced initializer lists
Shortname: D3016
Revision: 2
!Draft Revision: 9
Audience: LEWG
Status: D
Group: WG21
URL:
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  We show that some inconsistencies between non-member `begin` and `cbegin`
  applied to `valarray` and to braced initializer lists were caused by
  C++0x uncertainty around [stmt.ranged], and resolve these inconsistencies
  for C++26.
Date: 2024-01-15
</pre>

<style>
hilite  {background-color: #FFFF00; font-weight: bold;}
ins     {background-color: #CCFFCC; text-decoration: underline;}
del     {background-color: #FFCACA; text-decoration: line-through;}
</style>

# Changelog # {#changelog}

- R2:

    - Mention [[P2613]] and [[LWG4035]] as further precedent for `initializer_list.empty()`.

- R1:

    - Split [[CWG2825]] from this paper; this paper is now library-only.

    - Add discussion of `.data()` and `.empty()` overloads (proposed but undiscussed in R0).

    - Add wording for ".data+.size cleanup."


# Motivation and proposal # {#proposal}

Casey Carter [points out](https://lists.isocpp.org/lib/2023/10/26795.php)
that the following program is supported by libstdc++ but not libc++ nor Microsoft
([Godbolt](https://godbolt.org/z/WK37KbGss)):

```cpp
#include <iterator>
#include <valarray>
int main() {
  std::valarray<int> v = {1,2,3};
  std::begin(v); // OK
  std::cbegin(v); // Error
}
```

This is because `std::valarray` defines its own non-member, non-hidden-friend overloads
of `std::begin` and `std::end`. These overloads are found by the qualified call to `std::begin`
here, but aren't found by `std::cbegin`'s ADL because the primary template for `std::cbegin`
happens to be defined before `<valarray>` is included. Swapping the order of `#include <iterator>`
and `#include <valarray>` in this example doesn't help, because the relevant *parts* of `<iterator>`
are still transitively included by `<valarray>` before `std::valarray`'s own code.

Likewise, on all vendors ([Godbolt](https://godbolt.org/z/fnjj4WWGo)):

```cpp
#include <iterator>
int main() {
  std::begin({1,2,3}); // OK
  std::cbegin({1,2,3}); // Error
}
```

This is because `{1,2,3}` is a *braced-initializer-list* with no type; so it cannot bind to
the deduced `const C&` in <a href="https://en.cppreference.com/w/cpp/iterator/begin">`std::cbegin`</a>
(defined in `<iterator>`).
But it *can* bind to the `initializer_list<E>` in the non-member, non-hidden-friend overload
<a href="https://en.cppreference.com/w/cpp/utility/initializer_list/begin2">`std::begin(std::initializer_list<E>)`</a>
(defined in `<initializer_list>`).

Notice that `std::begin({1,2,3})` returns an iterator that will dangle at the end of the full-expression,
and that the return values of `std::begin({1,2,3})` and `std::end({1,2,3})` do not form a range
(because the two lists' backing arrays may be different). Therefore this overload's functionality is
more harmful than helpful.

Note: Be careful to distinguish the scenario of calling `std::begin`
on <em>an object of type `initializer_list`</em> (helpful!) from calling it on <em>a braced-initializer-list</em>
(harmful).

We propose to resolve `valarray`’s `begin`/`cbegin` inconsistency in favor of "make it work"
and to resolve *braced-initializer-list*’s inconsistency in favor of "make it ill-formed."

## .data and .empty ## {#data-empty}

We also propose two additional member functions for `std::initializer_list`: `.data()` and `.empty()`.

Many places in the library clauses would like to operate on
the contiguous data of an `initializer_list` using the "data + size" idiom, but since `initializer_list`
lacks `.data()`, they're forced to use an awkward "begin + size" approach instead. This (1) looks unnatural
and (2) causes extra mental effort for library writers. Part of P3016's proposed wording is to update
these places in the library. For example:

<small><blockquote>
<pre>
constexpr basic_string& append(const basic_string& str);
</pre>
<p>1. *Effects:* Equivalent to <code>return append(str.data(), str.size());</code>
<p>[...]
<p><pre>
constexpr basic_string& append(initializer_list&lt;charT> il);
</pre>
<p>16. *Effects:* Equivalent to <code>return append(<ins>il.data(), il.size()</ins> <del>il.begin(), il.size()</del>);</code>
</blockquote></small>

As for `.empty()`, it is generally recognized these days that ranges providing `.size()` should also
provide `.empty()`. For example, `iota_view`'s missing `.empty()` was added as a DR by [[LWG4001]].
[[LWG4035]] adds `single_view`'s missing `.empty()`.
[[P2613]], which added `mdspan`'s missing `.empty()`, claims that `initializer_list` and `bitset` remain
the only two types with `.size()` and without `.empty()`.

By making `il.data()` and `il.empty()` well-formed for `std::initializer_list` objects, we satisfy the SFINAE
conditions of the primary templates for `std::data(il)` and `std::empty(il)`, meaning that we can eliminate
their special overloads for `initializer_list` arguments.

<table>
<tr>
<td>
```cpp
  std::initializer_list<int> il = {1,2,3};
  const int *p = std::data(il);
    // OK, calls the initializer_list overload
    // specially provided in <iterator>
  bool b = std::empty(il);
    // OK, calls the initializer_list overload
    // specially provided in <iterator>
```
</td>
<td>
```cpp
  std::initializer_list<int> il = {1,2,3};
  const int *p = std::data(il);
    // OK, calls the primary template
  bool b = std::empty(il);
    // OK, calls the primary template
```
</td>
</tr>
<tr>
<td>
```cpp
  const int *p = std::data({1,2,3});
    // calls the initializer_list overload
    // specially provided in <iterator>,
    // and immediately dangles
  const int *q = std::data({});
    // does not compile
```
</td>
<td>
```cpp
  const int *p = std::data({1,2,3});
    // does not compile
  const int *q = std::data({});
    // does not compile
```
</td>
</tr>
<tr>
<td>
```cpp
  bool b = std::empty({1,2,3});
    // calls the initializer_list overload
    // specially provided in <iterator>,
    // invariably returns false
  bool c = std::empty({});
    // does not compile
```
</td>
<td>
```cpp
  bool b = std::empty({1,2,3});
    // does not compile
  bool c = std::empty({});
    // does not compile
```
</td>
</tr>
</table>


# Historical background # {#history}

[[N2930]] "Range-Based For Loop Wording (Without Concepts)" (2009) proposed that
<a href="https://eel.is/c++draft/stmt.ranged">[stmt.ranged]</a> should consider only free function `begin(x)` plus a special case
for built-in arrays; therefore N2930 added both `<iterator>`'s `std::begin` and
`<initializer_list>`'s `std::begin` — because they wanted `<initializer_list>` not to pull in
`<iterator>`, and `initializer_list`'s member function `begin()` wasn't going to be found by
their proposed [stmt.ranged].

Then, [[N3271]] "Wording for Range-Based For Loop (Option #5)" (2011) added the middle
bullet point in today's version of [stmt.ranged]:

<blockquote><small>

* if `_RangeT` is an array type, *begin-expr* and *end-expr* are `__range` and `__range + __bound`,
    respectively, where `__bound` is the array bound. If `_RangeT` is an array of unknown size
    or an array of incomplete type, the program is ill-formed;

* <ins>if `_RangeT` is a class type, the *unqualified-ids* `begin` and `end` are looked up in the
    scope of class `_RangeT` as if by class member access lookup, and if either (or both)
    finds at least one declaration, *begin-expr* and *end-expr* are `__range.begin()` and `__range.end()`, respectively;</ins>

* otherwise, *begin-expr* and *end-expr* are `begin(__range)` and `end(__range)`, respectively,
    where `begin` and `end` are looked up with argument-dependent lookup. For the purposes of
    this name lookup, namespace `std` is an associated namespace.

</small></blockquote>

This change meant that `std::initializer_list` no longer needed to provide
free `begin`/`end`: The new second bullet lets us use `il.begin()` and `il.end()`,
so the third bullet is never reached when `decltype(__range)` is `initializer_list`.
(Loops of the form `for (int i : {1,2,3})` are subtle because the *for-range-initializer*
is a *braced-initializer-list* with no type. [[CWG2825]] addressed this; GCC, Clang, and EDG
already implement the resolution.)

Meanwhile, since the prioritized customization point in [stmt.ranged] had shifted from
non-member `begin` to member `begin`, it would have made sense for `std::valarray`'s `begin`
to change from a non-member to a member. But this was not done — possibly out of C++0x–era
concerns that giving `std::valarray` member `begin`/`end` would make it "too much like a container."
[[LWG2058]] (2011) contains comments like: "The intent of these overloads is entirely to support
the new for syntax, and not to create new containers." In other words, we wanted `valarray`
to be iterable, without looking too much like a new kind of STL container. In 2011, we didn't have a word for
that. In 2023, we do: `valarray` is a *range*, just like `array` or `span`, and there's
nothing wrong with a *range* having member `begin` and `end`. (P3016 proposes to make it so.)

Similarly, `valarray<T>::iterator` is currently ill-formed even though `ranges::iterator_t<valarray<int>>`
is well-formed; `std::rbegin(valarray)` is ill-formed even though `ranges::rbegin(valarray)`
is well-formed; and so on.

Finally, [[LWG2128]] added overloads of `rbegin`/`rend` for `initializer_list`.
The primary template for `rbegin` doesn't work for `initializer_list` because it
simply calls `c.rbegin()` — it never attempts to do `make_reverse_iterator(c.end())`
because `make_reverse_iterator` isn't SFINAE-friendly. LWG2128's overloads are important
because they allow us to write ([Godbolt](https://godbolt.org/z/n75jeM3h6)):

```cpp
    template<class C>
    void f(const C& c) {
      using std::rbegin, std::rend;
      for (auto it = rbegin(c); it != rend(c); ++it) {}
    }
    void g(std::initializer_list<T> il) {
      f(il);
    }
    int main() {
      g({1,2,3});
    }
```

These were added in `<iterator>`, not in `<initializer_list>`, because they depend on `reverse_iterator`.

However, notice that LWG2128 did *not* add two things:

* `std::cbegin(initializer_list<E>)`. This omission indicates that it was not considered important
    to support `std::cbegin({1,2,3})`. Unsurprising, as the returned iterator would dangle.

* `std::cbegin(const valarray<T>&)`, `std::rbegin(valarray<T>&)`, `std::rbegin(const valarray<T>&)`, `std::crbegin(const valarray<T>&)`.
    These omissions might have been accidental; `<valarray>` is easy to overlook.
    Or, they might indicate the [[LWG2058]] mindset: `valarray` wasn't intended to be fully rangified,
    merely iterable with [stmt.ranged], and [stmt.ranged] didn't need `cbegin` or `rbegin`.


# Implementation experience # {#experience}

Arthur has implemented [[#wording]] in his fork of libc++, and used it to compile
both LLVM/Clang/libc++ and another large C++17 codebase. Naturally, it caused
no problems except in this single test from libc++'s own test suite:

```cpp
    #include <initializer_list> // but not <iterator>
    std::initializer_list<int> il;
    static_assert(noexcept(std::begin(il)));
```

This test now fails first because `<iterator>` was not included, and second
because today's `begin(initializer_list<E>)` is noexcept
but the primary template `begin(C&)` is non-noexcept
(per <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0884r0.pdf">P0884</a> guidance).

`il.begin()` and `ranges::begin(il)` remain noexcept.

`std::begin(valarray)` remains non-noexcept.


## Tony Table ## {#tony-table}

<table>
<tr>
<td>
```cpp
  #include <initializer_list>
  void f(std::initializer_list<int> il) {
    auto it = std::begin(il);
  }
```
</td>
<td>
```cpp
  #include <initializer_list>
  #include <iterator> // for std::begin
  void f(std::initializer_list<int> il) {
    auto it = std::begin(il);
  }
```
</td>
</tr>
<tr>
<td>
```cpp
  S(std::initializer_list<int> il) :
    S(il.begin(), il.size()) {}
```
</td>
<td>
```cpp
  S(std::initializer_list<int> il) :
    S(il.data(), il.size()) {}
```
</td>
</tr>
<tr>
<td>
```cpp
  auto dangle = std::begin({1,2,3});
```
</td>
<td>
```cpp
  // no longer compiles
```
</td>
</tr>
<tr>
<td>
```cpp
  bool b = std::empty({1,2,3});
    // calls the initializer_list overload
    // specially provided in <iterator>,
    // yielding false
```
</td>
<td>
```cpp
  bool b = std::empty({1,2,3});
    // does not compile
```
</td>
</tr>
<tr>
<td>
```cpp
  #include <valarray>
  #include <utility>
  std::valarray<int> va;
  auto it = std::begin(std::as_const(va));
```
</td>
<td>
```cpp
  #include <valarray>
  #include <iterator>
  std::valarray<int> va;
  auto it = std::cbegin(va);
```
</td>
</tr>
</table>

# Proposed wording # {#wording}

## [valarray.syn] ## {#wording-valarray.syn}

Modify <a href="https://eel.is/c++draft/valarray.syn">[valarray.syn]</a> as follows:

<small><blockquote>
[...]

<pre>
  template&lt;class T> valarray&lt;T> tan  (const valarray&lt;T>&);
  template&lt;class T> valarray&lt;T> tanh (const valarray&lt;T>&);

  <del>template&lt;class T> unspecified1 begin(valarray&lt;T>& v);</del>
  <del>template&lt;class T> unspecified2 begin(const valarray&lt;T>& v);</del>
  <del>template&lt;class T> unspecified1 end(valarray&lt;T>& v);</del>
  <del>template&lt;class T> unspecified2 end(const valarray&lt;T>& v);</del>
}
</pre>

[...]

3․ Any function returning a `valarray<T>` is permitted to return an object of another type,
provided all the const member functions of `valarray<T>` are also applicable to this type.
This return type shall not add more than two levels of template nesting over the most deeply nested argument type.

4․ Implementations introducing such replacement types shall provide additional functions and operators as follows:

- (4.1) for every function taking a `const valarray<T>&` <del>other than `begin` and `end`</del>,
    identical functions taking the replacement types shall be added;

- (4.2) for every function taking two `const valarray<T>&` arguments,
    identical functions taking every combination of `const valarray<T>&` and replacement types shall be added.

5․ In particular, an implementation shall allow a `valarray<T>` to be constructed from such replacement types
and shall allow assignments and compound assignments of such types to `valarray<T>`, `slice_array<T>`, `gslice_array<T>`,
`mask_array<T>` and `indirect_array<T>` objects.

[...]
</blockquote></small>

## [template.valarray.overview] ## {#wording-template.valarray.overview}

Note: We propose exposition-only `iterator` and `const_iterator` typedefs, but would
love to make them non-exposition-only.

Note: The `.size()` and `.begin()` members of every STL container are marked noexcept.
`valarray`'s `.size()` and `std::begin` are non-noexcept. We propose `valarray`'s `.begin()`
should also be non-noexcept, for consistency. If we add any `noexcept` markings to `valarray`,
we should add them consistently throughout the class — not *only* on its `begin` and `end`.

Modify <a href="https://eel.is/c++draft/template.valarray.overview">[template.valarray.overview]</a> as follows:

<small><blockquote>
<pre>
namespace std {
  template&lt;class T> class valarray {
  public:
    using value_type = T;
    <ins>using <i>iterator</i> = <i>unspecified</i>; // exposition only</ins>
    <ins>using <i>const_iterator</i> = <i>unspecified</i>; // exposition only</ins>

    <i>// [valarray.cons], construct/destroy</i>
    valarray();
    explicit valarray(size_t);
</pre>
[...]
<pre>
    <ins><i>// [valarray.range], range access</i></ins>

    <ins><i>iterator</i> begin();</ins>
    <ins><i>iterator</i> end();</ins>
    <ins><i>const_iterator</i> begin() const;</ins>
    <ins><i>const_iterator</i> end() const;</ins>

    <i>// [valarray.members], member functions</i>
    void swap(valarray&) noexcept;

    size_t size() const;

    T sum() const;
    T min() const;
    T max() const;

    valarray shift (int) const;
    valarray cshift(int) const;
    valarray apply(T func(T)) const;
    valarray apply(T func(const T&)) const;
    void resize(size_t sz, T c = T());
  };
</pre>
</blockquote></small>


## [valarray.members] ## {#wording-valarray.members}

Move the existing section <a href="https://eel.is/c++draft/valarray.range">[valarray.range]</a>
from its current location to make it a sibling of
<a href="https://eel.is/c++draft/valarray.members">[valarray.members]</a>; then
modify it as follows:

<small><blockquote>
<b><del>28.6.10</del> <ins>28.6.2.x</ins> <del>`valarray`</del> range access [valarray.range]</b>

1․ <del>In the `begin` and `end` function templates that
follow, <code><i>unspecified1</i></code> is a type that</del> <ins>The exposition-only <code><i>iterator</i></code></ins> type</ins> meets
the requirements of a mutable *Cpp17RandomAccessIterator* ([random.access.iterators])
and models `contiguous_iterator` ([iterator.concept.contiguous])<del>, whose</del> <ins>. Its</ins> `value_type` is the template parameter `T`
and <del>whose</del> <ins>its</ins> `reference` type is `T&`. <del><code><i>unspecified2</i></code> is
a type that</del> <ins>The exposition-only <code><i>const_iterator</i></code></ins> type</ins> meets
the requirements of a constant *Cpp17RandomAccessIterator*
and models `contiguous_iterator`<del>, whose</del> <ins>. Its</ins> `value_type` is the template parameter `T`
and <del>whose</del> <ins>its</ins> `reference` type is `const T&`.

2․ The iterators returned by `begin` and `end` for an array are guaranteed to be valid until the member function
`resize(size_t, T)` is called for that array or until the lifetime of that array ends, whichever happens first.

<pre>
<del>template&lt;class T> <i>unspecified1</i> begin(valarray&lt;T>& v);</del>
<del>template&lt;class T> <i>unspecified2</i> begin(const valarray&lt;T>& v);</del>
<ins><i>iterator</i> begin();</ins>
<ins><i>const_iterator</i> begin() const;</ins>
</pre>
3․ Returns: An iterator referencing the first value in the array.

<pre>
<del>template&lt;class T> <i>unspecified1</i> end(valarray&lt;T>& v);</del>
<del>template&lt;class T> <i>unspecified2</i> end(const valarray&lt;T>& v);</del>
<ins><i>iterator</i> end();</ins>
<ins><i>const_iterator</i> end() const;</ins>
</pre>
4․ Returns: An iterator referencing one past the last value in the array.

<b>28.6.2.8 Member functions [valarray.members]</b>
<pre>
void swap(valarray& v) noexcept;
</pre>
<p>1․ Effects: `*this` obtains the value of `v`. `v` obtains the value of `*this`.
<p>2․ Complexity: Constant.
</blockquote></small>

## [support.initlist] ## {#wording-support.initlist}

Modify <a href="https://eel.is/c++draft/support.initlist">[support.initlist]</a> as follows:

<small><blockquote>
[...]

<b>17.10.2 Header `<initializer_list>` synopsis [initializer.list.syn]</b>

<pre>
namespace std {
  template&lt;class E> class initializer_list {
  public:
    using value_type      = E;
    using reference       = const E&;
    using const_reference = const E&;
    using size_type       = size_t;

    using iterator        = const E*;
    using const_iterator  = const E*;

    constexpr initializer_list() noexcept;

    <ins>constexpr const E* data() const noexcept;</ins>
    constexpr size_t size() const noexcept;     // number of elements
    <ins>[[nodiscard]] constexpr bool empty() const noexcept;</ins>
    constexpr const E* begin() const noexcept;  // first element
    constexpr const E* end() const noexcept;    // one past the last element
  };

  <del>// [support.initlist.range], initializer list range access</del>
  <del>template&lt;class E> constexpr const E* begin(initializer_list&lt;E> il) noexcept;</del>
  <del>template&lt;class E> constexpr const E* end(initializer_list&lt;E> il) noexcept;</del>
}
</pre>
<p>1․ An object of type `initializer_list<E>` provides access to an array of objects of type `const E`.
<p><i>[Note: A pair of pointers or a pointer plus a length would be obvious representations for `initializer_list`.
`initializer_list` is used to implement initializer lists as specified in [dcl.init.list].
Copying an `initializer_list` does not copy the underlying elements. — end note]</i>
<p>2․ If an explicit specialization or partial specialization of `initializer_list` is declared, the program is ill-formed.

<b>17.10.3 Initializer list constructors [support.initlist.cons]</b>
<pre>
constexpr initializer_list() noexcept;
</pre>
<p>1․ Postconditions: `size() == 0`.

<b>17.10.4 Initializer list access [support.initlist.access]</b>
<pre>
constexpr const E* begin() const noexcept;
</pre>
<p>1․ Returns: A pointer to the beginning of the array. If `size() == 0` the values of `begin()` and `end()` are unspecified but they shall be identical.
<pre>
constexpr const E* end() const noexcept;
</pre>
<p>2․ Returns: `begin() + size()`.
<pre>
<ins>constexpr const E* data() const noexcept;</ins>
</pre>
<p><ins>x․ Returns: `begin()`.</ins>
<pre>
constexpr size_t size() const noexcept;
</pre>
<p>3․ Returns: The number of elements in the array.
<p>4․ Complexity: Constant <del>time</del>.
<pre>
<ins>[[nodiscard]] constexpr bool empty() const noexcept;</ins>
</pre>
<p><ins>x․ Returns: `size() == 0`.</ins>
<p><del><b>17.10.5 Initializer list range access [support.initlist.range]</b></del>
<pre>
<del>template&lt;class E> constexpr const E* begin(initializer_list&lt;E> il) noexcept;</del>
</pre>
<del>1․ Returns: `il.begin()`.</del>
<pre>
<del>template&lt;class E> constexpr const E* end(initializer_list&lt;E> il) noexcept;</del>
</pre>
<del>2․ Returns: `il.end()`.</del>

</blockquote></small>

## [iterator.synopsis] ## {#wording-iterator.synopsis}

Modify <a href="https://eel.is/c++draft/iterator.synopsis">[iterator.synopsis]</a> as follows:

<small><blockquote>
<b>25.2 Header <iterator> synopsis [iterator.synopsis]</b>

<pre>
#include &lt;compare>              // see [compare.syn]
#include &lt;concepts>             // see [concepts.syn]
<ins>#include &lt;initializer_list>     // see [initializer.list.syn]</ins>

namespace std {
</pre>
[...]
<pre>
  <i>// [iterator.range], range access</i>
  template&lt;class C> constexpr auto begin(C& c) -> decltype(c.begin());
  template&lt;class C> constexpr auto begin(const C& c) -> decltype(c.begin());
  template&lt;class C> constexpr auto end(C& c) -> decltype(c.end());
  template&lt;class C> constexpr auto end(const C& c) -> decltype(c.end());
  template&lt;class T, size_t N> constexpr T* begin(T (&array)\[N]) noexcept;
  template&lt;class T, size_t N> constexpr T* end(T (&array)\[N]) noexcept;
  template&lt;class C> constexpr auto cbegin(const C& c)
    noexcept(noexcept(std::begin(c))) -> decltype(std::begin(c));
  template&lt;class C> constexpr auto cend(const C& c)
    noexcept(noexcept(std::end(c))) -> decltype(std::end(c));
  template&lt;class C> constexpr auto rbegin(C& c) -> decltype(c.rbegin());
  template&lt;class C> constexpr auto rbegin(const C& c) -> decltype(c.rbegin());
  template&lt;class C> constexpr auto rend(C& c) -> decltype(c.rend());
  template&lt;class C> constexpr auto rend(const C& c) -> decltype(c.rend());
  template&lt;class T, size_t N> constexpr reverse_iterator&lt;T*> rbegin(T (&array)\[N])
  template&lt;class T, size_t N> constexpr reverse_iterator&lt;T*> rend(T (&array)\[N]);
  template&lt;class E> constexpr reverse_iterator&lt;const E*>
    rbegin(initializer_list&lt;E> il);
  template&lt;class E> constexpr reverse_iterator&lt;const E*>
    rend(initializer_list&lt;E> il);
  template&lt;class C> constexpr auto
    crbegin(const C& c) -> decltype(std::rbegin(c));
  template&lt;class C> constexpr auto
    crend(const C& c) -> decltype(std::rend(c));

  template&lt;class C> constexpr auto
    size(const C& c) -> decltype(c.size());
  template&lt;class T, size_t N> constexpr size_t
    size(const T (&array)\[N]) noexcept;

  template&lt;class C> constexpr auto
    ssize(const C& c)
      -> common_type_t&lt;ptrdiff_t, make_signed_t&lt;decltype(c.size())>>;
  template&lt;class T, ptrdiff_t N> constexpr ptrdiff_t
    ssize(const T (&array)\[N]) noexcept;

  template&lt;class C> [[nodiscard]] constexpr auto
    empty(const C& c) -> decltype(c.empty());
  template&lt;class T, size_t N> [[nodiscard]] constexpr bool
    empty(const T (&array)\[N]) noexcept;
  <del>template&lt;class E> [[nodiscard]] constexpr bool</del>
    <del>empty(initializer_list&lt;E> il) noexcept;</del>

  template&lt;class C> constexpr auto data(C& c) -> decltype(c.data());
  template&lt;class C> constexpr auto data(const C& c) -> decltype(c.data());
  template&lt;class T, size_t N> constexpr T* data(T (&array)\[N]) noexcept;
  <del>template&lt;class E> constexpr const E* data(initializer_list&lt;E> il) noexcept;</del>
}
</pre>
</blockquote></small>

## [iterator.range] ## {#wording-iterator.range}

Modify <a href="https://eel.is/c++draft/iterator.range">[iterator.range]</a> as follows:

<small><blockquote>
[...]
<pre>
<del>template&lt;class E> [[nodiscard]] constexpr bool empty(initializer_list&lt;E> il) noexcept;</del>
</pre>
<p><del>22․ Returns: `il.size() == 0`.</del>
<p>[...]
<pre>
<del>template&lt;class E> constexpr const E* data(initializer_list&lt;E> il) noexcept;</del>
</pre>
<p><del>25․ Returns: `il.begin()`.</del>
</blockquote></small>

## .data+.size cleanup ## {#wording-cleanup}
### [string.cons] ### {#wording-string.cons}

Modify <a href="https://eel.is/c++draft/string.cons">[string.cons]</a> as follows:

<small><blockquote>
<pre>
constexpr basic_string& operator=(initializer_list&lt;charT> il);
</pre>
36․ *Effects:* Equivalent to:<br>
<pre> return *this = basic_string_view&lt;charT, traits>(<del>il.begin()</del> <ins>il.data()</ins>, il.size());</pre>
</blockquote></small>

### [string.append] ### {#wording-string.append}

Modify <a href="https://eel.is/c++draft/string.append">[string.append]</a> as follows:

<small><blockquote>
<pre>
constexpr basic_string& append(initializer_list&lt;charT> il);
</pre>
16․ *Effects:* Equivalent to: <code>return append(<del>il.begin()</del> <ins>il.data()</ins>, il.size());</code>
</blockquote></small>

### [string.assign] ### {#wording-string.assign}

Modify <a href="https://eel.is/c++draft/string.assign">[string.assign]</a> as follows:

<small><blockquote>
<pre>
constexpr basic_string& assign(initializer_list&lt;charT> il);
</pre>
12․ *Effects:* Equivalent to: <code>return assign(<del>il.begin()</del> <ins>il.data()</ins>, il.size());</code>
</blockquote></small>

### [string.replace] ### {#wording-string.replace}

Modify <a href="https://eel.is/c++draft/string.replace">[string.replace]</a> as follows:

<small><blockquote>
<pre>
constexpr basic_string& replace(const_iterator i1, const_iterator i2, initializer_list&lt;charT> il);
</pre>
12․ *Effects:* Equivalent to: <code>return replace(i1, i2, <del>il.begin()</del> <ins>il.data()</ins>, il.size());</code>
</blockquote></small>

### [span.cons] ### {#wording-span.cons}

Modify <a href="https://eel.is/c++draft/span.cons">[span.cons]</a> as follows:

<small><blockquote>
<pre>
constexpr explicit(extent != dynamic_extent) span(std::initializer_list<value_type> il);
</pre>
<p>18․ *Constraints:* `is_const_v<element_type>` is `true`.
<p>19․ *Preconditions:* If `extent` is not equal to `dynamic_extent`, then `il.size()` is equal to `extent`.
<p>20․ *Effects:* Initializes <i>`data_`</i> with <del>`il.begin()`</del> <ins>`il.data()`</ins> and <i>`size_`</i> with `il.size()`.
</blockquote></small>

### [valarray.cons] ### {#wording-valarray.cons}

Modify <a href="https://eel.is/c++draft/valarray.cons">[valarray.cons]</a> as follows:

<small><blockquote>
<pre>
valarray(initializer_list&lt;T> il);
</pre>
9․ *Effects:* Equivalent to <code>valarray(<del>il.begin()</del> <ins>il.data()</ins>, il.size())</code>.
</blockquote></small>

# Proposed straw polls # {#straw-polls}

The next revision of this paper (if any) will be guided by the outcomes of these two straw polls.

<table class="def">
<tr><th style="width: 70%;"></th><th>**SF**</th><th>**F**</th><th>**N**</th><th>**A**</th><th>**SA**</th></tr>

<tr><th><small>Pursue the `initializer_list` changes and associated library-clause cleanup.</th>
<th> – </th><th> — </th><th> — </th><th> — </th><th> — </th></tr>

<tr><th><small>Pursue the `valarray` changes.</th>
<th> – </th><th> — </th><th> — </th><th> — </th><th> — </th></tr>
</table>

<pre class=biblio>
{
  "CWG1274": {
    "title": "Common nonterminal for expression and braced-init-list",
    "authors": [
      "Daniel Krügler"
    ],
    "href": "https://cplusplus.github.io/CWG/issues/1274.html",
    "date": "March 2011–October 2015"
  },
  "CWG2825": {
    "title": "Range-based for statement using a braced-init-list",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/CWG/issues/2825.html",
    "date": "November 2023"
  },
  "LWG2058": {
    "title": "valarray and begin/end",
    "authors": [
      "Gabriel Dos Reis"
    ],
    "href": "https://cplusplus.github.io/LWG/issue2058",
    "date": "May 2011–October 2012"
  },
  "LWG2128": {
    "title": "Absence of global functions cbegin/cend",
    "authors": [
      "Dmitry Polukhin"
    ],
    "href": "https://cplusplus.github.io/LWG/issue2128",
    "date": "January 2012–January 2016"
  },
  "LWG4001": {
    "title": "iota_view should provide empty",
    "authors": [
      "Hewill Kang"
    ],
    "href": "https://cplusplus.github.io/LWG/issue4001",
    "date": "October 2023"
  },
  "LWG4035": {
    "title": "single_view should provide empty",
    "authors": [
      "Hewill Kang"
    ],
    "href": "https://cplusplus.github.io/LWG/issue4035",
    "date": "December 2023"
  },
  "N2930": {
    "title": "Range-Based For Loop Wording (Without Concepts)",
    "authors": [
      "Doug Gregor",
      "Beman Dawes" 
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html",
    "date": "July 2009"
  },
  "N3271": {
    "title": "Wording for Range-Based For Loop (Option #5)",
    "authors": [
      "Doug Gregor" 
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3271.htm",
    "date": "March 2011"
  },
  "P2613": {
    "title": "Add the missing empty to mdspan",
    "authors": [
      "Yihe Li"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2613r1.html",
    "date": "June 2022"
  }
}
</pre>
