<pre class='metadata'>
Title: Variadic friends
Shortname: D2893
Revision: 1
!Draft Revision: 3
Audience: CWG
Status: D
Group: WG21
URL:
Editor: Jody Hagins, coachhagins@gmail.com
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  Support `friend Ts...` in C++26.
Date: 2024-01-20
</pre>

<style>
hilite  {background-color: #FFFF00; font-weight: bold;}
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>

# Changelog # {#changelog}

- R1 (post-Kona 2023):

    - New and improved wording after CWG feedback ([minutes](https://wiki.edg.com/bin/view/Wg21kona2023/CoreWorkingGroup#P2893R1)).



# Introduction # {#introduction}

This paper proposes support for granting friendship to all classes in a parameter pack. Several existing idioms
are implemented by providing friendship to a class via template parameter. However, these patterns can only
be used with a single template parameter, because friendship cannot be currently granted to a pack of types.

<table>
<tr><th>Before</th><th>After</th></tr>
<tr><td><pre>template&lt;class T=void,
         class U=void>
class Foo {
  friend T;
  friend U;
};
</pre></td><td><pre>
template&lt;class... Ts>
class Foo {
  friend Ts...;
};
</pre></td></tr>
</table>

## Passkey idiom ## {#passkey-idiom}

The Passkey idiom allows granting access to individual member functions
on a per-function basis. In the example below, `C` grants friendship to `A`,
meaning that `A::m` can access all of `C`'s internals. But `C` also grants
access to `intentionalA` and `intentionalB` using the Passkey idiom.
Class `Passkey<B>` has a private constructor accessible only to its friend `B`,
so nobody but `B` can construct instances of `Passkey<B>`. You can't call
`intentionalB` without an instance of `Passkey<B>` as the first argument.
So, even though `intentionalB` is public, it is callable only from `B`.

```cpp
template<class T>
class Passkey {
  friend T;
  Passkey() {}
};

class A;
class B;

class C {
  friend A;
private:
  void internal();
public:
  void intentionalA(Passkey<A>);
  void intentionalB(Passkey<B>);
};

class A {
  void m(C& c) {
    c.internal(); // OK
    c.intentionalA({}); // OK
    c.intentionalB({}); // Error, Passkey<B>'s ctor is inaccessible
  }
};

class B {
  void m(C& c) {
    c.intentionalB({}); // OK
  }
};
```

We would like to expand this idiom, and grant access to `Foo::intentional`
from multiple classes.

```cpp
template<class... Ts>
class Passkey {
  friend Ts...; // Today: Error. Proposed: OK
  Passkey() {}
};

class C {
public:
  // Only callable from Blarg, Blip, and Baz
  void intentional(Passkey<Blarg, Blip, Baz>);
};
```

## CRTP access to derived ## {#crtp-access}

Another common pattern is to inherit from some class template, passing the
type of the derived class as a template parameter to the base class.

There may be parts of the derived class API which are needed in the base class,
but only the base class, so they are private, and friendship is granted to
the base class.

```cpp
template<class Crtp, class MsgT>
class Receiver {
  void receive(MsgT) {
    static_cast<Crtp*>(this)->private_ += 1;
  }
};

template<class MsgT>
struct Dispatcher :
  public Receiver<Dispatcher<MsgT>, MsgT>
{
  using Receiver<Dispatcher, MsgT>::Receiver;
  friend Receiver<Dispatcher, MsgT>;

private:
  int private_;
};
```

To support multiple base classes, we would like to make `Dispatcher` variadic:

```cpp
template<class Crtp, class MsgT>
class Receiver {
  void receive(MsgT) {
    static_cast<Crtp*>(this)->private_ += 1;
  }
};

template<class... MsgTs>
struct Dispatcher :
  public Receiver<Dispatcher<MsgTs...>, MsgTs>... // OK
{
  using Receiver<Dispatcher, MsgTs>::Receiver...;  // OK
  friend Receiver<Dispatcher, MsgTs>...; // Today: Error. Proposed: OK

private:
  int private_;
};
```

Note that both inheritance and `using` support pack-expansion. Only `friend` does not.

# Confusing grammatical examples # {#confusing}

A declaration `template<class T> friend ~~~` is not a template for stamping out friends;
it is a request to befriend a specific template.

```cpp
template<class T>
friend class C::Nested;
```

declares that `C` has a member named `Nested` which itself is a class template, and we're
befriending that template. That is:

```cpp
struct C { template<class T> class Nested; };
struct S {
  template<class T>
  friend class C::Nested;
};
```

Therefore it is never well-formed to use the parameters of the friend declaration's own *template-head*
within the declarator itself. That is, these are all ill-formed, and replacing `U` with `Us...` doesn't
change anything:

<table>
<tr><th>Before</th><th>After</th></tr>
<tr><td><pre>
template&lt;class T>
struct S {
  template&lt;class U>
  friend U; // ill-formed

  template&lt;class U>
  friend class U; // ill-formed

  template&lt;class U>
  friend class C&lt;T>::Nested&lt;U>; // ill-formed




  template&lt;class U>
  friend class C&lt;U>::Nested; // ill-formed
};
</pre></td><td><pre>
template&lt;class... Ts>
struct VS {
  template&lt;class... Us>
  friend Us...; // ill-formed

  template&lt;class... Us>
  friend class Us...; // ill-formed

  template&lt;class U>
  friend class C&lt;Ts>::Nested&lt;U>...; // ill-formed

  template&lt;class... Us>
  friend class C&lt;Ts...>::Nested&lt;Us>...; // ill-formed

  template&lt;class... Us>
  friend class C&lt;Us>::Nested...; // ill-formed
};
</pre></td></tr>
</table>

But these are well-formed:

<table>
<tr><th>Before</th><th>After</th></tr>
<tr><td><pre>
template&lt;class T>
struct C {
  template&lt;class U> struct Nested;
};

template&lt;class T>
struct S {
  template&lt;class U>
  friend class C&lt;T>::Nested; // OK
};

template&lt;class T>
template&lt;class U>
struct C&lt;T>::Nested {
  int m(S&lt;int>& s) { return s.private_; }
};

int main() {
  S&lt;int> s;
  C&lt;int>::Nested&lt;float>().m(s); // OK
  C&lt;char>::Nested&lt;float>().m(s); // error, inaccessible
}
</pre></td><td><pre>
template&lt;class T>
struct C {
  template&lt;class U> struct Nested;
};

template&lt;class... Ts>
struct VS {
  template&lt;class U>
  friend class C&lt;Ts>::Nested...; // OK
};

template&lt;class T>
template&lt;class U>
struct C&lt;T>::Nested {
  int m(VS&lt;int, char>& vs) { return vs.private_; }
};

int main() {
  VS&lt;int, char> vs;
  C&lt;int>::Nested&lt;float>().m(vs); // OK
  C&lt;char>::Nested&lt;float>().m(vs); // OK
  C&lt;float>::Nested&lt;float>().m(vs); // error, inaccessible
}
</pre></td></tr>
</table>


## `friend class Ts...` ## {#confusing-elab}

C++ already disallows `friend class T` ([Godbolt](https://godbolt.org/z/zMefooj6h))
in <a href="https://eel.is/c++draft/dcl.spec#dcl.type.elab-4">[dcl.type.elab]</a>:
```cpp
template<class T>
struct S {
  friend class T;
};
```
but permits these ways to befriend a specific class instantiated from a class template `C`:
```
template<class T>
struct S {
  friend class C<T>;
  friend class N::C<T>;
};
```

The existing wording for this is:
<small><blockquote>
If an *elaborated-type-specifier* appears with the `friend` specifier as an entire *member-declaration*, the *member-declaration* shall have one of the following forms:

- `friend` *class-key nested-name-specifier*<sub>opt</sub> *identifier* `;`
- `friend` *class-key simple-template-id* `;`
- `friend` *class-key nested-name-specifier* `template`<sub>opt</sub> *simple-template-id* `;`

Any unqualified lookup for the *identifier* (in the first case) does not consider scopes that contain the target scope; no name is bound.
[*Note:* A using-directive in the target scope is ignored if it refers to a namespace not contained by that scope.
[basic.lookup.elab] describes how name lookup proceeds in an elaborated-type-specifier. — *end note*]
<p>5. [*Note:* An *elaborated-type-specifier* can be used to refer to a previously declared *class-name* or *enum-name*
even if the name has been hidden by a non-type declaration. — *end note*]
If the *identifier* or *simple-template-id* resolves to a *class-name* or *enum-name*, the *elaborated-type-specifier* introduces it
into the declaration the same way a *simple-type-specifier* introduces its *type-name* ([dcl.type.simple]).
If the *identifier* or *simple-template-id* resolves to a *typedef-name* ([dcl.typedef], [temp.names]), the *elaborated-type-specifier* is ill-formed.
[*Note:* This implies that, within a class template with a template type-parameter T, the declaration
`friend class T;` is ill-formed. However, the similar declaration `friend T;` is allowed ([class.friend]). — *end note*]
</blockquote></small>



The following `task1` and `task2` are grammatical according to our grammar, but it's not clear what
they mean (or if they're ill-formed for other reasons). Is this a problem?

```cpp
template<class... Ts>
class Task1 {
  friend class Newname<Ts>...;
};

template<class...> class Stranger;

class Task2 {
  template<class... Us>
  friend Stranger<Us>...;
};
```

<table>
<tr><td><pre>friend int f(Ts)...;</pre></td><td>Ill-formed by the grammar (`...` not allowed here)</td></tr>
<tr><td><pre>friend Ts...;</pre></td><td>OK</td></tr>
<tr><td><pre>friend class Ts...;</pre></td><td>Ill-formed; `class Ts`, being an *elaborated-type-specifier*, is not a *simple-friend-declarator*</td></tr>
<tr><td><pre>friend C&lt;Ts>...;</pre></td><td>OK; `C<Ts>`, being a *simple-type-specifier*, is a *simple-friend-declarator*</td></tr>
<tr><td><pre>friend typename C&lt;Ts>::type...;</pre></td><td>OK; `typename C<Ts>::type`, being a *typename-specifier*, is a *simple-friend-declarator*</td></tr>
<tr><td><pre>template&lt;class U> friend C&lt;Ts, U>...;</pre></td><td>OK</td></tr>
<tr><td><pre>template&lt;class... Us> friend C&lt;Ts, Us...>...;</pre></td><td>OK</td></tr>
<tr><td><pre>template&lt;class U> friend U;</pre></td><td>Vendors agree this is ill-formed; but how?</td></tr>
<tr><td><pre>template&lt;class U> friend typename U;</pre></td><td>Vendors agree this is ill-formed; but how?</td></tr>
<tr><td><pre>template&lt;class... Us> friend Us...;</pre></td><td>Should be ill-formed; but how?</td></tr>
<tr><td><pre>template&lt;class... Us> friend C&lt;Ts, Us>...;</pre></td><td>Should be ill-formed; but how?</td></tr>
<tr><td><pre></pre></td><td>Ill-formed by <a href=""></a></td></tr>
</table>



# Proposed wording # {#wording}

We present two possible wording options. Option 1 proposes to make `friend Ts...` expand to
`friend T1, T2`, which means we also need to define what *that* means. This is our
preferred direction, for consistency with `using T1::T1, T2::T2`.

Option 2 proposes to make `friend Ts...` expand to `friend T1; friend T2`, which means
that `friend T1, T2` will remain ill-formed — and if someone wants C++ to support that
syntax, they'll have to bring a new proposal and effectively reinvent Option 1 by unwinding
the effects of our paper. We think this is likely to happen, so Option 2 is *not* our
preferred direction.

P2893R0 presented Option 1, but with incomplete wording. EWG at Kona was concerned
that the wording to support `friend T1, T2` might be difficult, and so the presentation
drifted toward Option 2. By presenting both possible wordings in P2893R1, we allow
readers to decide for themselves whether Option 1's wording "pays for itself."

We make *simple-friend-declaration* a
<a href="https://eel.is/c++draft/temp.res.general#def:context,type-only">type-only context</a>, as already
implemented by GCC/Clang/EDG/MSVC ([Godbolt](https://godbolt.org/z/fbddeoMbW)).
That means we could eliminate the production for `friend typename X<Ts>::Y...` if we wanted,
but it seems more consistent to keep it. (That is, the production of *simple-friend-declarator*
from *typename-specifier* as well as from *simple-type-specifier*.)

## Option 1 (preferred) ## {#wording1}

Note: Precedent for "If a *member-declaration* matches..." is found in
<a href="https://eel.is/c++draft/dcl.pre#10">[dcl.pre]/10</a> "If a *static-assert-message* matches..."

Note: We want to support `friend Ts...` and `friend X<Ts>::Y<Us>...` but not `friend class A, class B`
and therefore not `friend class Ts...`. Therefore *simple-friend-declarator* is not producible from
*elaborated-type-specifier*.

### [class.mem.general] ### {#wording1-class.mem.general}

Modify <a href="https://eel.is/c++draft/class.mem.general#nt:member-declaration">[class.mem.general]</a> as follows:

<small><blockquote>
<i>member-declaration</i>:<br>
&emsp; <i>attribute-specifier-seq</i><sub>opt</sub> <i>decl-specifier-seq</i><sub>opt</sub> <i>member-declarator-list</i><sub>opt</sub> `;`<br>
&emsp; <i>function-definition</i><br>
&emsp; <ins><i>simple-friend-declaration</i></ins><br>
&emsp; <i>using-declaration</i><br>
&emsp; <i>using-enum-declaration</i><br>
&emsp; <i>static_assert-declaration</i><br>
&emsp; <i>template-declaration</i><br>
&emsp; <i>explicit-specialization</i><br>
&emsp; <i>deduction-guide</i><br>
&emsp; <i>alias-declaration</i><br>
&emsp; <i>opaque-enum-declaration</i><br>
&emsp; <i>empty-declaration</i><br>

<ins><i>simple-friend-declaration</i>:</ins><br>
&emsp; <ins>`friend` <i>simple-friend-declarator-list</i> `;`</ins><br>
<ins><i>simple-friend-declarator-list</i>:</ins><br>
&emsp; <ins><i>simple-friend-declarator</i> `...`<sub>opt</sub></ins><br>
&emsp; <ins><i>simple-friend-declarator-list</i> `,` <i>simple-friend-declarator</i> `...`<sub>opt</sub></ins><br>
<ins><i>simple-friend-declarator</i>:</ins><br>
&emsp; <ins><i>simple-type-specifier</i></ins><br>
&emsp; <ins><i>typename-specifier</i></ins><br>

<i>member-declarator-list</i>:<br>
&emsp; <i>member-declarator</i><br>
&emsp; <i>member-declarator-list</i> `,` <i>member-declarator</i><br>

[...]

<p>2. A *member-declaration* does not declare new members of the class if it is
- a friend declaration ([class.friend]),
- a *deduction-guide* ([temp.deduct.guide]),
- a *template-declaration* whose declaration is one of the above,
- a *static_assert-declaration*,
- a *using-declaration* ([namespace.udecl]), or
- an *empty-declaration*.

<p>For any other *member-declaration*, each declared entity that is not an unnamed bit-field
is a member of the class, and each such *member-declaration* shall either
declare at least one member name of the class or declare at least one unnamed bit-field.
<p>[...]
<p>8. A class `C` is complete at a program point *P* if the definition of `C` is reachable from *P* ([module.reach])
or if *P* is in a complete-class context of `C`. Otherwise, `C` is incomplete at *P*.

<p><ins>x. If a *member-declaration* matches the syntactic requirements of *simple-friend-declaration*, it is a *simple-friend-declaration*.</ins>

<p>9. In a *member-declarator*, an `=` immediately following the *declarator* is interpreted as
introducing a *pure-specifier* if the *declarator-id* has function type;
otherwise it is interpreted as introducing a *brace-or-equal-initializer*. [...]

<p>10. In a *member-declarator* for a bit-field, the *constant-expression* is parsed as
the longest sequence of tokens that could syntactically form a *constant-expression*. [...]
</blockquote></small>

### [class.friend] ### {#wording1-class.friend}

Modify <a href="https://eel.is/c++draft/class.friend">[class.friend]</a> as follows:

<small><blockquote>
<p>3. A friend declaration that does not declare a function shall have
one of the following forms:

&emsp; <ins><i><a href="#wording1-class.mem.general">simple-friend-declaration</a></i></ins><br>
&emsp; `friend` *elaborated-type-specifier* `;`<br>
&emsp; <del>`friend` *simple-type-specifier* `;`</del><br>
&emsp; <del>`friend` *typename-specifier* `;`</del><br>

[*Note:* A friend declaration can be the declaration in a *template-declaration* ([temp.pre], [temp.friend]). — *end note*]

<del>If the type specifier in a friend declaration designates a (possibly cv-qualified) class type,
that class is declared as a friend; otherwise, the friend declaration is ignored.</del> <ins>Each
type specifier in a friend declaration that designates a (possibly cv-qualified) class type declares
that class as a friend. Each other type specifier is ignored.</ins>

[*Example 4:*
<pre>
class C;
typedef C Ct;
<ins>struct E;</ins>

class X1 {
  friend C;                     // OK, class C is a friend
};

class X2 {
  friend Ct;                    // OK, class C is a friend
  friend D;                     // error: D not found
  friend class D;               // OK, elaborated-type-specifier declares new class
};

template &lt;class<ins>...</ins> T<ins>s</ins>> class R {
  friend T<ins>s...</ins>;
};

R&lt;C> rc;                        // class C is a friend of R&lt;C>
<ins>R&lt;C, E> rcef;                   // classes C and E are friends of R&lt;C,E></ins>
R&lt;int> Ri;                      // OK, "friend int;" is ignored

<ins>struct E { struct Nested; };</ins>

<ins>template &lt;class... Ts> class S {</ins>
  <ins>friend Ts::Nested...;</ins>
  <ins>friend R&lt;Ts>...;</ins>
<ins>};</ins>

<ins>S&lt;E> sc;                   // E::Nested and R&lt;E> are friends of S&lt;E></ins>
<ins>S&lt;int> sc;                 // error: int::Nested does not exist</ins>
</pre>
— *end example*]
</blockquote></small>

### [temp.res.general] ### {#wording1-temp.res.general}

Modify <a href="https://eel.is/c++draft/temp.res.general">[temp.res.general]</a> as follows:

<small><blockquote>
<p>4. A qualified or unqualified name is said to be in a *type-only context* if it is the terminal name of

* a *typename-specifier*, *nested-name-specifier*, *elaborated-type-specifier*, *class-or-decltype*, or
* <ins>the *simple-type-specifier* of a *simple-friend-declarator*, or</ins>
* a *type-specifier* of a
  - *new-type-id*,
  - *defining-type-id*,
  - *conversion-type-id*,
  - *trailing-return-type*,
  - default argument of a *type-parameter*, or
  - *type-id* of a `static_cast`, `const_cast`, `reinterpret_cast`, or `dynamic_cast`, or
* a *decl-specifier* of the *decl-specifier-seq* of a
  - *simple-declaration* or a *function-definition* in namespace scope,
  - *member-declaration*,
  - *parameter-declaration* in a *member-declaration*, unless that *parameter-declaration* appears in a default argument,
  - *parameter-declaration* in a declarator of a function or function template declaration whose *declarator-id* is qualified, unless that *parameter-declaration* appears in a default argument,
  - *parameter-declaration* in a *lambda-declarator* or *requirement-parameter-list*, unless that *parameter-declaration* appears in a default argument, or
  - *parameter-declaration* of a (non-type) *template-parameter*.

</blockquote></small>

### [temp.variadic] ### {#wording1-temp.variadic}

Modify <a href="https://eel.is/c++draft/temp.variadic">[temp.variadic]</a> as follows:

<small><blockquote>
<p>5. A *pack expansion* consists of a *pattern* and an *ellipsis*, the instantiation of which produces
zero or more instantiations of the pattern in a list (described below). The form of the pattern depends
on the context in which the expansion occurs. Pack expansions can occur in the following contexts:

* In a function parameter pack ([dcl.fct]); the pattern is the *parameter-declaration* without the ellipsis.
* In a *using-declaration* ([namespace.udecl]); the pattern is a *using-declarator*.
* <ins>In a *simple-friend-declaration* (<a href="#wording1-class.mem.general">[class.mem.general]</a>); the pattern is a *simple-friend-declarator*.</ins>
* In a template parameter pack that is a pack expansion ([temp.param]):
  - if the template parameter pack is a *parameter-declaration*; the pattern is the *parameter-declaration* without the ellipsis;
  - if the template parameter pack is a *type-parameter*; the pattern is the corresponding *type-parameter* without the ellipsis.
* In an *initializer-list* ([dcl.init]); the pattern is an *initializer-clause*.
* In a *base-specifier-list* ([class.derived]); the pattern is a *base-specifier*.
* In a *mem-initializer-list* ([class.base.init]) for a *mem-initializer* whose *mem-initializer-id* denotes a base class; the pattern is the *mem-initializer*.
* In a *template-argument-list* ([temp.arg]); the pattern is a *template-argument*.
* In an *attribute-list* ([dcl.attr.grammar]); the pattern is an *attribute*.
* In an *alignment-specifier* ([dcl.align]); the pattern is the *alignment-specifier* without the ellipsis.
* In a *capture-list* ([expr.prim.lambda.capture]); the pattern is the *capture* without the ellipsis.
* In a `sizeof...` expression; the pattern is an *identifier*.
* In a *fold-expression* ([expr.prim.fold]); the pattern is the *cast-expression* that contains an unexpanded pack.

</blockquote></small>

## Option 2 ## {#wording2}

Note: The idea that a pack-expansion can produce a semicolon-separated "sequence of declarations"
is not a problem, but it is novel.

Note: We need to permit `friend Ts...;` and `friend typename Ts::Nested...;`, but while keeping `friend int fs()...;`
and `inline int xs...;` clearly ill-formed. This wording probably achieves the former, but
without much regard for the latter.
Today, `friend T;` is a <a href="https://eel.is/c++draft/dcl.pre#nt:simple-declaration"><i>simple-declaration</i></a>,
consisting of two *decl-specifiers* and no *init-declarator-list*. The second *decl-specifier*
is a *defining-type-specifier* which is a *simple-type-specifier*.

### [dcl.type.general] ### {#wording2-dcl.type.general}

Modify <a href="https://eel.is/c++draft/dcl.type.general">[dcl.type.general]</a> as follows:

<small><blockquote>
<p>1. The type-specifiers are

<i>type-specifier</i>:<br>
&emsp; <i>simple-type-specifier</i> <ins>`...`<sub>opt</sub></ins><br>
&emsp; <i>elaborated-type-specifier</i> <ins>`...`<sub>opt</sub></ins><br>
&emsp; <i>typename-specifier</i> <ins>`...`<sub>opt</sub></ins><br>
&emsp; <i>cv-qualifier</i><br>

<i>type-specifier-seq</i>:<br>
&emsp; <i>type-specifier attribute-specifier-seq</i><sub>opt</sub><br>
&emsp; <i>type-specifier type-specifier-seq</i><br>

<i>defining-type-specifier</i>:<br>
&emsp; <i>type-specifier</i><br>
&emsp; <i>class-specifier</i><br>
&emsp; <i>enum-specifier</i><br>

[...]
</blockquote></small>

### [temp.variadic] ### {#wording2-temp.variadic}

Modify <a href="https://eel.is/c++draft/temp.variadic">[temp.variadic]</a> as follows:

<small><blockquote>
<p>9. The instantiation of a `sizeof...` expression ([expr.sizeof]) produces an integral constant with value *N*.
<p>10. The instantiation of an *alignment-specifier* with an ellipsis produces `E`<sub>1</sub>`E`<sub>2</sub>...`E`<sub>N</sub>.
<p>11. The instantiation of a *fold-expression* ([expr.prim.fold]) produces:

* `( (( E`<sub>1</sub> <i>op</i> `E`<sub>2</sub>`)` <i>op</i> ... `)` <i>op</i> `E`<sub>N</sub>`)` for a unary left fold,
* `(E`<sub>1</sub> <i>op</i> `(` ... <i>op</i> `(E`<sub>N-1</sub> <i>op</i> `E`<sub>N</sub>`)) )` for a unary right fold,
* `( (((E` <i>op</i> `E`<sub>1</sub>`)` <i>op</i> `E`<sub>2</sub> `)` <i>op</i> ... `)` <i>op</i> `E`<sub>N</sub> `)` for a binary left fold, and
* `(E`<sub>1</sub> <i>op</i> `(` ... <i>op</i> `(E`<sub>N-1</sub> <i>op</i> `(E`<sub>N</sub> <i>op</i> `E))) )` for a binary right fold. [...]

<p><ins>x. The instantiation of a friend declaration (<a href="#wording2-class.friend">[class.friend]</a>) produces a sequence of declarations
`friend E`<sub>1</sub>`;` `friend E`<sub>2</sub>`;`...`friend E`<sub>N</sub>`;`.</ins>
<p>12. The instantiation of any other pack expansion produces a list of elements `E`<sub>1</sub>`,E`<sub>2</sub>`,`...`,E`<sub>N</sub>.
[*Note:* The variety of list varies with the context: *expression-list*, *base-specifier-list*, *template-argument-list*, etc. — *end note*]
When *N* is zero, the instantiation of the expansion produces an empty list.
</blockquote></small>

### [class.friend] ### {#wording2-class.friend}

Modify <a href="https://eel.is/c++draft/class.friend">[class.friend]</a> as follows:

<small><blockquote>
<p>3. A friend declaration that does not declare a function shall have
one of the following forms:

&emsp; `friend` *elaborated-type-specifier* <ins>`...`<sub>opt</sub></ins> `;`<br>
&emsp; `friend` *simple-type-specifier* <ins>`...`<sub>opt</sub></ins> `;`<br>
&emsp; `friend` *typename-specifier* <ins>`...`<sub>opt</sub></ins> `;`<br>

[*Note:* A friend declaration can be the declaration in a *template-declaration* ([temp.pre], [temp.friend]). — *end note*]

<del>If the type specifier in a friend declaration designates a (possibly cv-qualified) class type,
that class is declared as a friend; otherwise, the friend declaration is ignored.</del> <ins>Each
type specifier in such a friend declaration that designates a (possibly cv-qualified) class type
declares that class as a friend;
each type specifier that does not designate a (possibly cv-qualified) class type is ignored.</ins>

[*Example 4:*
<pre>
class C;
typedef C Ct;
<ins>struct E;</ins>

class X1 {
  friend C;                     // OK, class C is a friend
};

class X2 {
  friend Ct;                    // OK, class C is a friend
  friend D;                     // error: D not found
  friend class D;               // OK, elaborated-type-specifier declares new class
};

template &lt;class<ins>...</ins> T<ins>s</ins>> class R {
  friend T<ins>s...</ins>;
};

R&lt;C> rc;                        // class C is a friend of R&lt;C>
<ins>R&lt;C, E> rcef;                   // classes C and E are friends of R&lt;C,E></ins>
R&lt;int> Ri;                      // OK, "friend int;" is ignored

<ins>struct E { struct Nested; };</ins>

<ins>template &lt;class... Ts> class S {</ins>
  <ins>friend Ts::Nested...;</ins>
  <ins>friend R&lt;Ts>...;</ins>
<ins>};</ins>

<ins>S&lt;E> sc;                   // E::Nested and R&lt;E> are friends of S&lt;E></ins>
</pre>
— *end example*]
</blockquote></small>


# Acknowledgments # {#acknowledgments}

I had been sitting on this since posting to the mailing list about it in January 2020. This paper was finally
written during C++Now 2023, Feature in a Week. Thus, it is very appropriate to say that it would not exist
without that program. Thanks to Jeff Garland, Marshall Clow, Barry Revzin, and JF Bastien for running that
program, and all the attendees who helped discuss and review the proposal. Special thanks to Barry Revzin for
lots of help with the document itself.
