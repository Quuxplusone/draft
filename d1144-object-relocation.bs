<pre class='metadata'>
Title: std::is_trivially_relocatable
Shortname: D1144
Revision: 7
!Draft Revision: 42
Audience: LEWG, EWG
Status: D
Group: WG21
URL:
!Current Source: <a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d1144-object-relocation.bs">github.com/Quuxplusone/draft/blob/gh-pages/d1144-object-relocation.bs</a>
!Current: <a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d1144-object-relocation.html">rawgit.com/Quuxplusone/draft/gh-pages/d1144-object-relocation.html</a>
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  We define a new verb, "relocate," equivalent to a move and a destroy.
  For many C++ types, the "relocate" operation is implementable as a single <code>memcpy</code>.
  We provide a standard trait to detect types which are trivially relocatable, for the benefit of library writers.
  We provide a rule that correctly propagates trivial relocatability among Rule-of-Zero types.
  Finally, we provide a portable way for a user-defined type (e.g. <code>boost::shared_ptr</code>) to warrant
  that it is trivially relocatable.
  P1144R3 was presented at C++Now 2019 as a 90-minute talk titled
  ["Trivially Relocatable."](https://www.youtube.com/watch?v=SGdfPextuAU)
Date: 2023-03-10
</pre>

<style>
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>


# Changelog # {#changelog}

- R7 (post-Issaquah 2023):

    - [[P2786R0]] debuted at Issaquah; it raised several
            open questions (see [[#open-questions]]). The authors of P1144 and P2786
            plan a joint paper to resolve some of these design issues.

    - Added `std::uninitialized_relocate_backward`, the building block of `vector::insert`.

    - Removed "move-constructible, destructible" from the requirements in [[#wording-basic.types.general|basic.types.general]].
            Now trivially relocatable types, like trivially copyable types, can be non-relocatable.

    - Added [[#applications|table §2.1]] directly comparing this proposal to Folly, BSL, and Qt.

    - Added straw poll results from Issaquah; removed much background and discussion
            (leaving only references for the interested reader to consult [[P1144R6]]).

    - Jonathan Hopkins points out that (contrary to the English description in [[N2271]])
            EASTL defines `has_trivial_relocate` as a synonym for
            `is_trivially_move_assignable`, thus it's not prior art for this notion.
            (In particular, EASTL considers `unique_ptr<int>` non-trivially relocatable.)
            Remove mentions of EASTL.

    - Added [[#open-questions|Appendix E]].

- R6:

    - Added `T std::relocate(T *source)`.

    - Changed the exception guarantee of `uninitialized_relocate` and `uninitialized_relocate_n`
            in accord with feedback from David Stone.

    - Removed `std::ranges::relocate_at` (but kept `std::relocate_at`).

- R5 (post-Prague 2020):

    - Polymorphic types (those with any vptr at all) inhibit "natural" trivial relocatability.
            David Stone gave the motivating example. See [[#non-trivial-sample-polymorphic]].

    - Updated `concept relocatable`. Added semantic requirements on assignment and some discussion
            of the issue with `vector::insert`.

- R3 (post-Kona 2019):

    - User-provided copy constructors and copy/move assignment operators inhibit "natural" trivial relocatability.
            This permits optimizing `vector::insert` and `vector::erase`.

    - Adopted `[[trivially_relocatable(bool)]]`.

    - Added `std::relocate_at(source, dest)`.

    - Removed the core-language blanket wording that permitted "the implementation" to eliminate
            moves and destroys of trivially relocatable types. Instead, the existence of
            `std::relocate_at` and handwaviness of e.g.
            [ [vector.capacity](http://eel.is/c++draft/vector#capacity-4)] combine to strongly imply
            (but still not to mandate) that library vendors will use `std::relocate_at` wherever
            it helps with performance. We no longer propose to permit eliminating
            moves and destroys in e.g. `return` statements, except as already permitted under the as-if rule.


# Introduction and motivation # {#intro}

Given an object type `T` and memory addresses `src` and `dst`,
the phrase "<b><i>relocate</i></b> a `T` from `src` to `dst`" means
"*move-construct* `dst` from `src`, and then immediately *destroy* the object at `src`."

Any type which is both move-constructible and destructible is <b><i>relocatable</i></b>.
A type is <b><i>nothrow relocatable</i></b> if its relocation operation is noexcept, and a type
is <b><i>[$trivially relocatable$]</i></b> if its relocation operation is trivial (which,
just like trivial move-construction and trivial copy-construction, means
"tantamount to `memcpy`").

In practice, almost all relocatable types are trivially relocatable: `std::unique_ptr<int>`,
`std::vector<int>`, `std::string` (on libc++), `std::list<int>` (on MSVC).
Examples of non-trivially relocatable types include `std::list<int>` (on libstdc++ and libc++),
`std::string` (on libstdc++ and MSVC), `std::set` (everywhere). See [[#non-trivial-samples]].

P1144 allows the library programmer
to <b><i>warrant</i></b> to the compiler that a resource-management type is trivially relocatable.
Explicit warrants are rarely needed because the compiler can infer trivial relocatability for
Rule-of-Zero types. See [[#wording-basic.types.general]].

The most important thing about P1144 relocation is that it is backward compatible and does not
break either API or ABI. My intention is simply to legalize the well-understood tricks
that many industry codebases ([[BSL]], [[Folly]], [[Deque]]) are already doing in practice.
P1144 is not intended to change the behavior of any existing source code (except to speed it up),
nor does it require major work from standard library vendors.


## Optimizations enabled by trivial relocatability ## {#applications}

The following optimizations are possible according to P1144R7's notion of
trivial relocatability. Here's who does these optimizations in practice:

<table>
<tr>
<td></td><td> vector realloc </td><td> type erasure </td><td> fixed-cap move </td><td> vector `erase` </td><td> vector `insert` </td><td> `rotate` </td><td> `swap` </td>
</tr><tr>
<td> Arthur's libc++ `std::is_trivially_relocatable_v<T>` </td><td>
     <a href="https://github.com/Quuxplusone/llvm-project/blob/d0c5d3639e/libcxx/include/vector#L936-L942">`std::vector`</a> </td><td>
     no </td><td>
     N/A </td><td>
     not yet </td><td>
     <a href="https://github.com/Quuxplusone/llvm-project/blob/d0c5d3639e/libcxx/include/vector#L1728-L1744">`std::vector`</a> </td><td>
     yes, uses `swap` </td><td>
     <a href="https://github.com/Quuxplusone/llvm-project/blob/d0c5d3639e/libcxx/include/__utility/swap.h#L45-L57">`std::swap`</a> </td>
</tr><tr>
<td> [[BSL]] `bslmf::IsBitwiseMoveable<T>` </td><td>
     <a href="https://github.com/bloomberg/bde/blob/e15f05be6/groups/bsl/bslstl/bslstl_vector.h#L3374-L3398">`bsl::vector`</a> </td><td>
     <a href="https://github.com/bloomberg/bde/blob/e15f05be6/groups/bsl/bslstl/bslstl_function.h#L116-L131">no</a> </td><td>
     ? </td><td>
     <a href="https://github.com/bloomberg/bde/blob/e15f05be6/groups/bsl/bslalg/bslalg_arrayprimitives.h#L3769-L3800">`bsl::vector`</a> </td><td>
     <a href="https://github.com/bloomberg/bde/blob/e15f05be6/groups/bsl/bslalg/bslalg_arrayprimitives.h#L3606-L3643">`bsl::vector`</a> </td><td>
     <a href="https://github.com/bloomberg/bde/blob/e15f05be6/groups/bsl/bslalg/bslalg_arrayprimitives.h#L1707-L1722">`ArrayPrimitives_Imp::rotate`</a>, unused by `bsl::rotate` </td><td>
     no </td>
</tr><tr>
<td> [[Folly]] `folly::IsRelocatable<T>` </td><td>
     <a href="https://github.com/facebook/folly/blob/1d4690d0a3/folly/FBVector.h#L945-L966">`fbvector`</a> </td><td>
     <a href="https://github.com/facebook/folly/blob/1d4690d0a3/folly/Function.h#L749-L755">no</a> </td><td>
     [proposed](https://github.com/facebook/folly/pull/1934) for `small_vector` </td><td>
     <a href="https://github.com/facebook/folly/blob/1d4690d0a3/folly/FBVector.h#L1232-L1259">`fbvector`</a> </td><td>
     <a href="https://github.com/facebook/folly/blob/1d4690d0a3/folly/FBVector.h#L1273-L1292">`fbvector`</a> </td><td>
     N/A </td><td>
     N/A </td>
</tr><tr>
<td> [[Qt]] `QTypeInfo<T>::isRelocatable` </td><td>
     <a href="https://github.com/qt/qtbase/blob/fbfee2d/src/corelib/tools/qarraydataops.h#L865-L872">`QList`</a> </td><td>
     <a href="https://github.com/qt/qtbase/blob/fbfee2d/src/corelib/kernel/qvariant.h#L73-L94">`QVariant`</a> </td><td>
     <a href="https://github.com/qt/qtbase/blob/fbfee2d/src/corelib/tools/qvarlengtharray.h#L312-L328">`QVarLengthArray`</a> </td><td>
     <a href="https://github.com/qt/qtbase/blob/fbfee2d/src/corelib/tools/qarraydataops.h#L842-L863">`QList`</a> </td><td>
     <a href="https://github.com/qt/qtbase/blob/fbfee2d/src/corelib/tools/qarraydataops.h#L679-L730">`QList`</a> </td><td>
     <a href="https://github.com/qt/qtbase/blob/7db28fb/src/corelib/tools/qcontainertools_impl.h#L89-L107">`q_rotate`</a> </td><td>
     N/A </td>
</tr>
</table>


### Contiguous reallocation ### {#benefit-resize}

Trivial relocation can be used anywhere we do the moral equivalent of `realloc`,
such as in `vector<R>::reserve`.

[[Bench]] (presented at C++Now 2018) shows a 3x speedup on `vector<unique_ptr<int>>::resize`.
[This Reddit thread](https://www.reddit.com/r/cpp/comments/9wj4vt/trivially_relocatable_in_san_diego_call_for/e9p76i4/)
demonstrates a similar 3x speedup using the online tool Quick-Bench.


### Moving in-place/SBO type-erased types like `any` and `function` ### {#benefit-type-erasure}

Trivial relocation can be used to de-duplicate the code generated by type-erasing wrappers
like `any`, `function`, and `move_only_function`.
For these types, a *move* of the wrapper object is implemented in terms of a
*relocation* of the contained object. (See for example
<a href="https://github.com/llvm-mirror/libcxx/blob/8fdc4918/include/any#L389-L394">libc++'s `std::any`</a>.)
In general, the *relocate* operation must be uniquely codegenned for each
different contained type `C`, leading to code bloat. But a single instantiation suffices to relocate every <em>trivially</em>
relocatable `C` in the program.


### Moving fixed-capacity containers like `static_vector` and `small_vector` ### {#benefit-fixed-capacity}

The move-constructor of `fixed_capacity_vector<R,N>`,
can be implemented naïvely as an element-by-element *move*
(leaving the source vector's elements in their moved-from state),
or efficiently as an element-by-element *relocate*
(leaving the source vector empty).

For a detailed analysis of this case, see [[FixedCapacityVector]].

`boost::container::static_vector<R,N>` currently implements the
naïve element-by-element-move strategy, but after LEWG feedback,
[[P0843R5]] `static_vector` does [permit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0843r5.html#Move-semantics)
the faster relocation strategy.


### Contiguous insert and erase ### {#benefit-insert-erase}

Trivial relocation can be used anywhere we shift a contiguous range left or right,
such as in `vector::erase` (i.e., destroy the erased elements and "close the window"
by memmoving left) and `vector::insert` (i.e., "make a window" by memmoving right and
then construct the new elements in place). [[Folly]]'s `fbvector` is prior art
for this optimization; see
<a href="https://github.com/facebook/folly/blob/1d4690d0a3/folly/FBVector.h#L1273-L1308">`fbvector::make_window`</a>.

[[#pmr-concerns]] determines whether this optimization will be possible in Standard C++.


### Swap ### {#benefit-swap}

Given a reliable way of detecting trivial relocatability,
we can optimize any routine that uses the moral equivalent of `std::swap`, such as
`std::rotate`, `std::partition`, or `std::sort`.

Optimizing `std::swap` produces massive code-size improvements for all swap-based
algorithms, including `std::sort` and `std::rotate`. 
See
[@19:56–21:22](https://www.youtube.com/watch?v=SGdfPextuAU&t=19m56s) in my C++Now 2019 talk,
and see [this Godbolt](https://p1144.godbolt.org/z/PPYhcYd8d).
[This Quick-Bench](https://quick-bench.com/q/suAss7ElmwgLDbOJQGnlEseheSQ) shows a 25% speedup
in `std::rotate` when it is allowed to use bitwise swap on a Rule-of-Zero type.

But [[#pmr-concerns]] determines whether this optimization will be possible in Standard C++.


## Assertions, not assumptions ## {#benefit-assertions}

Some data structures might reasonably assert the trivial relocatability of
their elements, just as they sometimes assert the stronger property of trivial *copyability* today.
This might help them guarantee reasonable performance, or guarantee exception-safety.


## Eliminate manual warrants, improve safety ## {#doing-it-wrong}

Many real-world codebases contain templates which require
trivial relocatability of their template parameters, but cannot today *verify*
trivial relocatability. For example, [[Folly]] requires the programmer to warrant the trivial
relocatability of any type stored in a `folly::fbvector`:

```c++
    class Widget {
        std::vector<int> lst_;
    };

    folly::fbvector<Widget> vec;  // FAILS AT COMPILE TIME for lack of warrant
```

This merely encourages the programmer to add the warrant and continue. An incorrect
warrant will be discovered only at runtime, via undefined behavior. See [[#non-trivial-sample-list]],
[[FollyIssue889]], and (most importantly) [@27:26–31:47](https://www.youtube.com/watch?v=SGdfPextuAU&t=27m26s)
in my C++Now 2019 talk.

```c++
    class Gadget {
        std::list<int> lst_;
    };
    // sigh, add the warrant on autopilot
    template<> struct folly::IsRelocatable<Gadget> : std::true_type {};

    folly::fbvector<Gadget> vec;  // CRASHES AT RUNTIME due to fraudulent warrant
```

If this proposal is adopted, then Folly can start using `static_assert(std::is_trivially_relocatable_v<T>)`
in the implementation of `fbvector`, and the programmer can stop writing explicit warrants.
Finally, the programmer can start writing assertions of correctness, which aids maintainability and
can even find real bugs. [Example:](https://p1144.godbolt.org/z/7b8893sjr)

```c++
    class Widget {
        std::vector<int> lst_;
    };
    static_assert(std::is_trivially_relocatable_v<Widget>);  // correctly SUCCEEDS

    class Gadget {
        std::list<int> lst_;
    };
    static_assert(std::is_trivially_relocatable_v<Gadget>);  // correctly ERRORS
```

The improvement in user experience and safety in real-world codebases ([[Folly]], [[BSL]], [[Qt]], etc.)
is the most important benefit to be gained by this proposal.


# Design goals # {#design-goals}

Every C++ type already *is* or *is not* trivially relocatable. This proposal does not require any
library vendor to make any library type trivially relocatable. (We assume that quality implementations
will do so on their own.)

The optimizations above are in the domain of library writers. If you're writing
a vector, and you detect that your element type `T` is trivially relocatable, then
whether you optimize in that case is up to you.
This proposal does not require any library vendor to guarantee that any particular optimization
happens. (We assume that quality implementations will do so on their own.)

What C++ lacks is a standard way for library writers to *detect* the (existing) trivial relocatability
of a type `T`, so that they can reliably apply their (existing) optimizations.
All we really need is to add *detection*, and then all the optimizations described above will naturally
emerge without any further special effort by WG21.

There are three kinds of object types that we want to make sure are correctly detected as
trivially relocatable. These three cases are important for improving the performance of
the standard library, and for improving the correctness of libraries such as
[[Folly]]'s `fbvector`.


## Standard library types such as `std::string` ## {#use1}

In order to optimize `std::vector<std::string>::resize`, we must come up with a way to achieve
```c++
    #include <string>
    static_assert(std::is_trivially_relocatable_v< std::string >);
```
This could be done unilaterally by the library vendor — via a non-standard attribute
(`[[clang::trivially_relocatable]]`), or a member typedef with a reserved name,
or simply a vendor-provided specialization of `std::is_trivially_relocatable<std::string>`.

That is, we can in principle solve §3.1 while confining our "magic" to the headers
of the implementation itself. The programmer doesn't have to learn anything new, so far.


## Program-defined types that follow the Rule of Zero ## {#use2}

In order to optimize the SBO `std::function` in any meaningful sense,
we must come up with a way to achieve
```c++
    #include <string>
    auto lam2 = [x=std::string("hello")]{};
    static_assert(std::is_trivially_relocatable_v< decltype(lam2) >);
```
Lambdas are not a special case in C++; they are simply class types with all their special members defaulted.
Therefore, lambdas can use the same solution as
```c++
    #include <string>
    struct A {
        std::string s;
    };
    static_assert(std::is_trivially_relocatable_v< A >);
```
Here `struct A` follows the Rule of Zero: its move-constructor and destructor are both defaulted.
If they were also *trivial*, then we'd be done. In fact they are non-trivial; and yet, because the type's
bases and members are all of trivially relocatable types, the type as a whole *is* trivially relocatable.

§3.2 asks that we make the `static_assert` succeed without breaking the "Rule of Zero."
We do not want to require the programmer to annotate `struct A` with a special attribute, or
a special member typedef, or anything like that. We want it to Just Work.
This is a harder problem than §3.1; it requires standard support in the core language.
But it still does not require any new *syntax*.


## Program-defined types with non-defaulted special members ## {#use3}

In order to optimize `std::vector<boost::shared_ptr<T>>::resize`,
we must come up with a way to achieve
```c++
    struct B {
        B(B&&);  // non-trivial
        ~B();  // non-trivial
    };
    static_assert(std::is_trivially_relocatable_v< B >);
```
via some standard annotation applied to class type `B` (which in this example is standing in for
`boost::shared_ptr`).
We cannot possibly do it without annotation, because there exist
examples of types that look just like `B` and *are* trivially relocatable
(e.g. <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/std_function.h">libstdc++'s `std::function`</a>)
and there exist types that look just like `B` and are *not* trivially relocatable
(e.g. <a href="https://github.com/llvm-mirror/libcxx/blob/4e7ffcaa/include/functional#L1719-L1734">libc++'s `std::function`</a>).
So, without some kind of opt-in annotation, we cannot achieve our goal.

This paper proposes a standard syntax for §3.3, which in turn
provides a *simple and portable* way for library vendors to implement §3.1.


# Proposed wording for C++2b # {#wording}

The wording in this section is relative to [[!N4910|WG21 draft N4910]].

Note: There is no difficulty in changing the attribute syntax to a contextual-keyword syntax;
the only downsides are aesthetic. We can defer that decision to the last minute, according
to CWG's feedback on the final wording.


## Nothrow bidirectional iterator [algorithms.requirements] ## {#wording-algorithms.requirements}

Modify <a href="https://eel.is/c++draft/algorithms.requirements">[algorithms.requirements]</a> as follows:

<small><blockquote>
* If an algorithm's template parameter is named `ForwardIterator`, `ForwardIterator1`, `ForwardIterator2`, or `NoThrowForwardIterator`,
    the template argument shall meet the *Cpp17ForwardIterator* requirements ([forward.iterators]) if it is required to be a mutable iterator,
    or model `forward_iterator` ([iterator.concept.forward]) otherwise.

* If an algorithm's template parameter is named `NoThrowForwardIterator`, the template argument is also required to have the property
    that no exceptions are thrown from increment, assignment, or comparison of, or indirection through, valid iterators.

* If an algorithm's template parameter is named `BidirectionalIterator`, `BidirectionalIterator1`, <del>or</del> `BidirectionalIterator2`, <ins>or
    `NoThrowBidirectionalIterator`,</ins> the template argument shall meet the *Cpp17BidirectionalIterator* requirements ([bidirectional.iterators])
    if it is required to be a mutable iterator, or model `bidirectional_iterator` ([iterator.concept.bidir]) otherwise.

* <ins>If an algorithm's template parameter is named `NoThrowBidirectionalIterator`, the template argument is also required to have the property
    that no exceptions are thrown from increment, decrement, assignment, or comparison of, or indirection through, valid iterators.</ins>

</blockquote></small>


## Relocation operation [defns.relocation] ## {#wording-defns.relocation}

Add a new section in <a href="http://eel.is/c++draft/definitions">[intro.defs]</a>:

<small><blockquote>

: <dfn dfn-type="abstract-op">relocation operation</dfn>

:: the homogeneous binary operation performed by `std::relocate_at`, consisting of a move construction immediately followed by a destruction of the source object

</blockquote></small>


## `relocate_at` and `relocate` [specialized.relocate] ## {#wording-relocate}

Add a new section after <a href="http://eel.is/c++draft/specialized.destroy">[specialized.destroy]</a>:

<small><blockquote>
<xmp>
  template<class T>
  T *relocate_at(T* source, T* dest);
</xmp>

*Mandates:* `T` shall be a complete non-array object type.

*Effects:* Equivalent to:
<xmp>
  struct guard { T *t; ~guard() { destroy_at(t); } } g(source);
  return ::new (voidify(*dest)) T(std::move(*source));
</xmp>
except that if `T` is trivially relocatable <i>[basic.types]</i>, side effects
associated with the relocation of the value of `*source` might not happen.

<xmp>
  template<class T>
  T relocate(T* source);
</xmp>

*Mandates:* `T` shall be a complete non-array object type.

*Effects:* Equivalent to:
<xmp>
  T t = move(source);
  destroy_at(source);
  return t;
</xmp>
except that if `T` is trivially relocatable <i>[basic.types]</i>, side effects
associated with the relocation of the object's value might not happen.
</blockquote></small>

Note:
These functions have both been implemented in my libc++ fork; for `relocate`, see [godbolt.org/z/cqPP4oeE9](https://p1144.godbolt.org/z/cqPP4oeE9)
and [[StdRelocateIsCute]]. My implementation of their "as-if-by-memcpy" codepaths relies on
Clang's `__builtin_memcpy`; vendors can use any vendor-specific means to implement them.
The wording also deliberately permits a low-quality implementation with no such codepath at all.
See [@45:23–48:39](https://www.youtube.com/watch?v=SGdfPextuAU&t=45m23s) in my C++Now 2019 talk.


## `uninitialized_relocate`, `uninitialized_relocate_n`, `uninitialized_relocate_backward` [uninitialized.relocate] ## {#wording-uninitialized.relocate}

Add a new section after <a href="http://eel.is/c++draft/uninitialized.move">[uninitialized.move]</a>:

<small><blockquote>
<xmp>
  template<class InputIterator, class NoThrowForwardIterator>
  NoThrowForwardIterator uninitialized_relocate(InputIterator first, InputIterator last,
                                                NoThrowForwardIterator result);
</xmp>

*Effects:* Equivalent to:
<xmp>
  try {
    for (; first != last; ++result, (void)++first) {
      ::new (voidify(*result))
        typename iterator_traits<NoThrowForwardIterator>::value_type(std::move(*first));
      destroy_at(addressof(*first));
    }
    return result;
  } catch (...) {
    destroy(++first, last);
    throw;
  }
</xmp>
except that if the iterators' common value type is trivially relocatable, side effects
associated with the relocation of the object's value might not happen.

*Remarks:* If an exception is thrown, all objects in both the source and destination
ranges are destroyed.

<xmp>
  template<class InputIterator, class Size, class NoThrowForwardIterator>
    pair<InputIterator, NoThrowForwardIterator>
      uninitialized_relocate_n(InputIterator first, Size n, NoThrowForwardIterator result);
</xmp>

*Effects:* Equivalent to:
<xmp>
  try {
    for (; n > 0; ++result, (void)++first, --n) {
      ::new (voidify(*result))
        typename iterator_traits<NoThrowForwardIterator>::value_type(std::move(*first));
      destroy_at(addressof(*first));
    }
    return {first, result};
  } catch (...) {
    destroy_n(++first, --n);
    throw;
  }
</xmp>
except that if the iterators' common value type is trivially relocatable, side effects
associated with the relocation of the object's value might not happen.

*Remarks:* If an exception is thrown, all objects in both the source and destination
ranges are destroyed.

<xmp>
  template<class BidirectionalIterator, class NoThrowBidirectionalIterator>
    NoThrowBidirectionalIterator
      uninitialized_relocate_backward(BidirectionalIterator first, BidirectionalIterator last,
                                      NoThrowBidirectionalIterator result);
</xmp>

*Effects:* Equivalent to:
<xmp>
  try {
    for (; last != first; ) {
      --last;
      --result;
      ::new (voidify(*result))
        typename iterator_traits<NoThrowBidirectionalIterator>::value_type(std::move(*last));
      destroy_at(addressof(*last));
    }
    return result;
  } catch (...) {
    destroy(first, ++last);
    throw;
  }
</xmp>
except that if the iterators' common value type is trivially relocatable, side effects
associated with the relocation of the object's value might not happen.

*Remarks:* If an exception is thrown, all objects in both the source and destination
ranges are destroyed.
</blockquote></small>

Note: The Remarks allude to blanket wording in <a href="http://eel.is/c++draft/specialized.algorithms#general-2">[specialized.algorithms.general]/2</a>.


## Trivially relocatable type [basic.types.general] ## {#wording-basic.types.general}

Add a new section in <a href="http://eel.is/c++draft/basic.types.general">[basic.types.general]</a>:

<small><blockquote>
An object type `T` is a <dfn dfn-type="abstract-op">trivially relocatable</dfn> type if it is:

  - a trivially copyable type, or

  - an array of trivially relocatable type, or

  - a (possibly cv-qualified) class type declared with a `trivially_relocatable` attribute
    with value `true` <a href="#wording-dcl.attr.trivreloc">[dcl.attr.trivreloc]</a>, or

  - a (possibly cv-qualified) class type which:

    - has no user-provided move constructors or move assignment operators,

    - has no user-provided copy constructors or copy assignment operators,

    - has no user-provided destructors,

    - has no virtual member functions,

    - has no virtual base classes,

    - all of whose members are either of reference type or of trivially relocatable type, and

    - all of whose base classes are of trivially relocatable type.

[*Note:* For a trivially relocatable type, the [$relocation operation$] (as performed by,
for example, the library functions `std::swap` and `std::vector::resize`) is tantamount
to a simple copy of the underlying bytes. *—end note*]

[*Note:* It is intended that most standard library types be trivially relocatable types. *—end note*]

</blockquote></small>

Note: Polymorphic types are disallowed from "natural" trivial relocatability.
See [[#non-trivial-sample-polymorphic|Appendix C, example 5]].
Volatile members are not disallowed. See [[Subobjects]].


## `[[trivially_relocatable]]` attribute [dcl.attr.trivreloc] ## {#wording-dcl.attr.trivreloc}

Add a new section after <a href="http://eel.is/c++draft/dcl.attr.nouniqueaddr">[dcl.attr.nouniqueaddr]</a>:

<small><blockquote>
The *attribute-token* `trivially_relocatable` specifies that a class type's relocation operation has no
visible side-effects other than a copy of the underlying bytes, as if by the library function `std::memcpy`.
It may be applied to the definition of a class. It shall appear at most once in each *attribute-list*.
An *attribute-argument-clause* may be present and, if present, shall have the form
```
    ( constant-expression )
```
The *constant-expression* shall be an integral constant expression of type `bool`.
If no *attribute-argument-clause* is present, it has the same effect as an *attribute-argument-clause*
of `(true)`.

If any definition of a class type has a `trivially_relocatable` attribute with value *V*, then each
definition of the same class type shall have a `trivially_relocatable` attribute with value *V*.
No diagnostic is required if definitions in different translation units have
mismatched `trivially_relocatable` attributes.

If a type `T` is declared with the `trivially_relocatable` attribute, and `T` is either not move-constructible
or not destructible, the program is ill-formed.

If a class type is declared with the `trivially_relocatable` attribute, and the program relies on
observable side-effects of its relocation other than a copy of the underlying bytes, the behavior is undefined.
</blockquote></small>

Issue: "If a type `T` is declared with the `trivially_relocatable` attribute, and `T` is either not move-constructible
or not destructible, the program is ill-formed." We might want to replace this wording with
a mere "Note" <em>encouraging</em> implementations to diagnose.
See <a href="https://p1144.godbolt.org/z/ociAVX">this example</a> where a diagnostic might be unwanted.


## Type traits `is_relocatable` etc. [meta.unary.prop] ## {#wording-meta.unary.prop}

Add new entries to Table 47 in <a href="http://eel.is/c++draft/meta.unary.prop">[meta.unary.prop]</a>:

<small><blockquote>
<table>
<tr><th>Template</th><th>Condition</th><th>Preconditions</th></tr>
<tr>
<td>`template<class T> struct is_relocatable;`</td>
<td>`is_move_constructible_v<T>` is `true` and `is_destructible_v<T>` is `true`</td>
<td>T shall be a complete type, <i>cv</i> `void`, or an array of unknown bound.</td>
</tr>
<tr>
<td>`template<class T> struct is_nothrow_relocatable;`</td>
<td>`is_relocatable_v<T>` is `true` and both the indicated move-constructor and the destructor are known not to throw any exceptions.</td>
<td>T shall be a complete type, <i>cv</i> `void`, or an array of unknown bound.</td>
</tr>
<tr>
<td>`template<class T> struct is_trivially_relocatable;`</td>
<td>`T` is a [$trivially relocatable$] type.</td>
<td>T shall be a complete type, <i>cv</i> `void`, or an array of unknown bound.</td>
</tr>
</table>
</blockquote></small>


## `relocatable` concept [concept.relocatable] ## {#wording-concept.relocatable}

Add a new section after <a href="http://eel.is/c++draft/concept.copyconstructible">[concept.copyconstructible]</a>:

<small><blockquote>
<xmp>
  template<class T>
    concept relocatable = move_constructible<T>;
</xmp>

If `T` is an object type, then let `rv` be an rvalue of type `T`, `lv` an lvalue of type `T` equal to `rv`,
and `u2` a distinct object of type `T` equal to `rv`.
`T` models `relocatable` only if

  - After the definition `T u = rv;`, `u` is equal to `u2`.

  - `T(rv)` is equal to `u2`.

  - If the expression `u2 = rv` is well-formed, then the expression has the same semantics as
    `u2.~T(); ::new ((void*)std::addressof(u2)) T(rv);`

  - If the definition `T u = lv;` is well-formed, then after the definition `u` is equal to `u2`.

  - If the expression `T(lv)` is well-formed, then the expression's result is equal to `u2`.

  - If the expression `u2 = lv` is well-formed, then the expression has the same semantics as
    `u2.~T(); ::new ((void*)std::addressof(u2)) T(lv);`

</blockquote></small>

Note: We intend that a type may be relocatable
regardless of whether it is copy-constructible; but, if it is copy-constructible then copy-and-destroy
must have the same semantics as move-and-destroy. We intend that a type may be relocatable regardless of
whether it is assignable; but, if it is assignable then assignment must have the same semantics as
destroy-and-copy or destroy-and-move.
The semantic requirements on assignment help us optimize `vector::insert` and `vector::erase`.
`pmr::forward_list<int>` satisfies `relocatable`, but it models `relocatable`
only when all relevant objects have equal allocators.


# Rationale and alternatives # {#alternatives}

## Attribute `[[maybe_trivially_relocatable]]` ## {#maybe-trivially-relocatable}

The Clang patch currently available on Godbolt Compiler Explorer supports both
`[[clang::trivially_relocatable]]` and another attribute called `[[clang::maybe_trivially_relocatable]]`,
which John McCall requested that I explore.

See [P1144R4 section 6.2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1144r4.html#maybe-trivially-relocatable)
for discussion of the `[[clang::maybe_trivially_relocatable]]` attribute, including the reasons
I do not propose it for standardization.

In Issaquah (February 2023), [[P2786R0]] suggested a very similar design to `[[clang::maybe_trivially_relocatable]]`.
EWGI took a three-way straw poll on the design of `[[clang::trivially_relocatable]]` versus `[[clang::maybe_trivially_relocatable]]`,
with an inconclusive 7–5–6 vote (the author of P1144 voting "For" and the three representatives of P2786
presumably voting "Against."


## Confusing interactions with `std::pmr` ## {#pmr-concerns}

Note: This section was added in P1144R5 and revised in P1144R7.
Here I assume libc++, where `std::string` is trivially relocatable.
Feel free to substitute your favorite trivially relocatable container type;
I'm sticking with `string` for these examples because it is short
and easy to spell.

P1144 aims to permit efficient insertion and erasure in `std::vector`.
[Example:](https://p1144.godbolt.org/z/vv5q69q44)

```c++
    std::vector<std::string> vs(501);
    vs.erase(vs.begin());
```

This `erase` requires us to shift down 500 `std::string` objects, which can be done either
by 500 calls to `string::operator=` followed by one call to `~string`, or by
one call to `~string` followed by a `memmove` (as seen for example in [[Folly]] and BSL;
see [[#applications|table §2.1]]). We want to permit BSL's implementation.
That's why since P1144R5, the definition of `concept relocatable` in [[#wording-concept.relocatable|§4.4]]
places semantic requirements on `T`'s assignment operators (if they exist) as well as on
`T`'s constructors and destructors.

`std::pmr::polymorphic_allocator<int>` is a trivially relocatable type:

```c++
    std::vector<std::pmr::polymorphic_allocator<int>> va;
    va.emplace_back(&mr1);
    va.emplace_back(&mr2);
    va.emplace_back(&mr3);
    va.erase(va.begin());  // A
```

Line "A" can use trivial relocation (`memmove`) because it is fast and correct:
after line "A" we will have `vv[0].resource() == &mr2`.
But an STL container *using* a `polymorphic_allocator` suddenly becomes problematic:

```c++
    std::vector<std::pmr::string> vp;
    vv.emplace_back("1", &mr1);
    vv.emplace_back("2", &mr2);
    vv.emplace_back("3", &mr3);
    vv.reserve(1000);  // B
    vv.erase(vv.begin());  // C
```

Line "B" can certainly use trivial relocation (`memcpy`) because it is fast and correct.
But on line "C", the difference between `pmr::string::operator=` and `memmove` is detectable:
the former makes `vp[0].get_allocator().resource() == &mr1` and the latter would make
`vp[0].get_allocator().resource() == &mr2`. Finally, hypothetically, if `vector::erase` were
implemented in terms of a single `std::rotate` followed by a call to `~string`, we'd have UB here
because it is UB to `swap` strings with unequal allocators.

For now, P1144R7's proposed wording implies that `std::pmr::string` must not be marked as trivially relocatable.
But if we add some blanket wording setting appropriate preconditions on `std::pmr::string`
(for example, permitting `vector::erase` and `deque::erase` to be implemented in terms of `rotate`,
or forbidding STL containers from containing PMR types with unequal allocators), then
vendors could make `std::pmr::string` trivially relocatable.

Issue: What new wording is needed to achieve this?

Note: Regardless, `std::pmr::polymorphic_allocator<int>` itself is trivially relocatable.
The problem above arises from `propagate_on_move_assignment` etc., which affect the behavior of
the *container's* `operator=`. The author of the container makes
the choice whether to respect POCMA/POCCA/POCS, and also makes the choice
when to warrant trivial relocatability. These choices are correlated, and so it is natural that
they should be made by the same person, at the same place in the source code.

## Overlapping base-class subobjects ## {#overlap-concerns}

Note: This section was added in P1144R7.

In the following snippet, `struct Dangerous` fails to be trivially relocatable in practice
because its assignment operator doesn't overwrite all `sizeof(Dangerous)` bytes of the
destination object. The tail padding of `Dangerous` is allowed to contain the value of
`Derived::k`. ([Godbolt.](https://godbolt.org/z/T7rzrY3x9))

```c++
struct Dangerous {
    Dangerous(int i, int j) : i(i), j(j) {}
    int i;
    short j;
};
static_assert(std::is_standard_layout_v<Dangerous>);
static_assert(std::is_trivially_relocatable_v<Dangerous>);

struct Derived : Dangerous {
    Derived(int i, int j, int k) : Dangerous(i, j), k(k) {}
    short k;
};
static_assert(!std::is_standard_layout_v<Derived>);
static_assert(!std::is_trivially_relocatable_v<Derived>);

int main() {
    Derived a = Derived(1,2,3);
    Derived b = Derived(4,5,6);
    Dangerous &ra = a, &rb = b;
    std::swap(ra, rb);
    assert(a.k == 3 && b.k == 6);
}
```

[[Subspace]] presented a version of this snippet, which led to the suggestion to consider only
standard-layout types "naturally" trivially relocatable. Unfortunately, that criterion affects only
`Derived`, whereas it's `Dangerous` that we can't trivially swap.

Possible solution #1 is due to [[Subspace]]: Bring the ABI notion of "data size" into standard C++,
so that we can say that the "data size" of `Dangerous` is less than its "size." Types with "data size"
less than "size" aren't naturally trivially relocatable. But this is painful, because it makes
`is_trivially_relocatable_v<Dangerous>` false.

Possible solution #2: Don't expose the ABI notion of "data size," but do take ABI into account
when deciding whether `Dangerous` is naturally trivially relocatable. This makes
`is_trivially_relocatable_v<Dangerous>` implementation-defined in theory (false in practice) —
even though it is trivially copyable!
The difficulty here is crafting the wording.

Possible solution #3: Bring the ABI notion of "data size" into standard C++, and make the trivial
version of `std::swap(T&, T&)` swap only `datasizeof(T)` bytes of memory instead of `sizeof(T)` bytes.
This makes it difficult for the vendor to benefit from trivial relocation in `rotate` (because
just calling `swap` won't swap all the bytes, which makes it impossible for the optimizer
to coalesce adjacent memcpy operations into one big memcpy).
This makes `is_trivially_relocatable_v<Dangerous>` true, makes `std::swap(ra, rb)` trivial,
and makes `std::rotate` non-trivial.

Possible solution #4: Disallow `std::swap(T&, T&)` from using trivial relocation unless
it can prove that it's operating on complete objects. This would also disallow e.g. `std::rotate`
from using trivial relocation unless it's operating on complete objects (e.g.
because it received a contiguous range). This creates fewer surprises, but makes it difficult
for the vendor to benefit from trivial relocation in `rotate` (because they can't just get
it for free by calling `swap`; they'd have to create a second entrypoint `__swap_complete_objects`
and figure out how to call that instead of `swap` from algorithms that would benefit from it).
This makes `is_trivially_relocatable_v<Dangerous>` true, makes `std::swap(ra, rb)` non-trivial,
and makes `std::rotate` trivial with heroics.

Possible solution #5 is what [[P1144R6]] implicitly assumed: Put a precondition on `swap(T&, T&)`
(both the template and user-defined ADL overloads) that says it's UB if either argument refers
to an overlapping subobject.
This makes `is_trivially_relocatable_v<Dangerous>` true, makes `std::swap(ra, rb)` undefined behavior,
and makes `std::rotate` trivial.
The difficulty here is getting WG21 to accept a new precondition on `swap`.


# Acknowledgements # {#acknowledgements}

Thanks to Pablo Halpern for [[N4158]], to which this paper bears a striking resemblance —
including the meaning assigned to the word "trivial," and the library-algorithm approach to avoiding the
problems with "lame duck objects" discussed in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm#Alternative%20move%20designs">the final section</a>
of [[N1377]]. See <a href="http://wiki.edg.com/bin/view/Wg21rapperswil2014/N4034">discussion of N4034 at Rapperswil</a> (June 2014)
and <a href="http://wiki.edg.com/bin/view/Wg21urbana-champaign/EvolutionWorkingGroup#N4158_Destructive_Move_Rev_1">discussion
of N4158 at Urbana</a> (November 2014).

Significantly different approaches to this problem have previously appeared in Rodrigo Castro Campos's
[[N2754]], Denis Bider's [[P0023R0]] (introducing a core-language "relocation" operator), and
Niall Douglas's [[P1029R3]] (treating trivial relocatability as an aspect of move-construction in isolation,
rather than an aspect of the class type as a whole). A less different approach is taken
in Mungo Gill & Alisdair Meredith's [[P2786R0]].

Thanks to Elias Kosunen, Niall Douglas, John Bandela, and Nicolas Lesser for their feedback on early drafts of P1144R0.

Thanks to Nicolas Lesser and John McCall for their review comments on the Clang implementation [[D50119]].

Many thanks to Matt Godbolt for allowing me to install my Clang fork on Compiler Explorer
(<a href="https://p1144.godbolt.org/z/oWEd_X">godbolt.org</a>). See also [[Announcing]].

Thanks to Howard Hinnant for appearing with me on [[CppChat]], and to Jon Kalb and Phil Nash for hosting us.

Thanks to Marc Glisse for his work integrating a "trivially relocatable" trait into GNU libstdc++
and for answering my questions on [GCC bug 87106](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=87106).

Thanks to Jens Maurer for his feedback on P1144R3 at Kona 2019, and to Corentin Jabot for championing
P1144R4 at Prague 2020.

Thanks to Dana Jansens for her contributions re overlapping and non-standard-layout types (see [[Subspace]]),
to Alisdair Meredith for our extensive discussions during the February 2023 drafting of [[P2786R0]],
to Giuseppe D'Angelo and Thiago Maceira for contributing the Qt entries in [[#applications|table §2.1]],
and to Giuseppe D'Angelo for extensive review comments and discussion.


Appendix A: Straw polls {#polls}
=================================


## Polls taken at EWGI at Issaquah on 2023-02-10 ## {#taken-polls-2023-02-10}

Arthur O'Dwyer presented P1144R6. Alisdair Meredith presented [[P2786R0]] (which proposed a
`[[maybe_trivially_relocatable]]`-style facility, and expressed it as a contextual keyword instead
of an attribute). EWGI took the following [straw polls](https://wiki.edg.com/bin/view/Wg21issaquah2023/EWGIP1144R6)
(as well as polls on attribute syntax and on both papers' readiness for EWG).

<table class="def">
<tr><th style="width: 70%;"></th><th>**SF**</th><th>**F**</th><th>**N**</th><th>**A**</th><th>**SA**</th></tr>

<tr><th><small>The problem presented in P1144/P2786 is worth solving.</th>
<th> 10 </th><th> 8 </th><th> 0 </th><th> 0 </th><th> 0 </th></tr>

<tr><th><small>The problem being introduced in P1144/P2786 should be solved in a more general way instead of as proposed.</th>
<th> 3 </th><th> 0 </th><th> 5 </th><th> 6 </th><th> 4 </th></tr>

<tr><th><small>The annotation should "trust the user" as in P1144R6's `[[trivially_relocatable]]` ("sharp knife"),
               instead of diagnosing as in P1144R6's `[[clang::maybe_trivially_relocatable]]` and P2786R0's `trivially_relocatable` ("dull knife"). Three-way poll.</th>
<th> — </th><th> 7 </th><th> 5 </th><th> 6 </th><th> — </th></tr>
</table>

## Polls taken at EWGI at Prague on 2020-02-13 ## {#taken-polls-2020-02-13}

Corentin Jabot championed P1144R4. EWGI discussed P1144R4 and Niall Douglas's [[P1029R3]] consecutively,
then took the following [straw polls](https://wiki.edg.com/bin/view/Wg21prague/P1144R4SG17)
(as well as a poll on the attribute syntax).

<table class="def">
<tr><th style="width: 70%;"></th><th>**SF**</th><th>**F**</th><th>**N**</th><th>**A**</th><th>**SA**</th></tr>

<tr><th><small>We believe that P1029 and P1144 are sufficiently different that they should be advanced separately.</th>
<th> 7 </th><th> 3 </th><th> 2 </th><th> 0 </th><th> 0 </th></tr>

<tr><th><small>EWGI is ok to have the spelling as an attribute with an expression argument.</th>
<th> 3 </th><th> 5 </th><th> 1 </th><th> 1 </th><th> 0 </th></tr>

<tr><th><small>EWGI thinks the author should explore P1144 as a customizable type trait.</th>
<th> 0 </th><th> 0 </th><th> 0 </th><th> 9 </th><th> 2 </th></tr>

<tr><th><small>Forward P1144 to EWG.</th>
<th> 1 </th><th> 3 </th><th> 4 </th><th> 1 </th><th> 0 </th></tr>
</table>

For polls taken September–November 2018, see [[P1144R6]].


Appendix B: Sample code {#samples}
=======================

See [[P1144R6]]'s Appendix B for reference implementations of `relocate`, `relocate_at`, and
P1144R6's version of the `uninitialized_relocate` library algorithm, plus
a conditionally trivially relocatable `std::optional<T>`.

I have implemented the entire Standard Library using the `[[clang::trivially_relocatable]]`
attribute; you can find the source code [on my GitHub](https://github.com/Quuxplusone/libcxx/tree/trivially-relocatable)
and explore the resulting codegen [on Godbolt Compiler Explorer](https://p1144.godbolt.org/z/t28saC).


Appendix C: Examples of non-trivially relocatable class types {#non-trivial-samples}
=============================================================

## Class contains pointer to self ## {#non-trivial-sample-string}

This fictional `short_string` illustrates a mechanism that can apply
to any small-buffer-optimized class. <a href="https://github.com/llvm-mirror/libcxx/blob/4e7ffcaa/include/functional#L1719-L1734">libc++'s `std::function`</a>
uses this mechanism and is thus not trivially relocatable.

However, different mechanisms for small-buffer optimization exist.
<a href="https://github.com/llvm-mirror/libcxx/blob/8fdc4918/include/any#L389-L394">libc++'s `std::any`</a> achieves small-buffer optimization
on a 24-byte buffer, without (necessarily) sacrificing trivial relocatability.

<small>
```c++
struct short_string {
    char *data_ = buffer_;
    size_t size_ = 0;
    char buffer_[8] = {};

    const char *data() const { return data_; }

    short_string() = default;
    short_string(const char *s) : size_(strlen(s)) {
        if (size_ < sizeof buffer_)
            strcpy(buffer_, s);
        else
            data_ = strdup(s);
    }
    short_string(short_string&& s) {
        memcpy(this, &s, sizeof(*this));
        if (s.data_ == s.buffer_)
            data_ = buffer_;
        else
            s.data_ = nullptr;
    }
    ~short_string() {
        if (data_ != buffer_)
            free(data_);
    }
};
```
</small>


## Allocated memory contains pointer to self ## {#non-trivial-sample-list}

`std::list` needs somewhere to store its "past-the-end" node, commonly referred to
as the "sentinel node," whose `prev` pointer points to the list's last node.
If the sentinel node is allocated on the heap, then `std::list` can be trivially
relocatable; but if the sentinel node is placed within the `list` object itself
(as happens on libc++ and libstdc++), then relocating the `list` object requires
fixing up the list's last node's `next` pointer so that it points to the
new sentinel node inside the destination `list` object. This fixup of an arbitrary
heap object cannot be simulated by `memcpy`.

Traditional implementations of `std::set` and `std::map` also store a "past-the-end"
node inside themselves and thus also fall into this category.

<small>
```c++
struct node {
    node *prev_ = nullptr;
    node *next_ = nullptr;
};
struct list {
    node n_;
    iterator begin() { return iterator(n_.next_); }
    iterator end() { return iterator(&n_); }
    list(list&& l) {
        if (l.n_.next_) l.n_.next_->prev_ = &n_;  // fixup
        if (l.n_.prev_) l.n_.prev_->next_ = &n_;  // fixup
        n_ = l.n_;
        l.n_ = node{};
    }
    // ...
};
```
</small>


## Class invariant depends on `this` ## {#non-trivial-sample-offset-ptr}

The `offset_ptr` provided by [[Boost.Interprocess]] is an example of this category.

<small>
```c++
struct offset_ptr {
    uintptr_t value_;

    uintptr_t here() const { return uintptr_t(this); }
    uintptr_t distance_to(void *p) const { return uintptr_t(p) - here(); }
    void *get() const { return (void*)(here() + value_); }

    offset_ptr() : value_(distance_to(nullptr)) {}
    offset_ptr(void *p) : value_(distance_to(p)) {}
    offset_ptr(const offset_ptr& rhs) : value_(distance_to(rhs.get())) {}
    offset_ptr& operator=(const offset_ptr& rhs) {
        value_ = distance_to(rhs.get());
        return *this;
    }
    ~offset_ptr() = default;
};
```
</small>


## Program invariant depends on `this` ## {#non-trivial-sample-registry}

In the following snippet, `struct Widget` is relocatable, but not
trivially relocatable, because the relocation operation of destroying a `Widget` at point A
and constructing a new `Widget` at point B has behavior that is observably different
from a simple `memcpy`.

<small>
```c++
std::set<void *> registry;

struct registered_object {
    registered_object() { registry.insert(this); }
    registered_object(registered_object&&) = default;
    registered_object(const registered_object&) = default;
    registered_object& operator=(registered_object&&) = default;
    registered_object& operator=(const registered_object&) = default;
    ~registered_object() { registry.erase(this); }
};

struct Widget : registered_object {};
```
</small>


## Polymorphic downcast effectively relies on offset-into-self ## {#non-trivial-sample-polymorphic}

Thanks to David Stone for this example.
In the following snippet, `struct Base` is relocatable, but not trivially relocatable,
because its copy constructor and assignment operator do not copy the entire state of the
right-hand object. (Notice that `pf` is initialized with `f`, not with a copy of `o.pf`.)

```c++
struct Base {
    static int f(Base*) { return 21; }
    int (*pf)(Base*);
    Base(int (*pf)(Base*) = f) : pf(pf) {}
    Base(const Base& o) : pf(f) {}
    Base& operator=(const Base&) { return *this; }
};
struct Derived : Base {
    static int f(Base *self) { return ((Derived*)self)->x; }
    Derived() : Base(f) {}
    Derived(const Derived&) = default;
    Derived& operator=(const Derived& o) { x = o.x; return *this; }
    int x = 42;
};

int main() {
    Base&& d = Derived();
    Base&& b = Base();
    std::swap(b, d);
    printf("%d\n", b.pf(&b));
}
```

The above snippet is isomorphic to a classically polymorphic hierarchy
with virtual methods. Here is the same snippet using `virtual`:

```c++
struct Base {
    virtual int f() { return 21; }
};
struct Derived : Base {
    int f() override { return x; }
    int x = 42;
};

int main() {
    Base&& b = Base();
    Base&& d = Derived();
    std::swap(b, d);
    printf("%d\n", b.f());
}
```

This is why (since P1144R5) the compiler will not consider types with
virtual methods to be "naturally" trivially relocatable.


Appendix D: Implementation experience {#implementation}
=====================================

A prototype Clang/libc++ implementation is at

- [github.com/Quuxplusone/llvm-project/tree/trivially-relocatable](https://github.com/Quuxplusone/llvm-project/tree/trivially-relocatable)
- <a href="https://p1144.godbolt.org/z/oWEd_X">godbolt.org</a>, under the name "x86-64 clang (experimental P1144)"

Side-by-side case studies of `[[trivially_relocatable]]`, `[[maybe_trivially_relocatable]]`,
and `[[trivially_relocatable(bool)]]` are given in [[P1144R6]].

As of November 2018, libstdc++ performs the `vector::resize` optimization
for any type which has manually specialized `std::__is_bitwise_relocatable`.
(See [this Godbolt](https://godbolt.org/z/f7971hEcG).)
Manual specialization is also the approach used by [[Qt]], [[Folly]], and [[BSL]].
As of 2023-02-12, the only libstdc++ library type for which `__is_bitwise_relocatable` has
been specialized is `deque`; see [[Deque]].

Clang trunk provides a compiler builtin type trait `__is_trivially_relocatable(T)`
(see [[D114732]]), which is largely the same as the trait proposed in this paper. (There are slight
differences; [e.g.](https://p1144.godbolt.org/z/MhncMxrdj), Clang reports polymorphic types, reference types, and incomplete types
as trivially relocatable, whereas P1144 does not. I'm not aware that any of Clang's differences were intentional.)
Clang trunk has no equivalent of the `[[trivially_relocatable]]`
attribute, so `__is_trivially_relocatable(T)` is true only for
trivially copyable types and types marked with the `[[clang::trivial_abi]]`
attribute. As of 2023-02-12, Clang trunk has no conception of a type which is non-trivial for purposes of calls
and yet is trivially relocatable. But Clang's current status is compatible with P1144 (modulo the
few unintentional differences in `__is_trivially_relocatable` mentioned above).


Appendix E: Open questions {#open-questions}
=====================================

Issue: P1144R6 `uninitialized_relocate(In, In, Fwd)`'s spec lacks the magic either-direction-overlap-handling of `memmove`.
Either-direction-overlap-handling is implementable only for contiguous iterators (which can be converted to pointers);
it is not implementable for arbitrary random-access iterators. Is there ever a case where someone might want to e.g.
`uninitialized_relocate(rbegin(a), rend(a), begin(b))`? Do we need a separate algorithm?
[[Qt]] provides both
<a href="https://github.com/qt/qtbase/blob/4dbd97c/src/corelib/tools/qcontainertools_impl.h#L203-L233">`q_relocate_overlap_n(T*, size_t, T*)`</a>
with magic overlap handling, and
<a href="https://github.com/qt/qtbase/blob/4dbd97c/src/corelib/tools/qcontainertools_impl.h#L71-L85">`q_uninitialized_relocate_n(T*, size_t, T*)`</a>
without.
[[P2786R0]] proposes only `relocate(T*, T*, T*)` with magic overlap handling.
[[P1144R6]] proposed only `uninitialized_relocate(In, In, Fwd)` without.

Issue: In P1144R7, types with vptrs are never naturally trivially relocatable.
Arthur claims that types with vptrs should be used only with inheritance, which means they never do value semantics
(they slice instead), which means relocating one is always a bug, just like assigning or copying one. But [[P2786R0]]
proposes to make polymorphic types naturally trivially relocatable. Is there any use-case for relocating polymorphic
types? Is P1144 being too conservative here?

Issue: In P1144R7, `std::vector<std::pmr::vector<int>>::erase(pos)` can use trivial relocation to
"close up the window" in the vector; this is also done in [[Qt]], [[Folly]], and [[BSL]]. The difference between
closing-the-window-by-move-assignment and closing-the-window-by-memmove is detectable in a conforming C++ program.
Therefore [[P2786R0]] proposes that relocation should not be allowed here.
Is there any implementation experience of P2786R0's conservative position here?
([[BSL]]'s `bsl::vector` follows P1144R7's liberal position already.)

Issue: In P1144R6, `std::rotate(a, a+2, a+8)` on an array `std::pmr::vector<int> a[10]` can use trivial relocation to
swap the elements. The difference between swap-by-move-assignment and swap-by-trivial-relocation is not detectable
in a conforming C++ program, because swapping `pmr::vector`s with unequal allocators is UB.
[[P2786R0]] conservatively proposes that relocation should not be allowed here, anyway.
Is there any usage experience in [[Qt]], [[BSL]], [[Folly]], or elsewhere that bears on this question?
(Arthur's libc++ fork does relocation here, but doesn't really count as usage experience since he's the only one using it.)

Issue: We need a solution for potentially overlapping subobjects; see [[#overlap-concerns]].

<pre class=biblio>
{
  "Announcing": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Announcing \"trivially relocatable\"",
    "href": "https://quuxplusone.github.io/blog/2018/07/18/announcing-trivially-relocatable/",
    "date": "July 2018"
  },
  "Bench": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Benchmark code from \"The Best Type Traits C++ Doesn't Have\"",
    "href": "https://github.com/Quuxplusone/from-scratch/blob/095b246d/cppnow2018/benchmark-relocatable.cc",
    "date": "April 2018"
  },
  "Boost.Interprocess": {
    "authors": [
      "Ion Gaztañaga"
    ],
    "title": "Mapping Address Independent Pointer: offset_ptr",
    "href": "https://www.boost.org/doc/libs/1_67_0/doc/html/interprocess/offset_ptr.html",
    "date": "2005"
  },
  "BSL": {
    "authors": [
      "Bloomberg"
    ],
    "title": "bslmf::IsBitwiseMoveable: bitwise moveable trait metafunction",
    "href": "https://github.com/bloomberg/bde/blob/962f7aa/groups/bsl/bslmf/bslmf_isbitwisemoveable.h#L8-L48",
    "date": "2013–2022"
  },
  "CppChat": {
    "authors": [
      "Howard Hinnant",
      "Arthur O'Dwyer"
    ],
    "title": "cpp.chat episode 40: It works but it's undefined behavior",
    "href": "https://www.youtube.com/watch?v=8u5Qi4FgTP8",
    "date": "August 2018"
  },
  "D50119": {
    "authors": [
      "Arthur O'Dwyer",
      "Nicolas Lesser",
      "John McCall"
    ],
    "title": "Compiler support for P1144R0 __is_trivially_relocatable(T)",
    "href": "https://reviews.llvm.org/D50119",
    "date": "July 2018"
  },
  "D114732": {
    "authors": [
      "Devin Jeanpierre"
    ],
    "title": "[clang] Mark trivial_abi types as trivially relocatable",
    "href": "https://reviews.llvm.org/D114732",
    "date": "November 2021"
  },
  "Deque": {
    "authors": [
      "Marc Glisse"
    ],
    "title": "Improve relocation ... (__is_trivially_relocatable): Specialize for deque",
    "href": "https://github.com/gcc-mirror/gcc/commit/a9b9381580de611126c9888c1a6c12a77d9b682e",
    "date": "November 2018"
  },
  "FixedCapacityVector": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "P1144 case study: Moving a `fixed_capacity_vector`",
    "href": "https://quuxplusone.github.io/blog/2019/02/22/p1144-fixed-capacity-vector/"
  },
  "Folly": {
    "authors": [
      "Facebook"
    ],
    "title": "Folly documentation on \"Object Relocation\"",
    "href": "https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md#object-relocation"
  },
  "FollyIssue889": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Traits.h marks std::list as trivially relocatable, but in fact it is not",
    "href": "https://github.com/facebook/folly/issues/889"
  },
  "N1377": {
    "authors": [
      "Howard Hinnant",
      "Peter Dimov",
      "Dave Abrahams"
    ],
    "title": "N1377: A Proposal to Add Move Semantics Support to the C++ Language",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm",
    "date": "September 2002"
  },
  "N2271": {
    "authors": [
      "Paul Pedriana"
    ],
    "title": "N2271: EASTL — Electronic Arts Standard Template Library",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html#type_traits_extensions"
  },
  "N2754": {
    "authors": [
      "Rodrigo Castro Campos"
    ],
    "title": "N2754: TriviallyDestructibleAfterMove and TriviallyReallocatable (rev 3)",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2754.html",
    "date": "September 2008"
  },
  "N4158": {
    "authors": [
      "Pablo Halpern"
    ],
    "title": "N4158: Destructive Move (rev 1)",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf",
    "date": "October 2014"
  },
  "P0023R0": {
    "authors": [
      "Denis Bider"
    ],
    "title": "P0023R0: Relocator: Efficiently Moving Objects",
    "href": "http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0023r0.pdf",
    "date": "April 2016"
  },
  "P0843R5": {
    "authors": [
      "Gonzalo Brito Gadeschi"
    ],
    "title": "static_vector",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0843r5.html",
    "date": "July 2022"
  },
  "P1029R3": {
    "authors": [
      "Niall Douglas"
    ],
    "title": "P1029R3: move = bitcopies",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1029r3.pdf",
    "date": "January 2020"
  },
  "P1144R6": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "P1144R6: Object relocation in terms of move plus destroy",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1144r6.html",
    "date": "June 2022"
  },
  "P2786R0": {
    "authors": [
      "Mungo Gill",
      "Alisdair Meredith"
    ],
    "title": "P2786R0: Trivial relocatability options",
    "href": "https://wg21.link/p2786r0",
    "date": "February 2023"
  },
  "Qt": {
    "title": "Qt Base",
    "href": "https://github.com/qt/qtbase/",
    "date": "February 2023"
  },
  "StdRelocateIsCute": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "std::relocate's implementation is cute",
    "href": "https://quuxplusone.github.io/blog/2022/05/18/std-relocate/",
    "date": "May 2022"
  },
  "Subobjects": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "When is a trivially copyable object not trivially copyable?",
    "href": "https://quuxplusone.github.io/blog/2018/07/13/trivially-copyable-corner-cases/",
    "date": "July 2018"
  },
  "Subspace": {
    "authors": [
      "Dana Jansens"
    ],
    "title": "Trivially Relocatable Types in C++/Subspace",
    "href": "https://danakj.github.io/2023/01/15/trivially-relocatable.html",
    "date": "January 2023"
  }
}
</pre>
