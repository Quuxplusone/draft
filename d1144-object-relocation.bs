<pre class='metadata'>
Title: std::is_trivially_relocatable
Shortname: D1144
Revision: 13
!Draft Revision: 74
Audience: WG21
Status: D
Group: WG21
URL:
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  P1144 trivial relocation is used by Abseil, AMC, BSL, Folly, HPX, Parlay, Pocketpy, Qt, Subspace, and Thrust.
  Let's make it part of the C++ standard.
Date: 2025-04-13
</pre>

<style>
p    {-moz-hyphens: none; -ms-hyphens: none; -webkit-hyphens: none; hyphens: none;}
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
good  {background-color: #CCFFCC; text-decoration: underline;}
bad  {background-color: #FFCACA; text-decoration: underline;}
</style>


# What's going on here? # {#intro}

Some of us submitted [[P3236]] for St Louis 2024, indicating our disapproval of [[P2786R4]]
and asking for our preferred direction [[P1144R10]] to be discussed in committee. This resulted
in EWG's "clawing back" P2786 for one meeting, but did not result in any committee discussion
of P1144, due to its primary author.

[[P2786R13]] was then merged into the Working Draft at Hagenberg 2024.
Almost all of P3236's objections remain unaddressed.

- "Types with user-provided `operator=` are reported as trivially relocatable by default."
    &nbsp; <good>Fixed.</good>

- "The programmer is allowed to create a type that is trivially copyable but not trivially relocatable."
    &nbsp; <bad>Not fixed.</bad>

- "It's ill-formed to create a trivially relocatable type with an `offset_ptr` member,
    or even a Boost `static_vector` member."
    &nbsp; <bad>Not fixed.</bad>

- "No backward-compatible syntax. P2786 proposes a new keyword, and goes out of its way to make the keyword unusable in C++23-and-earlier."
    &nbsp; <bad>Not fixed.</bad>

- "P1144, by providing stronger guarantees of value semantics, permits more optimizations."
    &nbsp; <bad>Not fixed.</bad>

- "P1144 provides a well-designed and stable library API."
    &nbsp; <good>Fixed,</good> in that the P1144 library API has been approved for C++26 via [[P3516]].

- "P2786's warrant marking is ‘viral downward.’ As container authors, we think P2786's normalization
    of a large number of explicit markings will cause programmer fatigue and lead to bugs."
    &nbsp; <bad>Not fixed.</bad>

- "Deliberately incomplete. P2786's authors have drafted followup papers including
    [[P2959]] and [[P2967]], all with incomplete wording and ‘heroic’ changes,
    for example `std::container_replace_with_assignment`."
    &nbsp; Arguably fixed, in P2786 was merged in its present state, and P2959 and P2967
    seem to have been abandoned. We now know with certainty what we have gotten,
    and we can say with certainty that it does not suit us.

In addition, the Working Draft version of P2786R13 contains several problems that weren't present in P2786R4 at the time we wrote [[P3236]].

- The ARM64e platform uses "vptr signing." Its vptrs are never safe to memcpy. Yet the Working Draft
    permits `is_trivially_relocatable` to return `true` for types with vptrs, types recursively
    containing members with vptrs, etc. This means that it is never safe to use e.g. `realloc`
    on ARM64e even when we know that the objects being reallocated are all `is_trivially_relocatable`.
    &nbsp; <bad>New problem, not fixed.</bad>

- P2786's approved syntax is shockingly ugly: `class C trivially_relocatable_if_eligible replaceable_if_eligible { }`.
    P1144's attribute syntax is unobtrusive by comparison: `class [[trivially_relocatable]] C { }`.
    &nbsp; <bad>New problem, not fixed.</bad>

Therefore we submit this revision of P1144, which addresses all of these problems directly,
as a diff against the current Working Draft. We gladly list ourselves as coauthors of this proposal,
in the same way that five Bloomberg employees listed themselves as coauthors of [[P2786R13]].
Unlike them, we come from a variety of backgrounds and maintain a variety of libraries.

We beg WG21 to resolve the community's concerns before it is too late.


<!--P1144 is the industry standard for `is_trivially_relocatable`, as already used in production
by Qt, Google Abseil and Skia, Facebook Folly, Amadeus AMC, Carnegie Mellon Parlay,
and in fact by Bloomberg BSL (which has never implemented anything corresponding to `is_replaceable`).

However, because of the primary authorship of P1144, EWG refused to discuss P1144,
and in Tokyo 2024 voted (7–9–6–0–2) to forward [[P2786]] for consideration by CWG.
In St Louis 2024, following the publication of [[P3233]] "Issues with P2786"
and [[P3236]] "Please reject P2786 and adopt P1144," EWG voted (21–15–3–6–5) to
take P2786 back for further EWG discussion. However, EWG's chair still refused
to discuss P1144 in committee. ([See the minutes](https://wiki.edg.com/bin/view/Wg21stlouis2024/NotesEWGTrivialRelocatability):
"Do we poll whether to see P1144?"
[See /r/cpp discussion](https://old.reddit.com/r/cpp/comments/1j8p9da/why_p2786_was_adopted_instead_of_p1144_i_thought/mh8knc7/)
of the authorship concern.)

In Hagenberg 2024, with Giuseppe D'Angelo the only representative of P3236 in the room,
EWG voted (19–26–7–4–1) to forward P2786 again to CWG; it went through two more revisions
in CWG that week; and then CWG forwarded it to plenary, where it passed (76–30–11;
see [N5007](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5007.pdf)).

P1144 has still never been seen by EWG.

We library authors, still believing that ours is the correct direction for C++,
and believing that P2786 is *not* the correct direction for C++26,
therefore submit a new revision of P1144 with ourselves as additional authors,
in the hope that WG21 will reconsider their previous decision to refuse discussion of P1144.


# Semantic requirements of a non-proposed `concept relocatable` # {#concept}

We intend that a type may be relocatable
regardless of whether it is copy-constructible; but, if it is copy-constructible then copy-and-destroy
must have the same semantics as move-and-destroy. We intend that a type may be relocatable regardless of
whether it is assignable; but, if it is assignable then assignment must have the same semantics as
destroy-and-copy or destroy-and-move.
The semantic requirements on assignment help us optimize `vector::insert`, `vector::erase`,
`swap_ranges`, type-erasure types such as `std::function`, algorithmic improvements to `std::sort`,
and so on.

[[P1144R12]] proposed to add a new concept directly codifying these semantic requirements;
but as we don't believe the concept will be useful <i>except</i> as a teaching aid, we have not
proposed it in the proposed wording below. It previously looked like this:

<small><blockquote>
<pre>
<ins>template&lt;class T></ins>
  <ins>concept relocatable = move_constructible&lt;T>;</ins>
</pre>
<p><ins>If `T` is an object type, then let `rv` be an rvalue of type `T`, `lv` an lvalue of type `T` equal to `rv`,
and `u2` a distinct complete object of type `T` equal to `rv`.
`T` models `relocatable` only if</ins>

  - <ins>After the definition `T u = rv;`, `u` is equal to `u2`.</ins>

  - <ins>`T(rv)` is equal to `u2`.</ins>

  - <ins>If the expression `u2 = rv` is well-formed, then the expression has the same semantics as
    `u2.~T(); ::new ((void*)std::addressof(u2)) T(rv);`</ins>

  - <ins>If the definition `T u = lv;` is well-formed, then after the definition `u` is equal to `u2`.</ins>

  - <ins>If the expression `T(lv)` is well-formed, then the expression's result is equal to `u2`.</ins>

  - <ins>If the expression `u2 = lv` is well-formed, then the expression has the same semantics as
    `u2.~T(); ::new ((void*)std::addressof(u2)) T(lv);`</ins>

</blockquote></small>
-->

# Scope and design # {#scope}

In this rebased proposal, we propose:

- The set of trivially relocatable types should be exactly those types which can be relocated as-if by memcpy.
    We change the definition of "trivially relocatable class" (<a href="#wording-basic.types.general">[basic.types.general]</a>)
    to include all trivially copyable types, and to exclude
    polymorphic types which require additional fixup beyond a simple memcpy.
    We need trivial relocatability to imply memcpy-ability and realloc-ability, or it is useless to us.

- Remove the possibility that `std::trivially_relocate` (<a href="#wording-obj.lifetime">[obj.lifetime]</a>) might
    do anything other than a simple memcpy of the underlying bytes.
    Otherwise we do not touch the `std::trivially_relocate` and `std::relocate` functions; we do not mind them.
    What is important is that they must be *trivial;* they must not be allowed to perform non-trivial "fixup" of the
    relocated objects (e.g. to fix up the vptrs of polymorphic objects).

- Remove the terms of art *default-movable* and *eligible for trivial relocation* (<a href="#wording-class.prop">[class.prop]</a>).

- Remove the terms *replaceable type* (<a href="#wording-basic.types.general">[basic.types.general]</a>),
    *eligible for replacement*, and *replaceable class* (<a href="#wording-class.prop">[class.prop]</a>)
    and the `std::is_replaceable` type-trait (<a href="#wording-meta.type.synop">[meta.type.synop]</a>)
    Nothing in the current working draft (nor [[P3516]]) depends on these notions.
    We believe they are likely to cause confusion to end-users, particularly in their similarity to the existing
    term of art "transparently replaceable" (<a href="https://eel.is/c++draft/basic.life#def:transparently_replaceable">[basic.life]</a>).
    We believe they [are not useful](https://stackoverflow.com/questions/79534079/what-is-the-purpose-semantics-of-p2786-is-replaceable)
    to library authors.

- Remove the `trivially_relocatable_if_eligible` and `replaceable_if_eligible` keywords (<a href="#wording-lex.name">[lex.name]</a>).
    They are ugly. They are difficult to use correctly because they are "viral"; see [[P3236]].
    They are unusable outside of C++26 mode.
    We propose to replace both contextual keywords with a single ignorable attribute, which compiler vendors can choose to support
    even in older C++ modes if they want.

- Remove the Annex C entry (<a href="#wording-diff.cpp23.dcl.dcl">[diff.cpp23.dcl.dcl]</a>) and discussion of new grammatical
    ambiguities (<a href="#wording-class.pre">[class.pre]</a>) caused by the P2786 syntax.
    These grammatical issues no longer exist.

- Do not touch the `std::is_trivially_relocatable` and `std::is_nothrow_relocatable` type-traits.

- Add the `[[trivially_relocatable]]` attribute as used by
    [std_error](https://github.com/charles-salvia/std_error/blob/25a2263152d4fe1b923c8daa568c9f61157f3939/include/compiler.hpp#L60-L64),
    [parlaylib](https://github.com/cmuparlay/parlaylib/blob/36459f42a84207330eae706c47e6fab712e6a149/include/parlay/type_traits.h#L309-L313),
    and [SG14](https://github.com/Quuxplusone/SG14/blob/ee3de047e6b54975674caf5f9d6342489b7003d9/include/sg14/inplace_vector.h#L47-L53).
    Note the lack of "if eligible" qualification: this attribute has "sharp knife" semantics suitable for
    our purposes and matching our current use-cases. (See [[P3236]].)
    Unlike the contextual keywords, this attribute can be supported in older C++ modes too.

- We do not need to propose P1144's library functionality — `std::uninitialized_relocate`, `std::relocate_at`, and so on —
    because that functionality has been submitted in a separate paper not authored by Arthur O'Dwyer
    ([[P3516]]) which LEWG has approved for C++26. We are happy with this outcome.


# Proposed wording # {#wording}

The wording in this section is relative to the current working draft.

## [cpp.predefined] ## {#wording-cpp.predefined}

Modify the feature-test macros in the table in
<a href="https://eel.is/c++draft/cpp.predefined#tab:cpp.predefined.ft">[cpp.predefined]</a>:

<small><blockquote>
<pre>
__cpp_impl_three_way_comparison   201907L
<ins>__cpp_impl_trivially_relocatable  YYYYMML</ins>
__cpp_implicit_move               202207L
</pre>
[...]
<pre>
__cpp_threadsafe_static_init      200806L
<del>__cpp_trivial_relocatability      202502L</del>
__cpp_trivial_union               202502L
</pre>
</blockquote></small>


## [version.syn] ## {#wording-version.syn}

Bump the feature-test macro in <a href="https://eel.is/c++draft/version.syn">[version.syn]/2</a>:

<small><blockquote>
<pre>
#define __cpp_lib_transparent_operators             201510L // freestanding, also in &lt;memory>, &lt;functional>
#define __cpp_lib_trivially_relocatable             <del>202502L</del> <ins>YYYYMML</ins> // freestanding, also in &lt;memory>, &lt;type_traits>
#define __cpp_lib_tuple_element_t                   201402L // freestanding, also in &lt;tuple>
</pre>
</blockquote></small>


## [basic.types.general] ## {#wording-basic.types.general}

Add a new section in <a href="http://eel.is/c++draft/basic.types.general">[basic.types.general]</a>:

<small><blockquote>
9․ Arithmetic types ([basic.fundamental]), enumeration types, pointer types, pointer-to-member types ([basic.compound]), `std::nullptr_t`, and cv-qualified versions of these types 
are collectively called <i>scalar types</i>.
Scalar types, trivially copyable class types ([class.prop]), arrays of such types, and cv-qualified versions of these types
are collectively called <i>trivially copyable types</i>.
<del>Scalar</del> <ins>Trivially copyable</ins> types, trivially relocatable class types ([class.prop]), arrays of such types, and cv-qualified versions of these types
are collectively called <i>trivially relocatable types</i>.
<del>Cv-unqualified scalar types, replaceable class types ([class.prop]), and arrays of such types
are collectively called <i>replaceable types</i>.</del>
Scalar types, standard-layout class types ([class.prop]), arrays of such types, and cv-qualified versions of these types
are collectively called <i>standard-layout types</i>.
Scalar types, implicit-lifetime class types ([class.prop]), array types, and cv-qualified versions of these types
are collectively called <i>implicit-lifetime types</i>.

<p><ins>[*Note:* For a trivially relocatable type, the object relocation operations performed by,
for example, `std::swap_ranges` or `std::vector::reserve`, are always tantamount
to simple copies of the underlying bytes. *—end note*]</ins>

10․ A type is a <i>literal type</i> if it is: [...]
</blockquote></small>


## [class.pre] ## {#wording-class.pre}

Modify <a href="http://eel.is/c++draft/class.pre">[class.pre]</a> as follows:

<small><blockquote>
<i>class-property-specifier</i>:<br>
&emsp; <code>final</code><br>
&emsp; <del><code>trivially_relocatable_if_eligible</code></del><br>
&emsp; <del><code>replaceable_if_eligible</code></del>

[...]

<p>5․ Each <i>class-property-specifier</i> shall appear at most once within a single <i>class-property-specifier-seq</i>.
Whenever a <i>class-key</i> is followed by a <i>class-head-name</i>, the identifier
`final`, <del>`trivially_relocatable_if_eligible`, or `replaceable_if_eligible`,</del> and a colon or left brace,
the identifier is interpreted as a <i>class-property-specifier</i>.

<p>[<i>Example</i>:<pre>
  struct A;
  struct A final {};      // OK, definition of struct A,
                          // not value-initialization of variable final

  <del>struct X {</del>
   <del>struct C { constexpr operator int() { return 5; } };</del>
   <del>struct B trivially_relocatable_if_eligible : C{};</del>
                          <del>// OK, definition of nested class B,</del>
                          <del>// not declaration of a bit-field member</del>
                          <del>// trivially_relocatable_if_eligible</del>
  <del>};</del>
</pre>
—<i>end example</i>]
</blockquote></small>

## [class.prop] ## {#wording-class.prop}

Modify <a href="http://eel.is/c++draft/class.prop">[class.prop]</a> as follows:

<small><blockquote>
<p>1․ A <i>trivially copyable class</i> is a class:
- that has at least one eligible copy constructor, move constructor, copy assignment operator, or move assignment operator ([special], [class.copy.ctor], [class.copy.assign]),
- where each eligible copy constructor, move constructor, copy assignment operator, and move assignment operator is trivial, and
- that has a trivial, non-deleted destructor ([class.dtor]).

<p><ins>x․ A <i>trivially relocatable class</i> is a class:</ins>
- <ins>where no eligible copy constructor, move constructor, copy assignment operator, move assignment operator, or destructor is user-provided,</ins>
- <ins>which has no virtual member functions or virtual base classes,</ins>
- <ins>all of whose non-static data members are either of reference type or of trivially relocatable type (<a href="#wording-basic.types.general">[basic.types.general]</a>), and</ins>
- <ins>all of whose base classes are of trivially relocatable type;</ins>

<ins>or a class that is declared with a `trivially_relocatable` attribute with value `true` (<a href="#wording-dcl.attr.trivreloc">[dcl.attr.trivreloc]</a>)
if that attribute is supported by the implementation (<a href="#wording-cpp.cond">[cpp.cond]</a>).</ins>

<p><del>2․ A class `C` is <i>default-movable</i> if</del>
- <del>overload resolution for direct-initializing an object of type `C` from an xvalue of type `C` selects a constructor that is a direct member of `C`
    and is neither user-provided nor deleted,</del>
- <del>overload resolution for assigning to an lvalue of type `C` from an xvalue of type `C` selects an assignment operator function that is a direct member of `C`
    and is neither user-provided nor deleted, and</del>
- <del>`C` has a destructor that is neither user-provided nor deleted.</del>

<p><del>3․ A class is <i>eligible for trivial relocation</i> unless it</del>
- <del>has any virtual base classes,</del>
- <del>has a base class that is not a trivially relocatable class,</del>
- <del>has a non-static data member of an object type that is not of a trivially relocatable type, or</del>
- <del>has a deleted destructor,</del>

<del>except that it is implementation-defined whether an otherwise-eligible union having one or more subobjects of polymorphic class type
is eligible for trivial relocation.</del>

<p><del>4․ A class `C` is a <i>trivially relocatable class</i> if it is eligible for trivial relocation and</del>
- <del>has the `trivially_relocatable_if_eligible` <i>class-property-specifier</i>,</del>
- <del>is a union with no user-declared special member functions, or</del>
- <del>is default-movable.</del>

<p><del>5․ [<i>Note:</i> A class with const-qualified or reference non-static data members can be trivially relocatable. —<i>end note</i>]</del>

<p><del>6․ A class `C` is <i>eligible for replacement</i> unless</del>
- <del>it has a base class that is not a replaceable class,</del>
- <del>it has a non-static data member that is not of a replaceable type,</del>
- <del>overload resolution fails or selects a deleted constructor
    when direct-initializing an object of type `C` from an xvalue of type `C` ([dcl.init.general]),</del>
- <del>overload resolution fails or selects a deleted assignment operator function 
    when assigning to an lvalue of type `C` from an xvalue of type `C` ([expr.assign], [over.assign])), or</del>
- <del>it has a deleted destructor.</del>

<p><del>7․ A class `C` is a <i>replaceable class</i> if it is eligible for replacement and</del>
- <del>has the `replaceable_if_eligible` <i>class-property-specifier</i>,</del>
- <del>is a union with no user-declared special member functions, or</del>
- <del>is default-movable.</del>

<p><del>8․ [<i>Note:</i> Accessibility of the special member functions is not considered when establishing trivial relocatability or replaceability. —<i>end note</i>]</del>

<p><del>9․ [<i>Note:</i> Not all trivially copyable classes are trivially relocatable or replaceable. —<i>end note</i>]</del>

<p>10․ A class `S` is a <i>standard-layout class</i> if it: [...]
</blockquote></small>


## [cpp.cond] ## {#wording-cpp.cond}

Add a new entry to the table of supported attributes in
<a href="https://eel.is/c++draft/cpp.cond">[cpp.cond]</a>:

<small><blockquote>
<pre>
noreturn              200809L
<ins>trivially_relocatable YYYYMML</ins>
unlikely              201803L
</pre>
</blockquote></small>


## [dcl.attr.trivreloc] ## {#wording-dcl.attr.trivreloc}

Add a new section after <a href="http://eel.is/c++draft/dcl.attr.nouniqueaddr">[dcl.attr.nouniqueaddr]</a>:

<small><blockquote>
<ins>1․ The *attribute-token* `trivially_relocatable` specifies that a class type's relocation operation has no
visible side-effects other than a copy of the underlying bytes, as if by the library function `std::memcpy`.
It may be applied to the definition of a class. It shall appear at most once in each *attribute-list*.
An *attribute-argument-clause* may be present and, if present, shall have the form</ins>
<pre>
    <ins>( <i>constant-expression</i> )</ins>
</pre>
<ins>The *constant-expression* shall be an integral constant expression of type `bool`.
If no *attribute-argument-clause* is present, it has the same effect as an *attribute-argument-clause*
of `(true)`.</ins>

<p><ins>2․ If any definition of a class type has a `trivially_relocatable` attribute with value *V*, then each
definition of the same class type shall have a `trivially_relocatable` attribute with value *V*.
No diagnostic is required if definitions in different translation units have
mismatched `trivially_relocatable` attributes.</ins>

<p><ins>3․ If a class type is declared with the `trivially_relocatable` attribute, and the program relies on
observable side-effects of its relocation other than a copy of the underlying bytes, the behavior is undefined.</ins>

<p><ins>4․ *Recommended practice:* The value of a <i>has-attribute-expression</i> for
the `trivially_relocatable` attribute should be `0` for a given implementation unless this attribute
can cause a class type to be trivially relocatable (<a href="#wording-class.prop">[class.prop]</a>).</ins>
</blockquote></small>


## [expr.prim.lambda.closure] ## {#wording-expr.prim.lambda.closure}

Modify <a href="http://eel.is/c++draft/expr.prim.lambda.closure">[expr.prim.lambda.closure]</a> as follows:

<small><blockquote>
<p>3. The closure type is not an aggregate type ([dcl.init.aggr]);
it is a structural type ([temp.param]) if and only if the lambda has no <i>lambda-capture</i>.
An implementation may define the closure type differently from what is described below provided this does not alter
the observable behavior of the program other than by changing:
- the size and/or alignment of the closure type,
- whether the closure type is trivially copyable ([class.prop]),
- whether the closure type is trivially relocatable ([class.prop]),
- <del>whether the closure type is replaceable ([class.prop]),</del> or
- whether the closure type is a standard-layout class ([class.prop]).

An implementation shall not add members of rvalue reference type to the closure type.
</blockquote></small>


## [lex.name] ## {#wording-lex.name}

Modify <a href="http://eel.is/c++draft/lex.name">[lex.name]</a> as follows:

<small><blockquote>
<p>2. The identifiers in Table 4 have a special meaning when appearing in a certain context.
When referred to in the grammar, these identifiers are used explicitly rather than using the
<i>identifier</i> grammar production. Unless otherwise specified, any ambiguity as to whether
a given <i>identifier</i> has a special meaning is resolved to interpret the token as a
regular <i>identifier</i>.

<p>Table 4 — Identifiers with special meaning
<pre>
  final     import  post  <del>replaceable_if_eligible</del>
  override  module  pre   <del>trivially_relocatable_if_eligible</del>
</pre>
</blockquote></small>


## [library.class.props] ## {#wording-library.class.props}

Modify <a href="https://eel.is/c++draft/library.class.props">[library.class.props]</a> as follows:

<small><blockquote>
<p>1. Unless explicitly stated otherwise, it is unspecified whether any class described in [support] through [exec] and [depr]
is a trivially copyable class, <ins>a trivially relocatable class,</ins> a standard-layout class, or an implicit-lifetime class ([class.prop]).
<p><del>2. Unless explicitly stated otherwise, it is unspecified whether any class for which trivial relocation
(i.e., the effects of `trivially_relocate` ([obj.lifetime])) would be semantically equivalent to move-construction
of the destination object followed by destruction of the source object is a trivially relocatable class ([class.prop]).</del>
<p><del>3. Unless explicitly stated otherwise, it is unspecified whether a class `C` is a replaceable class ([class.prop])
if assigning an xvalue `a` of type `C` to an object `b` of type `C` is semantically equivalent to destroying `b` and then
constructing from `a` in <code>b</code>'s place.</del>
</blockquote></small>


## [meta.type.synop] ## {#wording-meta.type.synop}

Modify <a href="http://eel.is/c++draft/meta.type.synop">[meta.type.synop]</a> as follows:

<small><blockquote>
<pre>
  [...]
  <i>// <a href="#wording-meta.unary.prop">[meta.unary.prop]</a>, type properties</i>
  template&lt;class T> struct is_const;
  template&lt;class T> struct is_volatile;
  template&lt;class T> struct is_trivially_copyable;
  template&lt;class T> struct is_trivially_relocatable;
  <del>template&lt;class T> struct is_replaceable;</del>
  template&lt;class T> struct is_standard_layout;
  [...]
  template&lt;class T>
    constexpr bool is_implicit_lifetime_v = is_implicit_lifetime&lt;T>::value;
  <del>template&lt;class T></del>
    <del>constexpr bool is_replaceable_v = is_replaceable&lt;T>::value;</del>
  template&lt;class T>
    constexpr bool has_virtual_destructor_v = has_virtual_destructor&lt;T>::value;
</pre>
</blockquote></small>

## [meta.unary.prop] ## {#wording-meta.unary.prop}

Modify Table 54 in <a href="http://eel.is/c++draft/meta.unary.prop">[meta.unary.prop]</a> as follows:

<small><blockquote>
<table>
<tr><th>Template</th><th>Condition</th><th>Preconditions</th></tr>
<tr>
<td>`template<class T> struct is_trivially_copyable;`</td>
<td>`T` is a trivially copyable type ([basic.types.general])</td>
<td>`remove_all_extents_t<T>` shall be a complete type or <i>cv</i> `void`.</td>
</tr>
<tr>
<td>`template<class T> struct is_trivially_relocatable;`</td>
<td>`T` is a trivially relocatable type (<a href="#wording-basic.types.general">[basic.types.general]</a>)</td>
<td>`remove_all_extents_t<T>` shall be a complete type or <i>cv</i> `void`.</td>
</tr>
<tr>
<td><del>`template<class T> struct is_replaceable;`</del></td>
<td><del>`T` is a replaceable type (<a href="#wording-basic.types.general">[basic.types.general]</a>)</del></td>
<td><del>`remove_all_extents_t<T>` shall be a complete type or <i>cv</i> `void`.</del></td>
</tr>
<tr>
<td>`template<class T> struct is_standard_layout;`</td>
<td>`T` is a standard-layout type ([basic.types.general])</td>
<td>`remove_all_extents_t<T>` shall be a complete type or <i>cv</i> `void`.</td>
</tr>
</table>
</blockquote></small>


## [obj.lifetime] ## {#wording-obj.lifetime}

Modify <a href="http://eel.is/c++draft/obj.lifetime">[obj.lifetime]</a> as follows:

<small><blockquote>
<pre>
  template&lt;class T>
    T* trivially_relocate(T* first, T* last, T* result);
</pre>

<p>9. *Mandates:* `is_trivially_relocatable_v<T> && !is_const_v<T>` is `true`. `T` is not an array of unknown bound.

<p>10. *Preconditions:*
- [`first`, `last`) is a valid range.
- [`result`, `result + (last - first)`) denotes a region of storage that is a subset of the region reachable through `result` ([basic.compound])
    and suitably aligned for the type `T`.
- No element in the range [`first`, `last`) is a potentially-overlapping subobject.

<p>11. *Postconditions:* No effect if `result == first` is `true`.
    Otherwise, the range denoted by [`result`, `result + (last - first)`) contains objects (including subobjects)
    whose lifetime has begun and whose object representations are the original object representations of the corresponding objects
    in the source range [`first`, `last`) <del>except for any parts of the object representations used by the implementation
    to represent type information ([intro.object])</del>. If any of the objects has union type, its active member is the same
    as that of the corresponding object in the source range. If any of the aforementioned objects has a non-static data member
    of reference type, that reference refers to the same entity as does the corresponding reference in the source range.
    The lifetimes of the original objects in the source range have ended.

<p>12. *Returns:* `result + (last - first)`.

<p>13. *Throws:* Nothing.

<p>14. *Complexity:* Linear in the length of the source range.

<p>15. *Remarks:* The destination region of storage is considered reused ([basic.life]). No constructors or destructors are invoked.

<p>[<i>Note:</i> Overlapping ranges are supported. —<i>end note</i>]

<!--
<p><pre>
  template&lt;class T>
    constexpr T* relocate(T* first, T* last, T* result);
</pre>

<p>16. *Mandates:* `is_nothrow_relocatable_v<T> && !is_const_v<T>` is `true`. `T` is not an array of unknown bound.

<p>17. *Preconditions:*
- [`first`, `last`) is a valid range.
- [`result`, `result + (last - first)`) denotes a region of storage that is a subset of the region reachable through result ([basic.compound])
    and suitably aligned for the type `T`.
- No element in the range [`first`, `last`) is a potentially-overlapping subobject.

<p>18. *Effects:*
- If `result == first` is `true`, no effect;
- otherwise, if not called during constant evaluation and `is_trivially_relocatable_v<T>` is `true`, then has effects equivalent to:
     `trivially_relocate(first, last, result);`
- otherwise, for each integer `i` in [`0`, `last - first`),
    - if `T` is an array type, equivalent to: `relocate(begin(first[i]), end(first[i]), *start_lifetime_as<T>(result + i));`
    - otherwise, equivalent to: `construct_at(result + i, std::move(first[i])); destroy_at(first + i);`

<p>19. *Returns:* `result + (last - first)`.

<p>20. *Throws:* Nothing.

<p>[<i>Note</i>: Overlapping ranges are supported. —<i>end note</i>]
-->
</blockquote></small>

## [diff.cpp23.dcl.dcl] ## {#wording-diff.cpp23.dcl.dcl}

Modify <a href="http://eel.is/c++draft/diff.cpp23.dcl.dcl">[diff.cpp23.dcl.dcl]</a> as follows:

<small><blockquote>
<p><del>1. Affected subclause: [dcl.decl.general]</del><br>
<del>Change: Introduction of `trivially_relocatable_if_eligible` and `replaceable_if_eligible` as identifiers with special meaning ([lex.name]).</del><br>
<del>Rationale: Support declaration of trivially relocatable and replaceable types ([class.prop]).</del><br>
<del>Effect on original feature: Valid C++ 2023 code can become ill-formed.</del><br>

<p><del>[<i>Example</i>:</del>
<pre>
  <del>struct C {};</del>
  <del>struct C replaceable_if_eligible {};    // was well-formed (new variable replaceable_if_eligible)</del>
                                          <del>// now ill-formed (redefines C)</del>
</pre>
<del>—<i>end example</i>]</del>
</blockquote></small>


<pre class=biblio>
{
  "Abseil": {
    "authors": [
      "Aaron Jacobs",
      "et al."
    ],
    "title": "Abseil C++ Common Libraries",
    "href": "https://github.com/abseil/abseil-cpp",
    "date": "March 2023"
  },
  "Amadeus": {
    "authors": [
      "Stephane Janel"
    ],
    "title": "AMadeus (C++) Containers",
    "href": "https://github.com/AmadeusITGroup/amc",
    "date": "April 2021"
  },
  "Announcing": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Announcing \"trivially relocatable\"",
    "href": "https://quuxplusone.github.io/blog/2018/07/18/announcing-trivially-relocatable/",
    "date": "July 2018"
  },
  "Bench": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Benchmark code from \"The Best Type Traits C++ Doesn't Have\"",
    "href": "https://github.com/Quuxplusone/from-scratch/blob/095b246d/cppnow2018/benchmark-relocatable.cc",
    "date": "April 2018"
  },
  "Boost.Interprocess": {
    "authors": [
      "Ion Gaztañaga"
    ],
    "title": "Mapping Address Independent Pointer: offset_ptr",
    "href": "https://www.boost.org/doc/libs/1_67_0/doc/html/interprocess/offset_ptr.html",
    "date": "2005"
  },
  "BSL": {
    "authors": [
      "Bloomberg"
    ],
    "title": "bslmf::IsBitwiseMoveable: bitwise moveable trait metafunction",
    "href": "https://github.com/bloomberg/bde/blob/962f7aa/groups/bsl/bslmf/bslmf_isbitwisemoveable.h#L8-L48",
    "date": "2013–2022"
  },
  "CppChat": {
    "authors": [
      "Howard Hinnant",
      "Arthur O'Dwyer"
    ],
    "title": "cpp.chat episode 40: It works but it's undefined behavior",
    "href": "https://www.youtube.com/watch?v=8u5Qi4FgTP8",
    "date": "August 2018"
  },
  "CppNow": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Trivially Relocatable (C++Now 2019)",
    "href": "https://www.youtube.com/watch?v=SGdfPextuAU",
    "date": "May 2019"
  },
  "D50119": {
    "authors": [
      "Arthur O'Dwyer",
      "Nicolas Lesser",
      "John McCall"
    ],
    "title": "Compiler support for P1144R0 __is_trivially_relocatable(T)",
    "href": "https://reviews.llvm.org/D50119",
    "date": "July 2018"
  },
  "D114732": {
    "authors": [
      "Devin Jeanpierre"
    ],
    "title": "[clang] Mark trivial_abi types as trivially relocatable",
    "href": "https://reviews.llvm.org/D114732",
    "date": "November 2021"
  },
  "Deque": {
    "authors": [
      "Marc Glisse"
    ],
    "title": "Improve relocation ... (__is_trivially_relocatable): Specialize for deque",
    "href": "https://github.com/gcc-mirror/gcc/commit/a9b9381580de611126c9888c1a6c12a77d9b682e",
    "date": "November 2018"
  },
  "FixedCapacityVector": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "P1144 case study: Moving a `fixed_capacity_vector`",
    "href": "https://quuxplusone.github.io/blog/2019/02/22/p1144-fixed-capacity-vector/"
  },
  "Folly": {
    "authors": [
      "Facebook"
    ],
    "title": "Folly documentation on \"Object Relocation\"",
    "href": "https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md#object-relocation"
  },
  "HPX": {
    "authors": [
      "Isidoros Tsaousis-Seiras"
    ],
    "title": "Relocation Semantics in the HPX Library",
    "href": "https://isidorostsa.github.io/gsoc2023/",
    "date": "August 2023"
  },
  "InPractice": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "What library types are trivially relocatable in practice?",
    "href": "https://quuxplusone.github.io/blog/2019/02/20/p1144-what-types-are-relocatable/",
    "date": "February 2019"
  },
  "LWG2153": {
    "authors": [
      "Robert Shearer"
    ],
    "title": "Narrowing of the non-member swap contract",
    "href": "https://cplusplus.github.io/LWG/issue2153",
    "date": "April 2012–October 2020"
  },
  "N1377": {
    "authors": [
      "Howard Hinnant",
      "Peter Dimov",
      "Dave Abrahams"
    ],
    "title": "N1377: A Proposal to Add Move Semantics Support to the C++ Language",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm",
    "date": "September 2002"
  },
  "N2754": {
    "authors": [
      "Rodrigo Castro Campos"
    ],
    "title": "N2754: TriviallyDestructibleAfterMove and TriviallyReallocatable (rev 3)",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2754.html",
    "date": "September 2008"
  },
  "N4158": {
    "authors": [
      "Pablo Halpern"
    ],
    "title": "N4158: Destructive Move (rev 1)",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf",
    "date": "October 2014"
  },
  "P0023R0": {
    "authors": [
      "Denis Bider"
    ],
    "title": "P0023R0: Relocator: Efficiently Moving Objects",
    "href": "http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0023r0.pdf",
    "date": "April 2016"
  },
  "P0178R0": {
    "authors": [
      "Alisdair Meredith"
    ],
    "title": "Allocators and swap",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0178r0.html",
    "date": "February 2016"
  },
  "P0843R5": {
    "authors": [
      "Gonzalo Brito Gadeschi"
    ],
    "title": "static_vector",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0843r5.html",
    "date": "July 2022"
  },
  "P1029R3": {
    "authors": [
      "Niall Douglas"
    ],
    "title": "P1029R3: move = bitcopies",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1029r3.pdf",
    "date": "January 2020"
  },
  "P1144R6": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Object relocation in terms of move plus destroy",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1144r6.html",
    "date": "June 2022"
  },
  "P1144R10": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "std::is_trivially_relocatable",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1144r10.html",
    "date": "February 2024"
  },
  "P2814R1": {
    "authors": [
      "Mungo Gill",
      "Alisdair Meredith"
    ],
    "title": "Trivial relocatability — comparing P2786 with P1144",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2814r1.pdf",
    "date": "May 2023"
  },
  "P2785R3": {
    "authors": [
      "Sébastien Bini",
      "Ed Catmur"
    ],
    "title": "Relocating prvalues",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r3.html",
    "date": "June 2023"
  },
  "P2786": {
    "authors": [
      "Alisdair Meredith; Mungo Gill; Joshua Berne; Corentin Jabot; Pablo Halpern; Lori Hughes"
    ],
    "title": "Trivial Relocatability For C++26",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2786r13.html",
    "date": "February 2025"
  },
  "P2959": {
    "authors": [
      "Alisdair Meredith"
    ],
    "title": "Relocation within containers",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2959r0.html",
    "date": "October 2023"
  },
  "P2967": {
    "authors": [
      "Alisdair Meredith",
      "Mungo Gill"
    ],
    "title": "Relocation has a library interface",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2967r1.pdf",
    "date": "May 2024"
  },
  "P3239": {
    "authors": [
      "Alisdair Meredith"
    ],
    "title": "A relocating swap",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3239r0.pdf",
    "date": "May 2024"
  },
  "D3262": {
    "authors": [
      "Alisdair Meredith"
    ],
    "title": "Specifying Trivially Relocatable Types in the Standard Library",
    "href": "https://isocpp.org/files/papers/D3262R0.pdf",
    "date": "unreleased (May 2024)"
  },
  "P3055R1": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Relax wording to permit relocation optimizations in the STL",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3055r1.html",
    "date": "February 2024"
  },
  "P3233": {
    "authors": [
      "Giuseppe D'Angelo"
    ],
    "title": "Issues with P2786 ('Trivial Relocatability For C++26')",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3233r0.html",
    "date": "April 2024"
  },
  "P3236": {
    "authors": [
      "Alan de Freitas; Daniel Liam Anderson; Giuseppe D'Angelo; Hans Goudey; Jacques Lucke; Krystian Stasiowski; Stéphane Janel; Thiago Maciera"
    ],
    "title": "Please reject P2786 and adopt P1144",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3236r1.html",
    "date": "May 2024"
  },
  "P3279": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "CWG2463: What 'trivially fooable' should mean",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3279r0.html",
    "date": "May 2024"
  },
  "P3516": {
    "authors": [
      "Louis Dionne",
      "Giuseppe D'Angelo"
    ],
    "title": "Uninitialized algorithms for relocation",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3516r1.html",
    "date": "February 2025"
  },
  "ParlayLib": {
    "authors": [
      "Daniel Anderson",
      "Guy Blelloch"
    ],
    "title": "ParlayLib, a toolkit for programming parallel algorithms on shared-memory multicore machines",
    "href": "https://github.com/cmuparlay/parlaylib/blob/36459f4/include/parlay/relocation.h",
    "date": "February 2024"
  },
  "PocketPy": {
    "authors": [
      "blueloveTH",
      "ykiko"
    ],
    "title": "pocketpy: single-file Python interpreter",
    "href": "https://github.com/pocketpy/pocketpy/blob/2929add/include/pocketpy/vector.h",
    "date": "February 2024"
  },
  "Polymorphic": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Polymorphic types aren't trivially relocatable",
    "href": "https://quuxplusone.github.io/blog/2023/06/24/polymorphic-types-arent-trivially-relocatable/",
    "date": "June 2023"
  },
  "Qt": {
    "title": "Qt Base",
    "href": "https://github.com/qt/qtbase/",
    "date": "February 2023"
  },
  "StdRelocateIsCute": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "std::relocate's implementation is cute",
    "href": "https://quuxplusone.github.io/blog/2022/05/18/std-relocate/",
    "date": "May 2022"
  },
  "StdxError": {
    "authors": [
      "Charles Salvia"
    ],
    "title": "Implementation of std::error as proposed by Herb Sutter in P0709R0",
    "href": "https://github.com/charles-salvia/std_error/",
    "date": "October 2023"
  },
  "Subspace": {
    "authors": [
      "Dana Jansens"
    ],
    "title": "Trivially Relocatable Types in C++/Subspace",
    "href": "https://danakj.github.io/2023/01/15/trivially-relocatable.html",
    "date": "January 2023"
  },
  "Thrust": {
    "authors": [
      "Bryce Adelstein Lelbach",
      "Michał Dominiak"
    ],
    "title": "Nvidia Thrust",
    "href": "https://github.com/NVIDIA/cccl/blob/main/thrust/thrust/type_traits/is_trivially_relocatable.h",
    "date": "December 2018"
  }
}
</pre>
