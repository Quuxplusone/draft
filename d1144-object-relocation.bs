<pre class='metadata'>
Title: std::is_trivially_relocatable
Shortname: D1144
Revision: 13
!Draft Revision: 77
Audience: WG21
Status: D
Group: WG21
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Editor: Artur Bać, artur@ebasoft.com.pl
Editor: Daniel Liam Anderson, dlanders@andrew.cmu.edu
Editor: Enrico Mauro, kaffedesk@gmail.com
Editor: Jody Hagins, coachhagins@gmail.com
Editor: Michael Steffens, michael_steffens@posteo.de
Editor: Stéphane Janel, stephane.janel@gmail.com
Editor: Vinnie Falco, vinnie.falco@gmail.com
Editor: Will Wray, wjwray@gmail.com
Editor: Walter E. Brown, webrown.cpp@gmail.com
URL:
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  P1144-style trivial relocation is used by Abseil, AMC, BSL, Folly, HPX, Parlay, Pocketpy, Qt, Subspace, and Thrust.
  Let's make it part of the C++ standard.
Date: 2025-05-13
</pre>

<style>
body {-moz-hyphens: none; -ms-hyphens: none; -webkit-hyphens: none; hyphens: none;}
ins  {color: light-dark(black, #DDDDDD); background-color: light-dark(#CCFFCC, #005500); text-decoration: underline;}
del  {color: light-dark(black, #FFCACA); background-color: light-dark(#FFCACA, #440000); text-decoration: line-through;}
good  {color: light-dark(black, #DDDDDD); background-color: light-dark(#CCFFCC, #005500); text-decoration: underline;}
bad  {color: light-dark(black, #FFCACA); background-color: light-dark(#FFCACA, #550000); text-decoration: underline;}
</style>

# What's going on here? # {#intro}

Some of us submitted [[P3236]] for St Louis 2024, indicating our disapproval of [[P2786R4]]
and asking for our preferred direction [[P1144R10]] to be discussed in committee. This resulted
in EWG's "clawing back" P2786 for one meeting, but did not result in any committee discussion
of P1144, due to its author.

[[P2786R13]] was then merged into the Working Draft ([[N5008]]) at Hagenberg 2024.
Almost all of P3236's objections remain unaddressed. Here are P3236's objections again:

- "Types with user-provided `operator=` are reported as trivially relocatable by default."
    &nbsp; <good>Addressed.</good>

- "The programmer is allowed to create a type that is trivially copyable but not trivially relocatable."
    &nbsp; <bad>Not addressed.</bad>

- "It's ill-formed to create a trivially relocatable type with an `offset_ptr` member,
    or even a Boost `static_vector` member."
    &nbsp; <bad>Not addressed.</bad>

- "No backward-compatible syntax. P2786 proposes a new keyword, and goes out of its way to make the keyword unusable in C++23-and-earlier."
    &nbsp; <bad>Not addressed.</bad>

- "P1144, by providing stronger guarantees of value semantics, permits more optimizations."
    &nbsp; <bad>Not addressed.</bad>

- "P1144 provides a well-designed and stable library API."
    &nbsp; <good>Addressed,</good> in that the P1144 library API has been approved for C++26 via [[P3516]].

- "P2786's warrant marking is ‘viral downward.’ As container authors, we think P2786's normalization
    of a large number of explicit markings will cause programmer fatigue and lead to bugs."
    &nbsp; <bad>Not addressed.</bad>

- "Deliberately incomplete. P2786's authors have drafted followup papers including
    [[P2959]] and [[P2967]], all with incomplete wording and ‘heroic’ changes,
    for example `std::container_replace_with_assignment`."
    &nbsp; Arguably addressed, in that P2786 was merged in its present state, and P2959 and P2967
    seem to have been abandoned. We now know with certainty what we have gotten,
    and we can say with certainty that it does not suit us.

In addition, the Working Draft version of P2786R13 contains several problems that weren't present in P2786R4 at the time we wrote [[P3236]].

- The ARM64e platform uses "vptr signing." Its vptrs are never safe to memcpy. Yet the Working Draft
    permits `is_trivially_relocatable` to return `true` for types with vptrs, types recursively
    containing members with vptrs, etc. This means that it is never safe to use e.g. `realloc`
    on ARM64e even when we know that the objects being reallocated are all `is_trivially_relocatable`.
    &nbsp; <bad>New problem, not addressed.</bad>

- P2786's approved syntax is shockingly ugly: `class C trivially_relocatable_if_eligible replaceable_if_eligible { }`.
    P1144's attribute syntax is unobtrusive by comparison: `class [[trivially_relocatable]] C { }`.
    &nbsp; <bad>New problem, not addressed.</bad>

Therefore we submit this revision of P1144, which addresses all of these problems directly,
as a diff against the current Working Draft. We gladly list ourselves as coauthors of this proposal,
in the same way that five Bloomberg employees listed themselves as coauthors of [[P2786R13]].
Unlike them, we come from a variety of backgrounds and maintain a variety of codebases.

We beg WG21 to resolve the community's concerns before it is too late.


## Statement from Stéphane Janel ## {#input-sjanel}

Stéphane Janel is the maintainer of [AmadeusITGroup/amc](https://github.com/AmadeusITGroup/amc/), a collection
of high-performance C++ containers used in the Amadeus pricing and shopping engines.

> Hello Arthur,
>
> As already discussed together, I am hugely in favor of P1144 against P2786.
>
> The reasons are perfectly described [here](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3233r0.html)
> and for me the main point is that P1144 better integrates with current type traits,
> and is much more natural to use. I don't know how to target WG21 though, feel free to forward my email if it can help.


## Statement from Vinnie Falco ## {#input-vfalco}

Vinnie Falco is the maintainer of [Boost.JSON](https://github.com/boostorg/json/), a portable C++ library of
containers and algorithms that implement the JSON lightweight data-interchange format.

> Boost.JSON makes intense use of trivial relocation for its variant-like container,
> [`boost::json::value`](https://github.com/boostorg/json/blob/0b1048adf7571b42ae9f684b63e4383241b9e4a1/include/boost/json/value.hpp#L55),
> which can hold any kind of JSON node including arrays, objects, and strings.
>
> This means when resizing an array of values (represented by the type `boost::json::array`)
> or an unordered container of values (represented by the type `boost::json::object`),
> the implementation can [simply `relocate`](https://github.com/boostorg/json/blob/0b1048adf7571b42ae9f684b63e4383241b9e4a1/include/boost/json/impl/array.ipp#L692)
> the contents of the container. The implementation of `relocate()` for an array of `value` is
> [simply `memcpy`](https://github.com/boostorg/json/blob/0b1048adf7571b42ae9f684b63e4383241b9e4a1/include/boost/json/value.hpp#L4152).
>
> Since Boost.JSON requires only C++11 we have to make some assumptions which are in principle not portable,
> yet in practice work everywhere (we have not gotten any reports of malfunctions).
> To keep the library's data types clean and first-class, we adopted Peter Dimov's "pilfer construction" approach
> from [P0308R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0308r0.html),
> which is related to trivial relocation.
>
> I'm happy to answer questions about the library if it can help the committee make better design choices,
> although it seems like decisions have already been made. Unfortunately I do not have the motivation
> to get more involved as there is little indication that quality of outcome is proportional to the level of effort invested.


## Statement from Michael Steffens ## {#input-msteffens}

Dr. Michael Steffens is the author of [misteffens/TrivialityInversion](https://gitlab.com/misteffens/TrivialityInversion/-/tree/main),
a public proof-of-concept for storage-location-agnostic C++ container types. His `BoundedVector` type includes an
`offset_ptr`-into-self as a data member, making `BoundedVector` trivially relocatable (for most types)
even though one of its data members is not.

> It seems that you are raising a lot of concerns with P2786 — on
> different abstraction levels — but the key concern in my context
> seems to be the lack of opt-in trivial relocatability.
> I have read arguments in favor of that opt-out-only, claiming
> that it's safer not to allow opt-in, overriding what the compiler could
> deduce on its own, as that could be done in error. And it's not seen as
> a functional gap, but only a missed opportunity for optimization.
>
> In my particular case (as in `boost::interprocess`) the motivation is not
> optimization, but storing objects in shared memory and coping with their
> different address offsets in different processes. As C++ standards do
> not cover IPC at all yet, we map the use of SHM to trivial
> copying or relocation, as if objects would end their life in one process
> and be memmoved to the other process (and back, as needed), being aware
> that the memmove never actually happens. Instead it's kind of an excuse
> to start/end object lifetimes on the other side without construction or
> destruction. This use case cannot be covered at all without the opt-in.
>
> If I understood everything right until this point, sure, I'd like to
> lend a hand on the P1144 side, based on the need to have a workaround
> for IPC.


## Statement from Arthur O'Dwyer ## {#input-aodwyer}

Arthur O'Dwyer is the maintainer of [Quuxplusone/SG14](https://github.com/Quuxplusone/SG14),
a library of containers and algorithms pioneered by the low-latency study group.
He also maintains a non-public `Vector` implementation and a public P1144+P3516-compliant
[fork of libc++](https://github.com/Quuxplusone/llvm-project/tree/trivially-relocatable).
He was previously the sole credited author of P1144 up to R12.

> I want to be clear: I did not *invent* trivial relocation in my P1144R0. That paper was based
> on implementations already in the wild in 2018: notably BSL, Qt, and Folly.
> Since then, more than a dozen other libraries have adopted the same semantics and most (including Qt)
> have adopted the terminology from P1144 and P3516.
> At least five library authors have written blogs or documentation about their use of "trivial relocation":
> [Folly](https://github.com/facebook/folly/blob/main/folly/docs/FBVector.md#object-relocation),
> [AMC](https://github.com/AmadeusITGroup/amc/?tab=readme-ov-file#what-is-a-trivially-relocatable-type),
> [Qt](https://www.kdab.com/qt-and-trivial-relocation-part-5/),
> [Subspace](https://orodu.net/2023/01/15/trivially-relocatable.html),
> [HPX](https://isidorostsa.github.io/gsoc2023/). Without exception,
> the people using it and writing about it follow the same path:
> the semantics recorded in (not originated by!) P1144 and P3516.
>
> Standardizing the prevailing term of art, as documented in the five links above, would be great.
> WG21's repurposing the prevailing term for a different meaning will lead only to confusion and safety bugs.


# Scope and design # {#scope}

In this rebased proposal, we propose:

- The set of trivially relocatable types should be exactly those types which can be relocated as-if by memcpy.
    We change the definition of "trivially relocatable class" (<a href="#wording-basic.types.general">[basic.types.general]</a>)
    to include all trivially copyable types, and to exclude
    polymorphic types which require additional fixup beyond a simple memcpy.
    We need trivial relocatability to imply memcpy-ability and realloc-ability, or it is useless to us.

- Remove the possibility that `std::trivially_relocate` (<a href="#wording-obj.lifetime">[obj.lifetime]</a>) might
    do anything other than a simple memcpy of the underlying bytes.
    Otherwise we preserve the `std::trivially_relocate` and `std::relocate` functions; we do not mind them.
    What is important is that they must be *trivial;* they must not be allowed to perform non-trivial "fixup" of the
    relocated objects (e.g. to fix up the vptrs of polymorphic objects).

- Remove the terms *default-movable* and *eligible for trivial relocation* (<a href="#wording-class.prop">[class.prop]</a>).
    They are no longer needed.

- Remove the terms *replaceable type* (<a href="#wording-basic.types.general">[basic.types.general]</a>),
    *eligible for replacement*, and *replaceable class* (<a href="#wording-class.prop">[class.prop]</a>)
    and the `std::is_replaceable` type-trait (<a href="#wording-meta.type.synop">[meta.type.synop]</a>)
    Nothing in [[N5008]] (nor [[P3516]]) depends on these notions.
    They are likely to cause confusion to end-users, particularly in their similarity to the existing
    term of art "transparently replaceable" (<a href="https://eel.is/c++draft/basic.life#def:transparently_replaceable">[basic.life]</a>).
    We believe they [are not useful](https://stackoverflow.com/questions/79534079/what-is-the-purpose-semantics-of-p2786-is-replaceable)
    to library authors.

- Remove the `trivially_relocatable_if_eligible` and `replaceable_if_eligible` keywords (<a href="#wording-lex.name">[lex.name]</a>).
    They are ugly. They are difficult to use correctly because they are "viral"; see [[P3236]].
    They are unusable outside of C++26 mode.
    We propose to replace both contextual keywords with a single ignorable attribute, which compiler vendors can choose to support
    even in older C++ modes if they want.

- Remove the Annex C entry (<a href="#wording-diff.cpp23.dcl.dcl">[diff.cpp23.dcl.dcl]</a>) and discussion of new grammatical
    ambiguities (<a href="#wording-class.pre">[class.pre]</a>) caused by the P2786 syntax.
    These grammatical issues no longer exist.

- Preserve the `std::is_trivially_relocatable` and `std::is_nothrow_relocatable` type-traits.

- Add the `[[trivially_relocatable]]` attribute as used by
    [std_error](https://github.com/charles-salvia/std_error/blob/25a2263152d4fe1b923c8daa568c9f61157f3939/include/compiler.hpp#L60-L64),
    [parlaylib](https://github.com/cmuparlay/parlaylib/blob/36459f42a84207330eae706c47e6fab712e6a149/include/parlay/type_traits.h#L309-L313),
    and [SG14](https://github.com/Quuxplusone/SG14/blob/ee3de047e6b54975674caf5f9d6342489b7003d9/include/sg14/inplace_vector.h#L47-L53).
    Note the lack of "if eligible" qualification: this attribute has "sharp knife" semantics suitable for
    our purposes and matching our current use-cases. (See [[P3236]].)
    Unlike the contextual keywords, this attribute can be supported in older C++ modes too.

- We do not need to propose P1144's library functionality — `std::uninitialized_relocate`, `std::relocate_at`, and so on —
    because that functionality has been submitted in a separate paper not authored by Arthur O'Dwyer
    ([[P3516]]) which LEWG has approved for C++26. We are happy with this outcome.


# Proposed wording # {#wording}

The wording in this section is relative to the current Working Draft, [[N5008]].

## [cpp.predefined] ## {#wording-cpp.predefined}

Modify the feature-test macros in the table in
<a href="https://eel.is/c++draft/cpp.predefined#tab:cpp.predefined.ft">[cpp.predefined]</a>:

<small><blockquote>
<pre>
__cpp_impl_three_way_comparison   201907L
<ins>__cpp_impl_trivially_relocatable  YYYYMML</ins>
__cpp_implicit_move               202207L
</pre>
[...]
<pre>
__cpp_threadsafe_static_init      200806L
<del>__cpp_trivial_relocatability      202502L</del>
__cpp_trivial_union               202502L
</pre>
</blockquote></small>


## [version.syn] ## {#wording-version.syn}

Bump the feature-test macro in <a href="https://eel.is/c++draft/version.syn">[version.syn]/2</a>:

<small><blockquote>
<pre>
#define __cpp_lib_transparent_operators             201510L // freestanding, also in &lt;memory>, &lt;functional>
#define __cpp_lib_trivially_relocatable             <del>202502L</del> <ins>YYYYMML</ins> // freestanding, also in &lt;memory>, &lt;type_traits>
#define __cpp_lib_tuple_element_t                   201402L // freestanding, also in &lt;tuple>
</pre>
</blockquote></small>


## [basic.types.general] ## {#wording-basic.types.general}

Add a new section in <a href="http://eel.is/c++draft/basic.types.general">[basic.types.general]</a>:

<small><blockquote>
9․ Arithmetic types ([basic.fundamental]), enumeration types, pointer types, pointer-to-member types ([basic.compound]), `std::nullptr_t`, and cv-qualified versions of these types 
are collectively called <i>scalar types</i>.
Scalar types, trivially copyable class types ([class.prop]), arrays of such types, and cv-qualified versions of these types
are collectively called <i>trivially copyable types</i>.
<del>Scalar</del> <ins>Trivially copyable</ins> types, trivially relocatable class types (<a href="#wording-class.prop">[class.prop]</a>), arrays of such types, and cv-qualified versions of these types
are collectively called <i>trivially relocatable types</i>.
<del>Cv-unqualified scalar types, replaceable class types ([class.prop]), and arrays of such types
are collectively called <i>replaceable types</i>.</del>
Scalar types, standard-layout class types ([class.prop]), arrays of such types, and cv-qualified versions of these types
are collectively called <i>standard-layout types</i>.
Scalar types, implicit-lifetime class types ([class.prop]), array types, and cv-qualified versions of these types
are collectively called <i>implicit-lifetime types</i>.

<p><ins>[*Note:* For a trivially relocatable type, object relocation operations
(as exemplified by `std::swap_ranges` and `std::vector::reserve`) are always tantamount
to simple copies of the underlying bytes. *—end note*]</ins>

10․ A type is a <i>literal type</i> if it is: [...]
</blockquote></small>


## [class.pre] ## {#wording-class.pre}

Modify <a href="http://eel.is/c++draft/class.pre">[class.pre]</a> as follows:

<small><blockquote>
<i>class-property-specifier</i>:<br>
&emsp; <code>final</code><br>
&emsp; <del><code>trivially_relocatable_if_eligible</code></del><br>
&emsp; <del><code>replaceable_if_eligible</code></del>

[...]

<p>5․ Each <i>class-property-specifier</i> shall appear at most once within a single <i>class-property-specifier-seq</i>.
Whenever a <i>class-key</i> is followed by a <i>class-head-name</i>, the identifier
`final`, <del>`trivially_relocatable_if_eligible`, or `replaceable_if_eligible`,</del> and a colon or left brace,
the identifier is interpreted as a <i>class-property-specifier</i>.

<p>[<i>Example</i>:<pre>
  struct A;
  struct A final {};      // OK, definition of struct A,
                          // not value-initialization of variable final

  struct X {
   struct C { constexpr operator int() { return 5; } };
   struct B <del>trivially_relocatable_if_eligible</del> <ins>final</ins> : C{};
                          // OK, definition of nested class B,
                          // not declaration of a bit-field member
                          // <del>trivially_relocatable_if_eligible</del> <ins>final</ins>
  };
</pre>
—<i>end example</i>]
</blockquote></small>

## [class.prop] ## {#wording-class.prop}

Modify <a href="http://eel.is/c++draft/class.prop">[class.prop]</a> as follows:

<small><blockquote>
<p>1․ A <i>trivially copyable class</i> is a class:
- that has at least one eligible copy constructor, move constructor, copy assignment operator, or move assignment operator ([special], [class.copy.ctor], [class.copy.assign]),
- where each eligible copy constructor, move constructor, copy assignment operator, and move assignment operator is trivial, and
- that has a trivial, non-deleted destructor ([class.dtor]).

<p><ins>x․ A <i>trivially relocatable class</i> is a class:</ins>
- <ins>where no eligible copy constructor, move constructor, copy assignment operator, move assignment operator, or destructor is user-provided,</ins>
- <ins>that has no virtual member functions or virtual base classes,</ins>
- <ins>all of whose non-static data members are either of reference type or of trivially relocatable type (<a href="#wording-basic.types.general">[basic.types.general]</a>), and</ins>
- <ins>all of whose base classes are of trivially relocatable type;</ins>

<ins>or a class that is declared with a `trivially_relocatable` attribute with value `true` (<a href="#wording-dcl.attr.trivreloc">[dcl.attr.trivreloc]</a>)
if that attribute is supported by the implementation (<a href="#wording-cpp.cond">[cpp.cond]</a>).</ins>

<p><del>2․ A class `C` is <i>default-movable</i> if</del>
- <del>overload resolution for direct-initializing an object of type `C` from an xvalue of type `C` selects a constructor that is a direct member of `C`
    and is neither user-provided nor deleted,</del>
- <del>overload resolution for assigning to an lvalue of type `C` from an xvalue of type `C` selects an assignment operator function that is a direct member of `C`
    and is neither user-provided nor deleted, and</del>
- <del>`C` has a destructor that is neither user-provided nor deleted.</del>

<p><del>3․ A class is <i>eligible for trivial relocation</i> unless it</del>
- <del>has any virtual base classes,</del>
- <del>has a base class that is not a trivially relocatable class,</del>
- <del>has a non-static data member of an object type that is not of a trivially relocatable type, or</del>
- <del>has a deleted destructor,</del>

<del>except that it is implementation-defined whether an otherwise-eligible union having one or more subobjects of polymorphic class type
is eligible for trivial relocation.</del>

<p><del>4․ A class `C` is a <i>trivially relocatable class</i> if it is eligible for trivial relocation and</del>
- <del>has the `trivially_relocatable_if_eligible` <i>class-property-specifier</i>,</del>
- <del>is a union with no user-declared special member functions, or</del>
- <del>is default-movable.</del>

<p><del>5․ [<i>Note:</i> A class with const-qualified or reference non-static data members can be trivially relocatable. —<i>end note</i>]</del>

<p><del>6․ A class `C` is <i>eligible for replacement</i> unless</del>
- <del>it has a base class that is not a replaceable class,</del>
- <del>it has a non-static data member that is not of a replaceable type,</del>
- <del>overload resolution fails or selects a deleted constructor
    when direct-initializing an object of type `C` from an xvalue of type `C` ([dcl.init.general]),</del>
- <del>overload resolution fails or selects a deleted assignment operator function 
    when assigning to an lvalue of type `C` from an xvalue of type `C` ([expr.assign], [over.assign])), or</del>
- <del>it has a deleted destructor.</del>

<p><del>7․ A class `C` is a <i>replaceable class</i> if it is eligible for replacement and</del>
- <del>has the `replaceable_if_eligible` <i>class-property-specifier</i>,</del>
- <del>is a union with no user-declared special member functions, or</del>
- <del>is default-movable.</del>

<p><del>8․ [<i>Note:</i> Accessibility of the special member functions is not considered when establishing trivial relocatability or replaceability. —<i>end note</i>]</del>

<p><del>9․ [<i>Note:</i> Not all trivially copyable classes are trivially relocatable or replaceable. —<i>end note</i>]</del>

<p>10․ A class `S` is a <i>standard-layout class</i> if it: [...]
</blockquote></small>


## [cpp.cond] ## {#wording-cpp.cond}

Add a new entry to the table of supported attributes in
<a href="https://eel.is/c++draft/cpp.cond">[cpp.cond]</a>:

<small><blockquote>
<pre>
noreturn              200809L
<ins>trivially_relocatable YYYYMML</ins>
unlikely              201803L
</pre>
</blockquote></small>


## [dcl.attr.trivreloc] ## {#wording-dcl.attr.trivreloc}

Add a new section after <a href="http://eel.is/c++draft/dcl.attr.nouniqueaddr">[dcl.attr.nouniqueaddr]</a>:

<small><blockquote>
<p><ins>1․ The *attribute-token* `trivially_relocatable` specifies that a class type's relocation operation has no
visible side-effects other than a copy of the underlying bytes, as if by the library function `std::memcpy`.
It may be applied to the definition of a class. It shall appear at most once in each *attribute-list*.
An *attribute-argument-clause* may be present and, if present, shall have the form</ins>
<p><pre>
    <ins>( <i>constant-expression</i> )</ins>
</pre>
<p><ins>The *constant-expression* shall be an integral constant expression of type `bool`.
If no *attribute-argument-clause* is present, it has the same effect as an *attribute-argument-clause*
of `(true)`.</ins>

<p><ins>2․ If any definition of a class type has a `trivially_relocatable` attribute with value *V*, then each
definition of the same class type shall have a `trivially_relocatable` attribute with value *V*.
No diagnostic is required if definitions in different translation units have
mismatched `trivially_relocatable` attributes.</ins>

<p><ins>3․ If a class type is declared with the `trivially_relocatable` attribute, and the program relies on
observable side-effects of its relocation other than a copy of the underlying bytes, the behavior is undefined.</ins>

<p><ins>4․ *Recommended practice:* The value of a <i>has-attribute-expression</i> for
the `trivially_relocatable` attribute should be `0` for a given implementation unless this attribute
can cause a class type to be trivially relocatable (<a href="#wording-class.prop">[class.prop]</a>).</ins>
</blockquote></small>


## [expr.prim.lambda.closure] ## {#wording-expr.prim.lambda.closure}

Modify <a href="http://eel.is/c++draft/expr.prim.lambda.closure">[expr.prim.lambda.closure]</a> as follows:

<small><blockquote>
<p>3. The closure type is not an aggregate type ([dcl.init.aggr]);
it is a structural type ([temp.param]) if and only if the lambda has no <i>lambda-capture</i>.
An implementation may define the closure type differently from what is described below provided this does not alter
the observable behavior of the program other than by changing:
- the size and/or alignment of the closure type,
- whether the closure type is trivially copyable ([class.prop]),
- whether the closure type is trivially relocatable ([class.prop]),
- <del>whether the closure type is replaceable ([class.prop]),</del> or
- whether the closure type is a standard-layout class ([class.prop]).

An implementation shall not add members of rvalue reference type to the closure type.
</blockquote></small>


## [lex.name] ## {#wording-lex.name}

Modify <a href="http://eel.is/c++draft/lex.name">[lex.name]</a> as follows:

<small><blockquote>
<p>2. The identifiers in Table 4 have a special meaning when appearing in a certain context.
When referred to in the grammar, these identifiers are used explicitly rather than using the
<i>identifier</i> grammar production. Unless otherwise specified, any ambiguity as to whether
a given <i>identifier</i> has a special meaning is resolved to interpret the token as a
regular <i>identifier</i>.

<p>Table 4 — Identifiers with special meaning
<pre>
  final     import  post  <del>replaceable_if_eligible</del>
  override  module  pre   <del>trivially_relocatable_if_eligible</del>
</pre>
</blockquote></small>


## [library.class.props] ## {#wording-library.class.props}

Modify <a href="https://eel.is/c++draft/library.class.props">[library.class.props]</a> as follows:

<small><blockquote>
<p>1. Unless explicitly stated otherwise, it is unspecified whether any class described in [support] through [exec] and [depr]
is a trivially copyable class, <ins>a trivially relocatable class,</ins> a standard-layout class, or an implicit-lifetime class ([class.prop]).
<p><del>2. Unless explicitly stated otherwise, it is unspecified whether any class for which trivial relocation
(i.e., the effects of `trivially_relocate` ([obj.lifetime])) would be semantically equivalent to move-construction
of the destination object followed by destruction of the source object is a trivially relocatable class ([class.prop]).</del>
<p><del>3. Unless explicitly stated otherwise, it is unspecified whether a class `C` is a replaceable class ([class.prop])
if assigning an xvalue `a` of type `C` to an object `b` of type `C` is semantically equivalent to destroying `b` and then
constructing from `a` in <code>b</code>'s place.</del>
</blockquote></small>


## [meta.type.synop] ## {#wording-meta.type.synop}

Modify <a href="http://eel.is/c++draft/meta.type.synop">[meta.type.synop]</a> as follows:

<small><blockquote>
<pre>
  [...]
  <i>// <a href="#wording-meta.unary.prop">[meta.unary.prop]</a>, type properties</i>
  template&lt;class T> struct is_const;
  template&lt;class T> struct is_volatile;
  template&lt;class T> struct is_trivially_copyable;
  template&lt;class T> struct is_trivially_relocatable;
  <del>template&lt;class T> struct is_replaceable;</del>
  template&lt;class T> struct is_standard_layout;
  [...]
  template&lt;class T>
    constexpr bool is_implicit_lifetime_v = is_implicit_lifetime&lt;T>::value;
  <del>template&lt;class T></del>
    <del>constexpr bool is_replaceable_v = is_replaceable&lt;T>::value;</del>
  template&lt;class T>
    constexpr bool has_virtual_destructor_v = has_virtual_destructor&lt;T>::value;
</pre>
</blockquote></small>

## [meta.unary.prop] ## {#wording-meta.unary.prop}

Modify Table 54 in <a href="http://eel.is/c++draft/meta.unary.prop">[meta.unary.prop]</a> as follows:

<small><blockquote>
<table>
<tr><th>Template</th><th>Condition</th><th>Preconditions</th></tr>
<tr>
<td>`template<class T> struct is_trivially_copyable;`</td>
<td>`T` is a trivially copyable type ([basic.types.general])</td>
<td>`remove_all_extents_t<T>` shall be a complete type or <i>cv</i> `void`.</td>
</tr>
<tr>
<td>`template<class T> struct is_trivially_relocatable;`</td>
<td>`T` is a trivially relocatable type (<a href="#wording-basic.types.general">[basic.types.general]</a>)</td>
<td>`remove_all_extents_t<T>` shall be a complete type or <i>cv</i> `void`.</td>
</tr>
<tr>
<td><del>`template<class T> struct is_replaceable;`</del></td>
<td><del>`T` is a replaceable type (<a href="#wording-basic.types.general">[basic.types.general]</a>)</del></td>
<td><del>`remove_all_extents_t<T>` shall be a complete type or <i>cv</i> `void`.</del></td>
</tr>
<tr>
<td>`template<class T> struct is_standard_layout;`</td>
<td>`T` is a standard-layout type ([basic.types.general])</td>
<td>`remove_all_extents_t<T>` shall be a complete type or <i>cv</i> `void`.</td>
</tr>
</table>
</blockquote></small>


## [obj.lifetime] ## {#wording-obj.lifetime}

Modify <a href="http://eel.is/c++draft/obj.lifetime">[obj.lifetime]</a> as follows:

<small><blockquote>
<pre>
  template&lt;class T>
    T* trivially_relocate(T* first, T* last, T* result);
</pre>

<p>9. *Mandates:* `is_trivially_relocatable_v<T> && !is_const_v<T>` is `true`. `T` is not an array of unknown bound.

<p>10. *Preconditions:*
- [`first`, `last`) is a valid range.
- [`result`, `result + (last - first)`) denotes a region of storage that is a subset of the region reachable through `result` ([basic.compound])
    and suitably aligned for the type `T`.
- No element in the range [`first`, `last`) is a potentially-overlapping subobject.

<p>11. *Postconditions:* No effect if `result == first` is `true`.
    Otherwise, the range denoted by [`result`, `result + (last - first)`) contains objects (including subobjects)
    whose lifetime has begun and whose object representations are the original object representations of the corresponding objects
    in the source range [`first`, `last`) <del>except for any parts of the object representations used by the implementation
    to represent type information ([intro.object])</del>. If any of the objects has union type, its active member is the same
    as that of the corresponding object in the source range. If any of the aforementioned objects has a non-static data member
    of reference type, that reference refers to the same entity as does the corresponding reference in the source range.
    The lifetimes of the original objects in the source range have ended.

<p>12. *Returns:* `result + (last - first)`.

<p>13. *Throws:* Nothing.

<p>14. *Complexity:* Linear in the length of the source range.

<p>15. *Remarks:* The destination region of storage is considered reused ([basic.life]). No constructors or destructors are invoked.

<p>[<i>Note:</i> Overlapping ranges are supported. —<i>end note</i>]

<!--
<p><pre>
  template&lt;class T>
    constexpr T* relocate(T* first, T* last, T* result);
</pre>

<p>16. *Mandates:* `is_nothrow_relocatable_v<T> && !is_const_v<T>` is `true`. `T` is not an array of unknown bound.

<p>17. *Preconditions:*
- [`first`, `last`) is a valid range.
- [`result`, `result + (last - first)`) denotes a region of storage that is a subset of the region reachable through result ([basic.compound])
    and suitably aligned for the type `T`.
- No element in the range [`first`, `last`) is a potentially-overlapping subobject.

<p>18. *Effects:*
- If `result == first` is `true`, no effect;
- otherwise, if not called during constant evaluation and `is_trivially_relocatable_v<T>` is `true`, then has effects equivalent to:
     `trivially_relocate(first, last, result);`
- otherwise, for each integer `i` in [`0`, `last - first`),
    - if `T` is an array type, equivalent to: `relocate(begin(first[i]), end(first[i]), *start_lifetime_as<T>(result + i));`
    - otherwise, equivalent to: `construct_at(result + i, std::move(first[i])); destroy_at(first + i);`

<p>19. *Returns:* `result + (last - first)`.

<p>20. *Throws:* Nothing.

<p>[<i>Note</i>: Overlapping ranges are supported. —<i>end note</i>]
-->
</blockquote></small>

## [diff.cpp23.dcl.dcl] ## {#wording-diff.cpp23.dcl.dcl}

Modify <a href="http://eel.is/c++draft/diff.cpp23.dcl.dcl">[diff.cpp23.dcl.dcl]</a> as follows:

<small><blockquote>
<p><del>1. Affected subclause: [dcl.decl.general]</del><br>
<del>Change: Introduction of `trivially_relocatable_if_eligible` and `replaceable_if_eligible` as identifiers with special meaning ([lex.name]).</del><br>
<del>Rationale: Support declaration of trivially relocatable and replaceable types ([class.prop]).</del><br>
<del>Effect on original feature: Valid C++ 2023 code can become ill-formed.</del><br>

<p><del>[<i>Example</i>:</del>
<pre>
  <del>struct C {};</del>
  <del>struct C replaceable_if_eligible {};    // was well-formed (new variable replaceable_if_eligible)</del>
                                          <del>// now ill-formed (redefines C)</del>
</pre>
<del>—<i>end example</i>]</del>
</blockquote></small>


<pre class=biblio>
{
  "Abseil": {
    "authors": [
      "Aaron Jacobs",
      "et al."
    ],
    "title": "Abseil C++ Common Libraries",
    "href": "https://github.com/abseil/abseil-cpp",
    "date": "March 2023"
  },
  "Amadeus": {
    "authors": [
      "Stephane Janel"
    ],
    "title": "AMadeus (C++) Containers",
    "href": "https://github.com/AmadeusITGroup/amc",
    "date": "April 2021"
  },
  "Announcing": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Announcing \"trivially relocatable\"",
    "href": "https://quuxplusone.github.io/blog/2018/07/18/announcing-trivially-relocatable/",
    "date": "July 2018"
  },
  "Bench": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Benchmark code from \"The Best Type Traits C++ Doesn't Have\"",
    "href": "https://github.com/Quuxplusone/from-scratch/blob/095b246d/cppnow2018/benchmark-relocatable.cc",
    "date": "April 2018"
  },
  "Boost.Interprocess": {
    "authors": [
      "Ion Gaztañaga"
    ],
    "title": "Mapping Address Independent Pointer: offset_ptr",
    "href": "https://www.boost.org/doc/libs/1_67_0/doc/html/interprocess/offset_ptr.html",
    "date": "2005"
  },
  "BSL": {
    "authors": [
      "Bloomberg"
    ],
    "title": "bslmf::IsBitwiseMoveable: bitwise moveable trait metafunction",
    "href": "https://github.com/bloomberg/bde/blob/962f7aa/groups/bsl/bslmf/bslmf_isbitwisemoveable.h#L8-L48",
    "date": "2013–2022"
  },
  "CppChat": {
    "authors": [
      "Howard Hinnant",
      "Arthur O'Dwyer"
    ],
    "title": "cpp.chat episode 40: It works but it's undefined behavior",
    "href": "https://www.youtube.com/watch?v=8u5Qi4FgTP8",
    "date": "August 2018"
  },
  "CppNow": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Trivially Relocatable (C++Now 2019)",
    "href": "https://www.youtube.com/watch?v=SGdfPextuAU",
    "date": "May 2019"
  },
  "D50119": {
    "authors": [
      "Arthur O'Dwyer",
      "Nicolas Lesser",
      "John McCall"
    ],
    "title": "Compiler support for P1144R0 __is_trivially_relocatable(T)",
    "href": "https://reviews.llvm.org/D50119",
    "date": "July 2018"
  },
  "D114732": {
    "authors": [
      "Devin Jeanpierre"
    ],
    "title": "[clang] Mark trivial_abi types as trivially relocatable",
    "href": "https://reviews.llvm.org/D114732",
    "date": "November 2021"
  },
  "Deque": {
    "authors": [
      "Marc Glisse"
    ],
    "title": "Improve relocation ... (__is_trivially_relocatable): Specialize for deque",
    "href": "https://github.com/gcc-mirror/gcc/commit/a9b9381580de611126c9888c1a6c12a77d9b682e",
    "date": "November 2018"
  },
  "FixedCapacityVector": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "P1144 case study: Moving a `fixed_capacity_vector`",
    "href": "https://quuxplusone.github.io/blog/2019/02/22/p1144-fixed-capacity-vector/"
  },
  "Folly": {
    "authors": [
      "Facebook"
    ],
    "title": "Folly documentation on \"Object Relocation\"",
    "href": "https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md#object-relocation"
  },
  "HPX": {
    "authors": [
      "Isidoros Tsaousis-Seiras"
    ],
    "title": "Relocation Semantics in the HPX Library",
    "href": "https://isidorostsa.github.io/gsoc2023/",
    "date": "August 2023"
  },
  "InPractice": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "What library types are trivially relocatable in practice?",
    "href": "https://quuxplusone.github.io/blog/2019/02/20/p1144-what-types-are-relocatable/",
    "date": "February 2019"
  },
  "LWG2153": {
    "authors": [
      "Robert Shearer"
    ],
    "title": "Narrowing of the non-member swap contract",
    "href": "https://cplusplus.github.io/LWG/issue2153",
    "date": "April 2012–October 2020"
  },
  "N1377": {
    "authors": [
      "Howard Hinnant",
      "Peter Dimov",
      "Dave Abrahams"
    ],
    "title": "N1377: A Proposal to Add Move Semantics Support to the C++ Language",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm",
    "date": "September 2002"
  },
  "N2754": {
    "authors": [
      "Rodrigo Castro Campos"
    ],
    "title": "N2754: TriviallyDestructibleAfterMove and TriviallyReallocatable (rev 3)",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2754.html",
    "date": "September 2008"
  },
  "N4158": {
    "authors": [
      "Pablo Halpern"
    ],
    "title": "N4158: Destructive Move (rev 1)",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4158.pdf",
    "date": "October 2014"
  },
  "N5008": {
    "title": "Working Draft — Programming Languages — C++",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5008.pdf",
    "date": "March 2025"
  },
  "P0023R0": {
    "authors": [
      "Denis Bider"
    ],
    "title": "P0023R0: Relocator: Efficiently Moving Objects",
    "href": "http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0023r0.pdf",
    "date": "April 2016"
  },
  "P0178R0": {
    "authors": [
      "Alisdair Meredith"
    ],
    "title": "Allocators and swap",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0178r0.html",
    "date": "February 2016"
  },
  "P0843R5": {
    "authors": [
      "Gonzalo Brito Gadeschi"
    ],
    "title": "static_vector",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0843r5.html",
    "date": "July 2022"
  },
  "P1029R3": {
    "authors": [
      "Niall Douglas"
    ],
    "title": "P1029R3: move = bitcopies",
    "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1029r3.pdf",
    "date": "January 2020"
  },
  "P1144R6": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Object relocation in terms of move plus destroy",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1144r6.html",
    "date": "June 2022"
  },
  "P1144R10": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "std::is_trivially_relocatable",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1144r10.html",
    "date": "February 2024"
  },
  "P2814R1": {
    "authors": [
      "Mungo Gill",
      "Alisdair Meredith"
    ],
    "title": "Trivial relocatability — comparing P2786 with P1144",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2814r1.pdf",
    "date": "May 2023"
  },
  "P2785R3": {
    "authors": [
      "Sébastien Bini",
      "Ed Catmur"
    ],
    "title": "Relocating prvalues",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2785r3.html",
    "date": "June 2023"
  },
  "P2786": {
    "authors": [
      "Alisdair Meredith; Mungo Gill; Joshua Berne; Corentin Jabot; Pablo Halpern; Lori Hughes"
    ],
    "title": "Trivial Relocatability For C++26",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2786r13.html",
    "date": "February 2025"
  },
  "P2959": {
    "authors": [
      "Alisdair Meredith"
    ],
    "title": "Relocation within containers",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2959r0.html",
    "date": "October 2023"
  },
  "P2967": {
    "authors": [
      "Alisdair Meredith",
      "Mungo Gill"
    ],
    "title": "Relocation has a library interface",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2967r1.pdf",
    "date": "May 2024"
  },
  "P3239": {
    "authors": [
      "Alisdair Meredith"
    ],
    "title": "A relocating swap",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3239r0.pdf",
    "date": "May 2024"
  },
  "D3262": {
    "authors": [
      "Alisdair Meredith"
    ],
    "title": "Specifying Trivially Relocatable Types in the Standard Library",
    "href": "https://isocpp.org/files/papers/D3262R0.pdf",
    "date": "unreleased (May 2024)"
  },
  "P3055R1": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Relax wording to permit relocation optimizations in the STL",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3055r1.html",
    "date": "February 2024"
  },
  "P3233": {
    "authors": [
      "Giuseppe D'Angelo"
    ],
    "title": "Issues with P2786 ('Trivial Relocatability For C++26')",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3233r0.html",
    "date": "April 2024"
  },
  "P3236": {
    "authors": [
      "Alan de Freitas; Daniel Liam Anderson; Giuseppe D'Angelo; Hans Goudey; Jacques Lucke; Krystian Stasiowski; Stéphane Janel; Thiago Maciera"
    ],
    "title": "Please reject P2786 and adopt P1144",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3236r1.html",
    "date": "May 2024"
  },
  "P3279": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "CWG2463: What 'trivially fooable' should mean",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3279r0.html",
    "date": "May 2024"
  },
  "P3516": {
    "authors": [
      "Louis Dionne",
      "Giuseppe D'Angelo"
    ],
    "title": "Uninitialized algorithms for relocation",
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3516r1.html",
    "date": "February 2025"
  },
  "ParlayLib": {
    "authors": [
      "Daniel Anderson",
      "Guy Blelloch"
    ],
    "title": "ParlayLib, a toolkit for programming parallel algorithms on shared-memory multicore machines",
    "href": "https://github.com/cmuparlay/parlaylib/blob/36459f4/include/parlay/relocation.h",
    "date": "February 2024"
  },
  "PocketPy": {
    "authors": [
      "blueloveTH",
      "ykiko"
    ],
    "title": "pocketpy: single-file Python interpreter",
    "href": "https://github.com/pocketpy/pocketpy/blob/2929add/include/pocketpy/vector.h",
    "date": "February 2024"
  },
  "Polymorphic": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "Polymorphic types aren't trivially relocatable",
    "href": "https://quuxplusone.github.io/blog/2023/06/24/polymorphic-types-arent-trivially-relocatable/",
    "date": "June 2023"
  },
  "Qt": {
    "title": "Qt Base",
    "href": "https://github.com/qt/qtbase/",
    "date": "February 2023"
  },
  "StdRelocateIsCute": {
    "authors": [
      "Arthur O'Dwyer"
    ],
    "title": "std::relocate's implementation is cute",
    "href": "https://quuxplusone.github.io/blog/2022/05/18/std-relocate/",
    "date": "May 2022"
  },
  "StdxError": {
    "authors": [
      "Charles Salvia"
    ],
    "title": "Implementation of std::error as proposed by Herb Sutter in P0709R0",
    "href": "https://github.com/charles-salvia/std_error/",
    "date": "October 2023"
  },
  "Subspace": {
    "authors": [
      "Dana Jansens"
    ],
    "title": "Trivially Relocatable Types in C++/Subspace",
    "href": "https://danakj.github.io/2023/01/15/trivially-relocatable.html",
    "date": "January 2023"
  },
  "Thrust": {
    "authors": [
      "Bryce Adelstein Lelbach",
      "Michał Dominiak"
    ],
    "title": "Nvidia Thrust",
    "href": "https://github.com/NVIDIA/cccl/blob/main/thrust/thrust/type_traits/is_trivially_relocatable.h",
    "date": "December 2018"
  }
}
</pre>
