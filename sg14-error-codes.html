<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<style type="text/css">

body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }
li { margin: 0 0 1ex 0; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5em; padding-right: 0.5em; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.8em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.8em; border: none; }

</style>

<title>Summary of SG14 discussion on <code>&lt;system_error&gt;</code></title>
</head>
<body>

<b>Document number:</b> PxxxxR0 <br>
<b>Date:</b> 2017-10-13 <br>
<b>Project:</b> ISO JTC1/SC22/WG21, Programming Language C++ <br>
<b>Audience:</b> Library Evolution Working Group <br>
<b>Reply to:</b> Arthur O'Dwyer &lt;arthur.j.odwyer@gmail.com&gt;, Charley Bay &lt;charleyb123@gmail.com&gt; Michael Wong &lt;fraggamuffin@gmail.com&gt; <br>

<h1>Summary of SG14 discussion on <code>&lt;system_error&gt;</code></h1>

<p>
<a href="#Introduction">1. Introduction</a><br>
<a href="#Description">2. Description of C++11's <code>&lt;system_error&gt;</code> facilities</a><br>
<a href="#Best">3. Proposed best practices for using C++11's <code>&lt;system_error&gt;</code> facilities</a><br>
<a href="#Issues">4. Issues with the <code>&lt;system_error&gt;</code> facilities</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#issue-string">4.1. Use of <code>std::string</code></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#issue-outparams">4.2. Proliferation of "two-API" libraries</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#issue-bool">4.3. No wording sets aside the <code>0</code> enumerator</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#issue-singletons">4.4. Reliance on singletons</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#issue-constexpr">4.5. No <code>error_category</code> subclass can be a literal type</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#issue-metadata">4.6. No guidance on attaching extra information to <code>error_code</code></a><br>
</p>


<h2><a name="Introduction">1. Introduction</a></h2>

<p>
This paper summarizes a discussion that took place during the SG14 telecon of 2017-10-11.
The discussion concerned the facilities of <code>&lt;system_error&gt;</code> (introduced in C++11),
which include <code>errc</code>, <code>error_code</code>, <code>error_condition</code>,
<code>error_category</code>, and <code>system_error</code>.
</p>

<p>
The discussion naturally also concerns the current idioms for exceptionless "disappointment handling"
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0157r0.html">P157R0</a>, Lawrence Crowl), as seen
in <code>&lt;filesystem&gt;</code> (C++17) and <code>std::from_chars</code>/<code>to_chars</code> (also C++17);
and it concerns <i>future</i> idioms for exceptionless disappointment handling, as proposed
in <code>status_value&lt;E,T&gt;</code>
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0262r0.html">P0262R0</a>, Lawrence Crowl),
in <code>expected&lt;T,E&gt;</code>
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r2.pdf">P0323R2</a>, Vicente J. Botet Escribá),
and in <code>result&lt;T,E&gt;</code> (Niall Douglas).
</p>

<p>
In all of those future idioms involving <code>expected&lt;T,E&gt;</code>-style result types, SG14 expects that
the <code>E</code> type parameter will default to <code>std::error_code</code> — which is right and good. This means
that the coming years will see extremely heavy use of <code>std::error_code</code> at every level of the system.
This means that SG14 is very interested in correcting deficiencies in <code>std::error_code</code> sooner, rather
than later.
</p>

<p>
On SG14's 2017-10-11 teleconference call, various people contributed to a miscellaneous "laundry list" of
perceived deficiencies with <code>&lt;system_error&gt;</code>. Several "best practices" were also proposed for
how we expect <code>&lt;system_error&gt;</code> facilities to be used in the best codebases. (Unfortunately,
the Standard Library does not follow <i>anyone's</i> proposed "best practice"!) This paper is a summary of that
discussion.
</p>

<h2><a name="Description">2. Description of C++11's <code>&lt;system_error&gt;</code> facilities</a></h2>

<p>
<code>&lt;system_error&gt;</code> provides the following patterns for dealing with error codes:
</p>

<p>
    A <code>std::error_code</code> object wraps an integer "error enumerator" and a pointer to an "error category"
    (that is, a handle to the specific error domain associated with this integer enumerator). The addition of the
    error domain handle is what allows us to distinguish, say, <code>error=5</code> "no leader for Kafka partition"
    (in the rdkafka domain) from <code>error=5</code> "I/O error" (in the POSIX domain). Two <code>error_code</code>
    instances compare equal if and only if they represent the same error enumerator <i>in the same domain</i>.
</p>
<p>
    Notice that <code>std::error_condition</code> is not the same type as <code>std::error_code</code>!
</p>
<pre>
    namespace std {
    class error_code {
        int value_;
        std::error_category *cat_;
    public:
        error_code() noexcept : error_code(0, std::system_category()) {}
        error_code(int e, const std::error_category& c) noexcept : value_(e), cat_(&c) {}
        template&lt;class E&gt; error_code(E e) noexcept requires(std::is_error_code_enum_v&lt;E&gt;) { *this = make_error_code(e); }  // intentional ADL
        template&lt;class E&gt; error_code& operator=(E e) noexcept requires(std::is_error_code_enum_v&lt;E&gt;) { *this = make_error_code(e); }  // intentional ADL
        void assign(int e, const std::error_category& c) noexcept { value_ = e; cat_ = &c; }
        void clear() noexcept { *this = std::error_code(); }

        explicit operator bool() const noexcept { return !!value_; }
        int value() const noexcept { return value_; }
        const std::error_category& category() const noexcept { return cat_; }

        std::string message() const { return cat_->message(value_); }
        std::error_condition default_error_condition() const noexcept { return cat_->default_error_condition(value_); }
    };
    bool operator==(const std::error_code& a, const std::error_code& b) noexcept { return a.value() == b.value() && &a.category() == &b.category(); }
    } // namespace std
</pre>

<p>
    Each "error domain" is represented in code by an object of type <code>std::error_category</code>. These are always
    singletons, effectively, because <code>error_code</code> equality-comparison is implemented in terms of pointer comparison
    (see above). So two <code>error_category</code> objects located at different memory addresses represent different
    error domains, <i>by definition</i>, as far as the currently standardized scheme is concerned.
</p>
<pre>
    namespace std {
    class error_category {
    public:
        constexpr error_category() noexcept = default;
        error_category(const error_category&) = delete;
        virtual ~error_category() {}

        virtual const char *name() const noexcept = 0;

        virtual std::error_condition default_error_condition(int e) const noexcept { return std::error_condition(e, *this); }
        virtual std::string message(int e) const = 0;

        virtual bool equivalent(int e, const std::error_condition& condition) const noexcept { return this->default_error_condition(e) == condition; }
        virtual bool equivalent(const std::error_code& code, int e) const noexcept { return code == std::error_code(e, *this); }
    };
    bool operator==(const std::error_category& a, const std::error_category& b) noexcept { return &a == &b; }
    } // namespace std
</pre>

<p>
    It is intended that the programmer should <i>inherit publicly from</i> <code>std::error_category</code> and override its pure virtual methods
    (and optionally override its non-pure virtual methods) to create new library-specific error domains. An error domain encompasses a set of
    error enumerators with their associated human meanings (for example, <code>error=5</code> meaning "no leader for Kafka partition").
    So for example we can expect that <code>rdkafka_category().message(5)</code> would return
    <code>std::string("no leader for partition")</code>.
</p>

<p>
    The standard also provides a class <code>std::error_condition</code> which is almost identical in implementation
    to <code>std::error_code</code>.
</p>
<pre>
    namespace std {
    class error_condition {
        int value_;
        std::error_category *cat_;
    public:
        error_condition() noexcept : error_code(0, std::generic_category()) {}
        error_condition(int e, const std::error_category& c) noexcept : value_(e), cat_(&c) {}
        template&lt;class E&gt; error_condition(E e) noexcept requires(std::is_error_condition_enum_v&lt;E&gt;) { *this = make_error_condition(e); }  // intentional ADL
        template&lt;class E&gt; error_condition& operator=(E e) noexcept requires(std::is_error_condition_enum_v&lt;E&gt;) { *this = make_error_condition(e); }  // intentional ADL
        void assign(int e, const std::error_category& c) noexcept { value_ = e; cat_ = &c; }
        void clear() noexcept { *this = std::error_condition(); }

        explicit operator bool() const noexcept { return !!value_; }
        int value() const noexcept { return value_; }
        const std::error_category& category() const noexcept { return cat_; }

        std::string message() const { return cat_->message(value_); }
    };
    bool operator==(const std::error_condition& a, const std::error_condition& b) noexcept { return a.value() == b.value() && &a.category() == &b.category(); }
    } // namespace std
</pre>
<p>
    The best practice for using <code>std::error_condition</code> is the subject of some debate in SG14; see the rest of this paper.
    However, clearly the vague intent of <code>std::error_condition</code> is to represent in some way a high-level "condition" which
    a low-level "error code" (thrown up from the bowels of the system) might or might not "match" in some high-level semantic sense.
    Notice that the error domain of a default-constructed <code>error_code</code> is <code>system_category()</code>, whereas the
    error domain of a default-constructed <code>error_condition</code> is <code>generic_category()</code>.
</p>

<p>
    The standard provides a highly customizable codepath for comparing an <code>error_code</code> against an <code>error_condition</code>
    with <code>operator==</code>.
    (Both <code>error_code</code> and <code>error_condition</code> are value types &mdash; in fact they are POD types &mdash; which means
    that their own <code>operator==(A,A)</code> are just bitwise comparisons. We are now speaking of <code>operator==(A,B)</code>.)
</p>
<pre>
    namespace std {
    bool operator==(const std::error_code& a, const std::error_condition& b) noexcept {
        return a.category().equivalent(a.value(), b) or b.category().equivalent(a, b.value());
    }
    bool operator==(const std::error_condition& a, const std::error_code& b) noexcept {
        return a.category().equivalent(a.value(), b) or b.category().equivalent(a, b.value());
    }
    } // namespace std
</pre>
<p>
    Recall that the base-class implementation of <code>error_category::equivalent()</code> is just to compare for strict equality;
    but the programmer's own <code>error_category</code>-derived classes can override <code>equivalent()</code> to have different
    behavior.
</p>

<p>
    Lastly, the <code>&lt;system_error&gt;</code> header provides an exception class that wraps an <code>error_code</code>
    (but not an <code>error_condition</code>):
</p>
<pre>
    namespace std {
    class system_error : public std::runtime_error {
        std::error_code code_;
        std::string what_;
    public:
        system_error(std::error_code ec) : code_(ec), what_(ec.message()) {}
        system_error(std::error_code ec, const std::string& w) : code_(ec), what_(ec.message() + ": " + w) {}
        system_error(std::error_code ec, const char *w) : system_error(ec, std::string(w)) {}
        system_error(int e, const std::error_category& cat) : system_error(std::error_code(e, cat)) {}
        system_error(int e, const std::error_category& cat, const std::string& w) : system_error(std::error_code(e, cat), w) {}
        system_error(int e, const std::error_category& cat, const char *w) : system_error(std::error_code(e, cat), w) {}
        const std::error_code& code() const noexcept { return code_; }
        const char *what() const noexcept override { return what_.c_str(); }
    };
    } // namespace std
</pre>

<h2><a name="Best">3. Proposed best practices for using C++11's <code>&lt;system_error&gt;</code> facilities</a></h2>

<p>
    In the example that follows, we have an application <code>appA</code>, which calls into library <code>libB</code>,
    which calls into library <code>libC</code>, which calls into library <code>libD</code>.
</p>
<p>
    Arthur O'Dwyer proposes the following general rules:
    <ol>
        <li>No enumeration type <code>E</code> should ever satisfy <i>both</i> <code>is_error_code_enum_v&lt;E&gt;</code>
        and <code>is_error_condition_enum_v&lt;E&gt;</code> simultaneously. (To do so would be to represent a low-level error code value
        and a high-level abstract condition simultaneously, which is impossible.)</li>

        <li>For any enumeration type <code>E</code>, the ADL function <code>make_error_code(E)</code> should exist if-and-only-if
        <code>is_error_code_enum_v&lt;E&gt;</code>; and the ADL function <code>make_error_condition(E)</code> should exist if-and-only-if
        <code>is_error_condition_enum_v&lt;E&gt;</code>.

        <li>In any enumeration type <code>E</code> satisfying either <code>is_error_code_enum_v&lt;E&gt;</code> or
        <code>is_error_condition_enum_v&lt;E&gt;</code>, the enumerator value <code>0</code> must be set aside as a "success"
        value, and never allotted to any mode of failure. In fact, the enumeration <code>E</code> should have an enumerator
        <code>success = 0</code> or <code>none = 0</code> to ensure that this invariant is never broken accidentally by
        a maintainer.</li>

        <li>Your library should have exactly as many <code>error_category</code> subclasses as it has enumeration types satisfying
        either <code>is_error_code_enum_v&lt;E&gt;</code> or <code>is_error_condition_enum_v&lt;E&gt;</code>, in a one-to-one correspondence.
        No <code>error_category</code> subclass should be "shared" between two enumeration types; and no <code>error_category</code>
        subclass should exist that is not associated with a specific enumeration type.</li>

        <li>Each <code>error_category</code> subclass should be a singleton; that is, it should have a single instance
        across the entire program.</li>

        <li>When your library detects a failure, it should construct an <code>std::error_code</code> representing the failure. This can
        be done using ADL <code>make_error_code(LibD::ErrCode::failure_mode)</code> or simply using <code>LibD::ErrCode::failure_mode</code>
        (which works because of <code>std::error_code</code>'s implicit constructor from error-code-enum types).</li>

        <li>This <code>std::error_code</code> is passed up the stack using out-parameters (as <code>&lt;filesystem&gt;</code>) or
        using <code>Expected&lt;T, std::error_code&gt;</code>.</li>

        <li>When <code>libB</code> receives a <code>std::error_code code</code> that must be checked for <i>failure versus success</i>,
        it should use <code>if (code)</code> or <code>if (!code)</code>.</li>

        <li>When <code>libB</code> receives a <code>std::error_code code</code> that must be checked for
        <i>a particular source-specific error</i> (such as "rdkafka partition lacks a leader"), it should use
        <code>if (code == LibD::ErrCode::failure_mode)</code>. This performs exact equality,
        and is useful if you know the exact source of the error you're looking for (such as "rdkafka").</li>

        <li>When <code>libB</code> receives a <code>std::error_code code</code> that must be checked for
        <i>a high-level condition</i> (such as "file not found"), which might correspond to any of several source-specific errors
        across different domains, it may use <code>if (code == LibC::ErrCondition::failure_mode)</code>, where <code>LibC::ErrCondition</code>
        is an error-condition-enum type provided by the topmost library (the one whose API we're calling &mdash; not any lower-level
        library). This will perform semantic classification.</li>

        <li>Your library might perhaps <i>provide</i> semantic classification by providing an error-condition-enum type <code>LibB::ErrCondition</code>
        (and its associated <code>error_category</code> subclass <code>LibB::ErrConditionCategory</code>), which encodes knowledge about
        the kinds of error values reported by <code>LibC</code>. Ideally, <code>LibB::ErrConditionCategory::equivalent()</code> should
        defer to <code>LibC::ErrConditionCategory::equivalent()</code> in any case where <code>LibB</code> is unsure of the meaning of
        a particular error code (for example, if it comes from an unrecognized error domain).</li>

        <li>Most likely, <code>std::error_condition</code> and error-condition-enum types should simply <i>not be used</i>.
        <code>libB</code> should not expect its own callers to write <code>if (code == LibB::ErrCondition::oom_failure)</code>;
        instead <code>libB</code> should expect its callers to write <code>if (LibB::is_oom_failure(code))</code>, where
        <code>bool LibB::is_oom_failure(std::error_code)</code> is a free function provided by <code>libB</code>. This successfully
        accomplishes semantic classification, and does it without any operator overloading, and therefore does it without the
        need for the <code>std::error_condition</code> type.</li>
    </ol>
</p>

<p>
    Charley Bay proposes (something like) the following general rules (paraphrased here by Arthur O'Dwyer):
    <ol>
        <li>No enumeration type <code>E</code> should ever satisfy <i>both</i> <code>is_error_code_enum_v&lt;E&gt;</code>
        and <code>is_error_condition_enum_v&lt;E&gt;</code> simultaneously. (To do so would be to represent a low-level error code value
        and a high-level abstract condition simultaneously, which is impossible.)</li>

        <li>For any enumeration type <code>E</code>, the ADL function <code>make_error_code(E)</code> should exist if-and-only-if
        <code>is_error_code_enum_v&lt;E&gt;</code>; and the ADL function <code>make_error_condition(E)</code> should exist if-and-only-if
        <code>is_error_condition_enum_v&lt;E&gt;</code>.

        <li>In any enumeration type <code>E</code> satisfying either <code>is_error_code_enum_v&lt;E&gt;</code> or
        <code>is_error_condition_enum_v&lt;E&gt;</code>, the enumerator value <code>0</code> must be set aside as a "success"
        value, and never allotted to any mode of failure. In fact, the enumeration <code>E</code> should have an enumerator
        <code>success = 0</code> or <code>none = 0</code> to ensure that this invariant is never broken accidentally by
        a maintainer.</li>

        <li><code>error_category</code> subclasses are not necessarily singletons. It is conceivable that multiple instances
        of the same <code>error_category</code> subclass type could exist within the same program.</li>

        <li>When your library detects a failure, it should construct an <code>std::error_code</code> representing the failure. This can
        be done using ADL <code>make_error_code(LibD::ErrCode::failure_mode)</code> or simply using <code>LibD::ErrCode::failure_mode</code>
        (which works because of <code>std::error_code</code>'s implicit constructor from error-code-enum types).</li>

        <li>This <code>std::error_code</code> is passed up the stack using out-parameters (as <code>&lt;filesystem&gt;</code>) or
        using <code>Expected&lt;T, std::error_code&gt;</code>.</li>

        <li>When <code>libB</code> receives a <code>std::error_code code</code> that must be checked for <i>failure versus success</i>,
        it should use <code>if (code)</code> or <code>if (!code)</code>.</li>

        <li>When <code>libB</code> receives a <code>std::error_code code</code>, it must <i>never</i> be checked for
        <i>a particular source-specific error</i> (such as "rdkafka partition lacks a leader"). Every test should be done
        on the basis of semantic classification &mdash; whether at the coarse granularity of "failure versus success" or at the
        fine granularity of "partition lacks a leader." It is always conceivable that <code>libC</code> might change out its
        implementation so that it no longer uses <code>libD</code>; therefore, all testing of error codes returned by a
        <code>libC</code> API must be expressed in terms of the specific set of abstract failure modes exposed by that
        same <code>libC</code> API.</li>

        <li>As explained in the preceding point, exact-equality comparisons should never be used.
        But with the standard syntax, there is a significant risk that the programmer will accidentally write
        <code>if (code == LibB::ErrCode::oom_failure)</code> (exact-equality comparison) instead of the intended
        <code>if (code == make_error_condition(LibB::ErrCode::oom_failure))</code> (semantic classification).
        Therefore <code>std::error_condition</code> and error-condition-enum types should <i>not be used</i>. <code>libB</code>
        should expect its callers to write <code>if (LibB::is_oom_failure(code))</code>, where
        <code>bool LibB::is_oom_failure(std::error_code)</code> is a free function provided by <code>libB</code>. This successfully
        accomplishes semantic classification, and does it without any operator overloading, and therefore does it without the
        need for the <code>std::error_condition</code> type.</li>
    </ol>
</p>


<h2><a name="Issues">4. Issues with the <code>&lt;system_error&gt;</code> facilities</a></h2>

<p>
    On the 2017-10-11 teleconference, the following issues were discussed.
</p>


<h3><a name="issue-string">4.1. Use of <code>std::string</code></a></h3>

<p>
    <code>std::error_category</code>'s method <code>virtual std::string message(int) const</code> converts an error-code-enumerator
    into a human-readable message. This functionality is apparently useful only for presentation to humans; i.e., we do not expect
    that anyone should be treating the result of <code>message()</code> as a unique key, nor scanning into its elements with
    <code>strstr</code>. However, as a pure virtual method, this method <i>must</i> be implemented by each <code>error_category</code>
    subclass.
</p>
<p>
    Its return type is <code>std::string</code>, i.e., it introduces a hard-coded dependency on <code>std::allocator&lt;char&gt;</code>.
    This seems to imply that if you are on a computer system without <code>new</code> and <code>delete</code>,
    without <code>std::allocator</code>, without <code>std::string</code>, then you cannot implement your own <code>error_category</code>
    subclasses, which effectively means that you cannot use <code>std::error_code</code> to deal with disappointment.
    SG14 sees any hard-coded dependency on <code>std::allocator</code> as unfortunate.
    For a supposedly "fundamental" library like <code>&lt;system_error&gt;</code> it is <i>extremely</i> unfortunate.
</p>
<p>
    During the call, Charley Bay commented that returning ownership of a dynamically allocated string allows the
    <code>error_category</code> subclass to return a message that differs based on <i>the current locale</i>.
    However, nobody on the call claimed that this functionality was important to them. Furthermore, if locale-awareness
    were desirable, then branching on the <i>current (global) locale</i> would be the wrong way to go about it, because
    that mechanism would not be usable by multi-threaded programs. The right way to introduce locale-awareness into
    <code>error_category</code> would be to provide a virtual method <code>std::string message(int, const std::locale&)</code>.
</p>
<p>
    SG14 seems to agree that eliminating the dependency on <code>std::allocator</code> would be nice.
</p>
<p>
    SG14 seems to agree that dynamically allocated message strings are not an important feature.
</p>
<p>
    Two ways of removing <code>std::string</code> were proposed: return <code>const char*</code>, or return <code>std::string_view</code>.
    Arthur O'Dwyer commented that he strongly prefers <code>const char*</code> for simplicity (no new library dependencies) and for consistency
    with <code>std::error_category::name()</code> and <code>std::exception::what()</code>.
    Niall Douglas commented that he prefers <code>std::string_view</code> over raw null-terminated <code>const char*</code> whenever possible.
</p>
<p>
    Both ways of removing <code>std::string</code> alter the return type of a pure virtual method
    and thus inevitably break every subclass of <code>std::error_category</code> ever. SG14 has no way out of this dilemma
    other than to suggest "wait for <code>std2</code> and do it correctly there."
</p>


<h3><a name="issue-outparams">4.2. Proliferation of "two-API" libraries</a></h3>

<p>
    <code>&lt;filesystem&gt;</code> is the poster child for this issue. Every function and method in <code>&lt;filesystem&gt;</code>
    comes in two flavors: throwing and non-throwing. The throwing version gets the "natural" signature (as is right and expected
    in C++); and the non-throwing version gets a signature with an extra out-parameter of type <code>std::error_code&</code>.
    The expectation is apparently that <code>&lt;system_error&gt;</code> users will be willing to write "C-style" code:
    <pre>
        namespace fs = std::filesystem;
        void truncate_if_large(const fs::path& p) noexcept
        {
            std::error_code ec;  // declare an uninitialized variable
            uintmax_t oldsize = fs::file_size(p, ec);
            if (ec) { report_error(ec); return; }
            if (oldsize > 1000) {
                fs::resize_file(p, 1000, ec);
                if (ec) { report_error(ec); return; }
            }
        }
    </pre>
</p>

<p>
    It would be nicer if the non-throwing API had exactly the same signatures as the throwing API, except that it should
    return <code>expected&lt;T&gt;</code> or <code>result&lt;T&gt;</code> instead of <code>T</code>. On the telecon,
    Arthur O'Dwyer commented that this can't easily be done because you cannot have two functions with the same name
    and the same signature, differing only in return type.
</p>
<p>
    It is possible to segregate the <i>free functions</i> into a separate namespace, say <code>namespace std::filesystem::nothrow</code>,
    so that the above code could be written as
    <pre>
        namespace fs = std::filesystem::nothrow;  // hypothetical
        void truncate_if_large(const fs::path& p) noexcept
        {
            auto oldsize = fs::file_size(p);
            if (!oldsize.has_value()) { report_error(oldsize.error()); return; }
            if (oldsize.value() > 1000) {
                auto failure = fs::resize_file(p, 1000);
                if (failure) { report_error(failure.error()); return; }
            }
        }
    </pre>
    However, this doesn't help with member functions, such as <code>directory_entry::is_symlink()</code>.
</p>

<p>
    Having two APIs (throwing and non-throwing) side by side in the same namespace has another disadvantage.
    There is a significant risk that the programmer might accidentally leave off the out-parameter that signifies
    "non-throwing-ness", resulting in a call to the throwing version when a call to the non-throwing version was
    intended.
    <pre>
        namespace fs = std::filesystem;
        void truncate_if_large(const fs::path& p) noexcept
        {
            std::error_code ec;  // declare an uninitialized variable
            uintmax_t oldsize = fs::file_size(p, ec);
            if (ec) { report_error(ec); return; }
            if (oldsize > 1000) {
                fs::resize_file(p, 1000);  // Oops! Bug goes undetected by all major vendors.
                if (ec) { report_error(ec); return; }
            }
        }
    </pre>
    Therefore, segregating throwing from non-throwing functions is desirable. But we don't know how to make
    segregation work for member functions. Therefore perhaps the <i>best</i> outcome would be to stick with
    a single (non-throwing) API for each library.
</p>
<p>
    If we had a single (non-throwing) API that returned something like <code>Expected&lt;T&gt;</code>, and if
    <code>Expected&lt;T&gt;</code> had a member function <code>T or_throw()</code> that returned the
    <code>ex.value()</code> if possible or else threw a <code>system_error</code> initialized from <code>ex.error()</code>,
    then we could write exception-throwing code fluently as follows:
    <pre>
        namespace fs = std::filesystem::nothrow;
        void truncate_if_large(const fs::path& p) noexcept
        {
            uintmax_t oldsize = fs::file_size(p).or_throw();
            if (oldsize > 1000) {
                fs::resize_file(p, 1000).or_throw();
            }
        }
    </pre>
    Here we assume that the template class <code>Expected&lt;void&gt;</code> is marked with the standard
    <code>[[nodiscard]]</code> attribute, so that if the programmer accidentally leaves off the final <code>or_throw()</code>
    the compiler will emit a warning.
</p>

<p>
    SG14 seems not to have a great answer for how to avoid "two-API" libraries such as <code>&lt;filesystem&gt;</code>
    going forward; but we believe that "two-API" libraries should be avoided. The Networking TS seems to be shaping up
    to be another "two-API" library. We believe this is unfortunate.
</p>


<h3><a name="issue-bool">4.3. No wording sets aside the <code>0</code> enumerator</a></h3>

<p>
    The current Standard strongly implies the best-practice mentioned above: that every error-code-enumerator and
    every error-condition-enumerator should set aside <code>success = 0</code> as a special case.
    <pre>
        enum class TroublesomeCode { out_of_memory, out_of_files };
        struct TroublesomeCategory : public std::error_category {
            const char *name() const noexcept override { return ""; }
            std::string message(int e) const override {
                switch (e) {
                    case TroublesomeCode::out_of_memory: return "out of memory";
                    case TroublesomeCode::out_of_files: return "out of files";
                    default: __builtin_unreachable();
                }
            }
        };
        const std::error_category& troublesome_category() {
            static const TroublesomeCategory instance;
            return instance;
        }

        template<> struct std::is_error_code_enum&lt;TroublesomeCode&gt; : std::true_type {};
        std::error_code make_error_code(TroublesomeCode e) {
            return std::error_code((int)e, troublesome_category());
        }

        int main() {
            std::error_code ec = TroublesomeCode::out_of_memory;
            if (ec) {
                puts("This line will not be printed.");
            }
        }
    </pre>
    SG14 would like to see some explicit acknowledgment in the Standard that error-code enumerators with value <code>0</code>
    are "special," i.e., they will not be treated as "errors" by any of the machinery in the Standard. Error codes with
    value <code>0</code> are effectively reserved for the "success" case, and programmers should not attempt to use them
    for any other purpose.
</p>
<p>
    Vice versa, programmers should be aware that using a non-zero integer value to represent "success" will not work as expected.
    Consider an HTTP library that naively attempts to use <code>ok = 200</code> as its "success" code, and then provides an
    ADL <code>make_error_code</code> like this:
    <pre>
        enum class HTTPStatusCode { ok = 200, created = 201, /* ... */ };

        template<> struct std::is_error_code_enum&lt;HTTPStatusCode&gt; : std::true_type {};
        std::error_code make_error_code(HTTPStatusCode e) {
            return std::error_code((e == ok) ? 0 : (int)e, http_status_category());
        }

        std::string HTTPStatusCategory::message(int e) const {
            switch (e) {
                case 0: return "200 OK";
                case 201: return "201 Created";
                // ...
            }
        }
    </pre>
    The programmer may head far down this "garden path" under the assumption that his goal of a non-zero "ok" code is attainable;
    but we on the Committee know that it is <i>not</i> attainable. We should save the programmer some time and some headaches,
    by explicitly reserving error-code <code>0</code> in the standard.
</p>


<h3><a name="issue-singletons">4.4 Reliance on singletons</a></h3>
<h3><a name="issue-constexpr">4.5 No <code>error_category</code> subclass can be a literal type</a></h3>
<h3><a name="issue-metadata">4.6 No guidance on attaching extra information to <code>error_code</code></a></h3>



</body>
</html>
