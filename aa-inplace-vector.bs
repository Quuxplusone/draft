<pre class='metadata'>
Title: Resolve inconsistencies in begin/end for <code>valarray</code> and braced initializer lists
Shortname: Dxxxx
Revision: 0
!Draft Revision: 1
Audience: LEWG
Status: D
Group: WG21
URL:
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  Allocator-aware `inplace_vector`.
Date: 2024-08-19
</pre>

<style>
hilite  {background-color: #FFFF00; font-weight: bold;}
ins     {background-color: #CCFFCC; text-decoration: underline;}
del     {background-color: #FFCACA; text-decoration: line-through;}
p       {-moz-hyphens: none; -ms-hyphens: none; -webkit-hyphens: none; hyphens: none;}
p.p     {margin: 0em 2em 0.5em 2em;}
</style>

# Changelog # {#changelog}

- R0:

    - Initial revision.


# Motivation and proposal # {#proposal}

We propose that `inplace_vector` should support an allocator parameter.

(1) This permits it to interoperate with allocator-extended client code. For example:

<table>
<tr>
<td colspan="2">
```cpp
template<class Ctr, class... Args>
Ctr f(Args... args) {
  using Alloc = typename Ctr::allocator_type;
  Alloc alloc(args...);
  return Ctr(alloc);
}
```
</td>
</tr>
<tr>
<td>
<pre>
auto v1 = f&lt;std::vector&lt;int>>();
<del>auto v2 = f&lt;std::inplace_vector&lt;int, 10>>();</del>
</pre>
</td>
<td>
<pre>
auto v1 = f&lt;std::vector&lt;int>>();
<ins>auto v2 = f&lt;std::inplace_vector&lt;int, 10>>();</ins>
</pre>
</td>
</tr>
</table>

(2) This permits using `inplace_vector` with a PMR allocator. The vector's elements are still
allocated directly in-place inside the memory footprint of the `inplace_vector` object, but
the elements *in turn* are constructed with allocator-extended construction.
Without allocator-awareness, the code is cumbersome and error-prone. Notice that neither
snippet below uses the global heap.

<table>
<tr>
<td colspan="2">
<pre>
std::pmr::set_default_resource(nullptr);
char buf[10'000];
std::pmr::monotonic_buffer_resource mr(buf, 10'000);
</pre>
</td>
</tr>
<tr>
<td>
<pre>
std::inplace_vector&lt;std::pmr::string, 10> pv;
const char *contents[] = {
  "A string so long that it requires heap allocation",
  "A short string",
};
<del>for (const char *p : contents) {</del>
  <del>pv.emplace_back(p, &amp;mr);</del>
<del>}</del>
pv.emplace_back("A string so long that it requires heap allocation", <del>&amp;mr</del>);
</pre>
</td>
<td>
<pre>
std::pmr::inplace_vector&lt;std::pmr::string, 10> pv(&amp;mr);
const char *contents[] = {
  "A string so long that it requires heap allocation",
  "A short string",
};
<ins>pv.insert(contents.begin(), contents.end());</ins>
pv.emplace_back("A string so long that it requires heap allocation");
</pre>
</td>
</tr>
</table>

(3) This permits using `inplace_vector` with a Boost.Interprocess allocator,
with the same benefits as the PMR example above: less code to write, and
fewer chances to write bugs by accident.
See <a href="https://quuxplusone.github.io/blog/2024/08/23/boost-interprocess-tutorial/">"Boost.Interprocess, and `sg14::inplace_vector`"</a> (2024-08-23).

(4) This gives the programmer control over the `size_type` and `difference_type` members
of `inplace_vector`, permitting a predictably smaller (or larger) memory footprint.
(<a href="https://godbolt.org/z/x1Mxnhb1h">The same example on Godbolt.</a>)
Now, STL vendors *could* implement memory-footprint optimizations to store the `size` member
in fewer bits when `N` was small; but we have seen from our experience with `variant`
that vendors do not do such optimizations in practice, and then get locked out of them
forever by ABI. Giving control to the programmer is more general *and* reduces the
STL vendor's own workload.

<table>
<tr>
<td>
<pre>
<br><br><br><br><br><br><br><br>
static_assert(sizeof(std::inplace_vector&lt;char, 3>) == 16);
</pre>
</td>
<td>
<pre>
namespace Tiny {
  template&lt;class T>
  struct Alloc {
    using value_type = T;
    using size_type = uint8_t;
  };
  template&lt;class T, size_t N>
  using inplace_vector = std::inplace_vector&lt;T, N, Tiny::Alloc&lt;T>>;
}
static_assert(sizeof(std::inplace_vector&lt;char, 3>) == 16);
<ins>static_assert(sizeof(Tiny::inplace_vector&lt;char, 3>) == 4);</ins>
</pre>
</td>
</tr>
</table>


# Implementation experience # {#experience}

Arthur has implemented [[#wording]] in [[QuuxplusoneSG14]]. This includes extensive
unit tests verifying that:

- The proposed `inplace_vector<T, N, std::allocator<T>>` is an exact drop-in replacement
    for the original `inplace_vector<T, N>`, with all the same properties w.r.t.
    sizeof, alignof, triviality, and noexcept.

- The proposed `inplace_vector<T, N, Alloc>` works correctly with `std::pmr::polymorphic_allocator<T>`.

- The proposed `inplace_vector<T, N, Alloc>` works correctly with Boost.Interprocess.

- The proposed `inplace_vector<T, N, Alloc>` works correctly with the `Tiny::Alloc<T>` depicted above.


# Proposed wording # {#wording}

Note: Since `inplace_vector` hasn't shipped yet, we needn't add a feature-test macro for this refinement of the facility.
But if LWG wants to bump the value of `__cpp_lib_inplace_vector` from `202406L` to `YYYYMML`, we won't object.

Modify <a href="https://eel.is/c++draft/inplace.vector">[inplace.vector]</a> as follows:

<small><blockquote>
<p><b>24.3.14 Class template `inplace_vector` [inplace.vector]</b>
<p><b>24.3.14.1 Overview [inplace.vector.overview]</b>
<p>1․ An `inplace_vector` is a contiguous container. Its capacity is fixed and its elements are stored within the `inplace_vector` object itself.
<p>2․ An `inplace_vector` meets all of the requirements of a container ([container.reqmts]), of a reversible container ([container.rev.reqmts]),
of a contiguous container, and of a sequence container, including most of the optional sequence container requirements ([sequence.reqmts]).
The exceptions are the `push_front`, `prepend_range`, `pop_front`, and `emplace_front` member functions, which are not provided.
Descriptions are provided here only for operations on `inplace_vector` that are not described in one of these tables or for operations where there is additional semantic information.
<p>3․ For any `N`, `inplace_vector<T, N>::iterator` and `inplace_vector<T, N>::const_iterator` meet the constexpr iterator requirements.
<p>4․ For any `N` > 0, if `is_trivial_v<T>` is `false`, then no `inplace_vector<T, N>` member functions are usable in constant expressions.
<p>5․ Any member function of `inplace_vector<T, N>` that would cause the size to exceed `N` throws an exception of type `bad_alloc`.
<p>6․ Let `IV` denote a specialization of `inplace_vector<T, N>`. If `N` is zero, then `IV` is both trivial and empty. Otherwise:
<ul>
  <li>(6.1) If `is_trivially_copy_constructible_v<T>` is `true`, then `IV` has a trivial copy constructor.</li>
  <li>(6.2) If `is_trivially_move_constructible_v<T>` is `true`, then `IV` has a trivial move constructor.</li>
  <li>(6.3) If `is_trivially_destructible_v<T>` is `true`, then:
  <ul>
    <li>(6.3.1) `IV` has a trivial destructor.</li>
    <li>(6.3.2) If `is_trivially_copy_constructible_v<T> && is_trivially_copy_assignable_v<T>` is `true`, then `IV` has a trivial copy assignment operator.</li>
    <li>(6.3.3) If `is_trivially_move_constructible_v<T> && is_trivially_move_assignable_v<T>` is `true`, then `IV` has a trivial move assignment operator.</li>
  </ul></li>
</ul>

<p><pre>
namespace std {
  template&lt;class T, size_t N>
  class inplace_vector {
  public:
    <i>// types:</i>
    using value_type             = T;
    using pointer                = T*;
    using const_pointer          = const T*;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;
    using iterator               = <i>implementation-defined</i>; // see [container.requirements]
    using const_iterator         = <i>implementation-defined</i>; // see [container.requirements]
    using reverse_iterator       = std::reverse_iterator&lt;iterator>;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator>;
&nbsp;
    <i>// [inplace.vector.cons], construct/copy/destroy</i>
    constexpr inplace_vector() noexcept;
    constexpr explicit inplace_vector(size_type n);                         // freestanding-deleted
    constexpr inplace_vector(size_type n, const T& value);                  // freestanding-deleted
    template&lt;class InputIterator>
      constexpr inplace_vector(InputIterator first, InputIterator last);    // freestanding-deleted
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr inplace_vector(from_range_t, R&& rg);                       // freestanding-deleted
    constexpr inplace_vector(const inplace_vector&);
    constexpr inplace_vector(inplace_vector&&)
      noexcept(N == 0 || is_nothrow_move_constructible_v&lt;T>);
    constexpr inplace_vector(initializer_list&lt;T> il);                       // freestanding-deleted
    constexpr ~inplace_vector();
    constexpr inplace_vector& operator=(const inplace_vector& other);
    constexpr inplace_vector& operator=(inplace_vector&& other)
      noexcept(N == 0 || (is_nothrow_move_assignable_v&lt;T> &&
                          is_nothrow_move_constructible_v&lt;T>));
    constexpr inplace_vector& operator=(initializer_list&lt;T>);               // freestanding-deleted
    template&lt;class InputIterator>
      constexpr void assign(InputIterator first, InputIterator last);       // freestanding-deleted
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr void assign_range(R&& rg);                                  // freestanding-deleted
    constexpr void assign(size_type n, const T& u);                         // freestanding-deleted
    constexpr void assign(initializer_list&lt;T> il);                          // freestanding-deleted
&nbsp;
    <i>// iterators</i>
    constexpr iterator               begin()         noexcept;
    constexpr const_iterator         begin()   const noexcept;
    constexpr iterator               end()           noexcept;
    constexpr const_iterator         end()     const noexcept;
    constexpr reverse_iterator       rbegin()        noexcept;
    constexpr const_reverse_iterator rbegin()  const noexcept;
    constexpr reverse_iterator       rend()          noexcept;
    constexpr const_reverse_iterator rend()    const noexcept;
&nbsp;
    constexpr const_iterator         cbegin()  const noexcept;
    constexpr const_iterator         cend()    const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend()   const noexcept;
&nbsp;
    <i>// [inplace.vector.capacity] size/capacity</i>
    constexpr bool empty() const noexcept;
    constexpr size_type size() const noexcept;
    static constexpr size_type max_size() noexcept;
    static constexpr size_type capacity() noexcept;
    constexpr void resize(size_type sz);                                    // freestanding-deleted
    constexpr void resize(size_type sz, const T& c);                        // freestanding-deleted
    static constexpr void reserve(size_type n);                             // freestanding-deleted
    static constexpr void shrink_to_fit() noexcept;
&nbsp;
    <i>// element access</i>
    constexpr reference       operator[](size_type n);
    constexpr const_reference operator[](size_type n) const;
    constexpr reference       at(size_type n);                              // freestanding-deleted
    constexpr const_reference at(size_type n) const;                        // freestanding-deleted
    constexpr reference       front();
    constexpr const_reference front() const;
    constexpr reference       back();
    constexpr const_reference back() const;
&nbsp;
    <i>// [inplace.vector.data], data access</i>
    constexpr       T* data()       noexcept;
    constexpr const T* data() const noexcept;
&nbsp;
    <i>// [inplace.vector.modifiers], modifiers</i>
    template&lt;class... Args>
      constexpr reference emplace_back(Args&&... args);                     // freestanding-deleted
    constexpr reference push_back(const T& x);                              // freestanding-deleted
    constexpr reference push_back(T&& x);                                   // freestanding-deleted
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr void append_range(R&& rg);                                  // freestanding-deleted
    constexpr void pop_back();
&nbsp;
    template&lt;class... Args>
      constexpr pointer try_emplace_back(Args&&... args);
    constexpr pointer try_push_back(const T& x);
    constexpr pointer try_push_back(T&& x);
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr ranges::borrowed_iterator_t&lt;R> try_append_range(R&& rg);
&nbsp;
    template&lt;class... Args>
      constexpr reference unchecked_emplace_back(Args&&... args);
    constexpr reference unchecked_push_back(const T& x);
    constexpr reference unchecked_push_back(T&& x);
&nbsp;
    template&lt;class... Args>
      constexpr iterator emplace(const_iterator position, Args&&... args);  // freestanding-deleted
    constexpr iterator insert(const_iterator position, const T& x);         // freestanding-deleted
    constexpr iterator insert(const_iterator position, T&& x);              // freestanding-deleted
    constexpr iterator insert(const_iterator position, size_type n,         // freestanding-deleted
                              const T& x);
    template&lt;class InputIterator>
      constexpr iterator insert(const_iterator position,                    // freestanding-deleted
                                InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr iterator insert_range(const_iterator position, R&& rg);     // freestanding-deleted
    constexpr iterator insert(const_iterator position,                      // freestanding-deleted
                              initializer_list&lt;T> il);
    constexpr iterator erase(const_iterator position);
    constexpr iterator erase(const_iterator first, const_iterator last);
    constexpr void swap(inplace_vector& x)
      noexcept(N == 0 || (is_nothrow_swappable_v&lt;T> &&
                          is_nothrow_move_constructible_v&lt;T>));
    constexpr void clear() noexcept;
&nbsp;
    constexpr friend bool operator==(const inplace_vector& x,
                                     const inplace_vector& y);
    constexpr friend <i>synth-three-way-result</i>&lt;T>
      operator&lt;=>(const inplace_vector& x, const inplace_vector& y);
    constexpr friend void swap(inplace_vector& x, inplace_vector& y)
      noexcept(N == 0 || (is_nothrow_swappable_v&lt;T> &&
                          is_nothrow_move_constructible_v&lt;T>))
      { x.swap(y); }
  };
};
</pre>

<p><b>24.3.14.2. Constructors [inplace.vector.cons]</b>
<p><pre>
constexpr explicit inplace_vector(size_type n);
</pre>
<p class="p">1․ *Preconditions:* `T` is <i>`Cpp17DefaultInsertable`</i> into `inplace_vector`.
<p class="p">2․ *Effects:* Constructs an `inplace_vector` with `n` default-inserted elements.
<p class="p">3․ *Complexity:* Linear in `n`.
<p><pre>
constexpr inplace_vector(size_type n, const T& value);
</pre>
<p class="p">4․ *Preconditions:* `T` is <i>`Cpp17CopyInsertable`</i> into `inplace_vector`.
<p class="p">5․ *Effects:* Constructs an `inplace_vector` with `n` copies of `value`.
<p class="p">6․ *Complexity:* Linear in `n`.
<p><pre>
template&lt;class InputIterator>
  constexpr inplace_vector(InputIterator first, InputIterator last);
</pre>
<p class="p">7․ *Effects:* Constructs an `inplace_vector` equal to the range `[first, last)`.
<p class="p">8․ *Complexity:* Linear in `distance(first, last)`.
<p><pre>
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr inplace_vector(from_range_t, R&& rg);
</pre>
<p class="p">9․ *Effects:* Constructs an `inplace_vector` object with the elements of the range `rg`.
<p class="p">10․ *Complexity:* Linear in `ranges::distance(rg)`.

<p><b>24.3.14.3 Size and capacity [inplace.vector.capacity]</b>
<p><pre>
static constexpr size_type capacity() noexcept;
static constexpr size_type max_size() noexcept;
</pre>
<p class="p">1․ *Returns:* `N`.
<p><pre>
constexpr void resize(size_type sz);
</pre>
<p class="p">2․ *Preconditions:* `T` is <i>`Cpp17DefaultInsertable`</i> into inplace_vector.
<p class="p">3․ *Effects:* If `sz < size()`, erases the last `size() - sz` elements from the sequence. Otherwise, appends `sz - size()` default-inserted elements to the sequence.
<p class="p">4․ *Remarks:* If an exception is thrown, there are no effects on `*this`.
<p><pre>
constexpr void resize(size_type sz, const T& c);
</pre>
<p class="p">5․ *Preconditions:* `T` is <i>`Cpp17CopyInsertable`</i> into `inplace_vector`.
<p class="p">6․ *Effects:* If `sz < size()`, erases the last `size() - sz` elements from the sequence. Otherwise, appends `sz - size()` copies of `c` to the sequence.
<p class="p">7․ *Remarks:* If an exception is thrown, there are no effects on `*this`.

<p><b>24.3.14.4 Data [inplace.vector.data]</b>
<p><pre>
constexpr       T* data()       noexcept;
constexpr const T* data() const noexcept;
</pre>
<p class="p">1․ *Returns:* A pointer such that [`data()`, `data() + size()`) is a valid range.
For a non-empty `inplace_vector`, <nobr>`data() == addressof(front())`</nobr> is `true`.
<p class="p">2․ *Complexity:* Constant time.

<p><b>24.3.14.5 Modifiers [inplace.vector.modifiers]</b>
<p><pre>
constexpr iterator insert(const_iterator position, const T& x);
constexpr iterator insert(const_iterator position, T&& x);
constexpr iterator insert(const_iterator position, size_type n, const T& x);
template&lt;class InputIterator>
  constexpr iterator insert(const_iterator position, InputIterator first, InputIterator last);
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr iterator insert_range(const_iterator position, R&& rg);
constexpr iterator insert(const_iterator position, initializer_list&lt;T> il);
&nbsp;
template&lt;class... Args>
  constexpr iterator emplace(const_iterator position, Args&&... args);
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr void append_range(R&& rg);
</pre>
<p class="p">1․ Let `n` be value of `size()` before this call for the `append_range` overload, and `distance(begin, position)` otherwise.
<p class="p">2․ *Complexity:* Linear in the number of elements inserted plus the distance to the end of the vector.
<p class="p">3․ *Remarks:* If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or
move assignment operator of `T` or by any `InputIterator` operation, there are no effects.
Otherwise, if an exception is thrown, then `size()` ≥ `n` and elements in the range `begin()` + [`0`, `n`) are not modified.
<p><pre>
constexpr reference push_back(const T& x);
constexpr reference push_back(T&& x);
template&lt;class... Args>
  constexpr reference emplace_back(Args&&... args);
</pre>
<p class="p">4․ *Returns:* `back()`.
<p class="p">5․ *Throws:* `bad_alloc` or any exception thrown by initialization of inserted element.
<p class="p">6․ *Complexity:* Constant.
<p class="p">7․ *Remarks:* If an exception is thrown, there are no effects on `*this`.
<p><pre>
template&lt;class... Args>
  constexpr pointer try_emplace_back(Args&&... args);
constexpr pointer try_push_back(const T& x);
constexpr pointer try_push_back(T&& x);
</pre>
<p class="p"> 8․ Let `vals` denote a pack:
<ul>
  <li>(8.1) `std::forward<Args>(args)...` for the first overload,</li>
  <li>(8.2) `x` for the second overload,</li>
  <li>(8.3) `std::move(x)` for the third overload.</li>
</ul>
<p class="p">9․ *Preconditions:* `value_type` is <i>`Cpp17EmplaceConstructible`</i> into `inplace_vector` from `vals...`.
<p class="p">10․ *Effects:* If `size() < capacity()` is `true`, appends an object of type `T` direct-non-list-initialized with `vals...`. Otherwise, there are no effects.
<p class="p">11․ *Returns:* `nullptr` if `size() == capacity()` is `true`, otherwise `addressof(back())`.
<p class="p">12․ *Throws:* Nothing unless an exception is thrown by initialization of inserted element.
<p class="p">13․ *Complexity:* Constant.
<p class="p">14․ *Remarks:* If an exception is thrown, there are no effects on `*this`.
<p><pre>
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr ranges::borrowed_iterator_t&lt;R> try_append_range(R&& rg);
</pre>
<p class="p">15․ *Preconditions:* `value_type` is <i>`Cpp17EmplaceConstructible`</i> into `inplace_vector` from `*ranges::begin(rg)`.
<p class="p">16․ *Effects:* Appends copies of initial elements in `rg` before `end()`, until all elements are inserted or `size() == capacity() is true`.
Each iterator in the range `rg` is dereferenced at most once.
<p class="p">17․ *Returns:* An iterator pointing to the first element of `rg` that was not inserted into `*this`, or `ranges::end(rg)` if no such element exists.
<p class="p">18․ *Complexity:* Linear in the number of elements inserted.
<p class="p">19․ *Remarks:* Let `n` be the value of `size()` prior to this call. If an exception is thrown after the insertion of `k` elements, then `size()` equals `n+k`,
elements in the range `begin()` + [`0`, `n`) are not modified, and elements in the range `begin()` + [`n`, `n+k`) correspond to the inserted elements.
<p><pre>
template&lt;class... Args>
  constexpr reference unchecked_emplace_back(Args&&... args);
</pre>
<p class="p">20․ *Preconditions:* `size() < capacity()` is `true`.
<p class="p">21․ *Effects:* Equivalent to: `return *try_emplace_back(std::forward&lt;Args>(args)...);`
<p><pre>
constexpr reference unchecked_push_back(const T& x);
constexpr reference unchecked_push_back(T&& x);
</pre>
<p class="p">22․ *Preconditions:* `size() < capacity()` is `true`.
<p class="p">23․ *Effects:* Equivalent to: `return *try_push_back(std::forward&lt;decltype(x)>(x));`
<p><pre>
static constexpr void reserve(size_type n);
</pre>
<p class="p">24․ *Effects:* None.
<p class="p">25․ *Throws:* `bad_alloc` if `n > capacity()` is `true`.
<p><pre>
static constexpr void shrink_to_fit() noexcept;
</pre>
<p class="p">26․ *Effects:* None.
<p><pre>
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_back();
</pre>
<p class="p">27․ *Effects:* Invalidates iterators and references at or after the point of the erase.
<p class="p">28․ *Throws:* Nothing unless an exception is thrown by the assignment operator or move assignment operator of `T`.
<p class="p">29․ *Complexity:* The destructor of `T` is called the number of times equal to the number of the elements erased,
but the assignment operator of `T` is called the number of times equal to the number of elements after the erased elements.

<p><b>24.3.14.6 Erasure [inplace.vector.erasure]</b>
<p><pre>
template&lt;class T, size_t N, class U = T>
  constexpr size_t erase(inplace_vector&lt;T, N>& c, const U& value);
</pre>
<p class="p">1․ *Effects:* Equivalent to:
<div style="margin: 0.5em 2em;"><pre>
    auto it = remove(c.begin(), c.end(), value);
    auto r = distance(it, c.end());
    c.erase(it, c.end());
    return r;
</pre></div>
<p><pre>
template&lt;class T, size_t N, class Predicate>
  constexpr size_t erase_if(inplace_vector&lt;T, N>& c, Predicate pred);
</pre>
<p class="p">2․ *Effects:* Equivalent to:
<div style="margin: 0.5em 2em;"><pre>
    auto it = remove_if(c.begin(), c.end(), pred);
    auto r = distance(it, c.end());
    c.erase(it, c.end());
    return r;
</pre></div>
</blockquote>
</small>

<pre class=biblio>
{
  "CWG2825": {
    "title": "Range-based for statement using a braced-init-list",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://cplusplus.github.io/CWG/issues/2825.html",
    "date": "November 2023"
  },
  "P2613": {
    "title": "Add the missing empty to mdspan",
    "authors": [
      "Yihe Li"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2613r1.html",
    "date": "June 2022"
  },
  "QuuxplusoneSG14": {
    "title": "Quuxplusone/SG14: Allocator-aware in-place vector (future > C++20)",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://github.com/Quuxplusone/SG14?tab=readme-ov-file#allocator-aware-in-place-vector-future--c20",
    "date": "August 2024"
  }
}
</pre>
