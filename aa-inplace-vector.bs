<pre class='metadata'>
Title: Allocator-aware <code>inplace_vector</code>
Shortname: Dxxxx
Revision: 0
!Draft Revision: 2
Audience: LEWG
Status: D
Group: WG21
URL:
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  We make `inplace_vector` an allocator-aware container, and make `allocator` partially freestanding.
Date: 2024-08-26
</pre>

<style>
hilite  {background-color: #FFFF00; font-weight: bold;}
ins     {background-color: #CCFFCC; text-decoration: underline;}
del     {background-color: #FFCACA; text-decoration: line-through;}
p       {-moz-hyphens: none; -ms-hyphens: none; -webkit-hyphens: none; hyphens: none;}
p.p     {margin: 0em 2em 0.5em 2em;}
</style>

# Changelog # {#changelog}

- R0:

    - Initial revision.


# Motivation and proposal # {#proposal}

[[P0843]] introduced `inplace_vector<T, N>` to the C++26 working draft.
We propose that `inplace_vector` should support an allocator parameter, thus allowing it
to use that allocator's `construct` and `destroy` members, even though it never needs to `allocate`.

(1) This permits `inplace_vector` to interoperate with allocator-extended client code. For example:

<table>
<tr>
<td colspan="2">
```cpp
template<class Ctr, class... Args>
Ctr f(Args... args) {
  using Alloc = typename Ctr::allocator_type;
  Alloc alloc(args...);
  return Ctr(alloc);
}
```
</td>
</tr>
<tr>
<td>
<pre>
auto v1 = f&lt;std::vector&lt;int>>();
<del>auto v2 = f&lt;std::inplace_vector&lt;int, 10>>();</del>
</pre>
</td>
<td>
<pre>
auto v1 = f&lt;std::vector&lt;int>>();
<ins>auto v2 = f&lt;std::inplace_vector&lt;int, 10>>();</ins>
</pre>
</td>
</tr>
</table>

(2) This permits using `inplace_vector` with a PMR allocator. The vector's elements are still
allocated directly in-place inside the memory footprint of the `inplace_vector` object, but
the elements *in turn* are constructed with allocator-extended construction.
Without allocator-awareness, the code is cumbersome and error-prone. Notice that neither
snippet below uses the global heap.

<table>
<tr>
<td colspan="2">
<pre>
std::pmr::set_default_resource(nullptr);
char buf[10'000];
std::pmr::monotonic_buffer_resource mr(buf, 10'000);
</pre>
</td>
</tr>
<tr>
<td>
<pre>
std::inplace_vector&lt;std::pmr::string, 10> pv;
const char *contents[] = {
  "A string so long that it requires heap allocation",
  "A short string",
};
<del>for (const char *p : contents) {</del>
  <del>pv.emplace_back(p, &amp;mr);</del>
<del>}</del>
pv.emplace_back("A string so long that it requires heap allocation", <del>&amp;mr</del>);
</pre>
</td>
<td>
<pre>
std::pmr::inplace_vector&lt;std::pmr::string, 10> pv(&amp;mr);
const char *contents[] = {
  "A string so long that it requires heap allocation",
  "A short string",
};
<ins>pv.insert(contents.begin(), contents.end());</ins>
pv.emplace_back("A string so long that it requires heap allocation");
</pre>
</td>
</tr>
</table>

(3) This permits using `inplace_vector` with a Boost.Interprocess allocator,
with the same benefits as the PMR example above: less code to write, and
fewer chances to write bugs by accident.
See <a href="https://quuxplusone.github.io/blog/2024/08/23/boost-interprocess-tutorial/">"Boost.Interprocess, and `sg14::inplace_vector`"</a> (2024-08-23).

(4) This gives the programmer control over the `size_type` and `difference_type` members
of `inplace_vector`, permitting a predictably smaller (or larger) memory footprint.
Now, STL vendors *could* implement memory-footprint optimizations to store the `size` member
in fewer bits when `N` was small; but we have seen from our experience with `variant`
that vendors do not do such optimizations in practice, and then get locked out of them
forever by ABI. Giving control to the programmer is more general *and* reduces the
STL vendor's own workload. (<a href="https://godbolt.org/z/onofT6oMa">Godbolt.</a>)

<table>
<tr>
<td>
<pre>
<br><br><br><br><br><br><br><br>
static_assert(sizeof(std::inplace_vector&lt;char, 3>) == 16);
</pre>
</td>
<td>
<pre>
namespace Tiny {
  template&lt;class T>
  struct Alloc {
    using value_type = T;
    using size_type = uint8_t;
    static T* allocate(size_t) { assert(false); }
    static void deallocate(T*) { assert(false); }
  };
  template&lt;class T, size_t N>
  using inplace_vector = std::inplace_vector&lt;T, N, Tiny::Alloc&lt;T>>;
}
static_assert(sizeof(std::inplace_vector&lt;char, 3>) == 16);
<ins>static_assert(sizeof(Tiny::inplace_vector&lt;char, 3>) == 4);</ins>
</pre>
</td>
</tr>
</table>

## Notes on freestanding ## {#freestanding}

`inplace_vector<T, N>` is freestanding. We don't propose to change that.
But now it's a synonym for `inplace_vector<T, N, allocator<T>>`.
So, `allocator<T>` needs to become freestanding.
Freestanding implementations lack a heap, so `allocator<T>::allocate` becomes
a <i>freestanding-deleted</i> member function (<a href="https://eel.is/c++draft/library#freestanding.item-3">[freestanding.item]/3</a>),
which means that it must be `=delete`'d if not provided by a freestanding implementation.
This is fine because `inplace_vector` doesn't use `allocate` or `deallocate`.

`allocator_traits` is already freestanding in C++23, thanks to Ben Craig's [[P1642]].
But it is UB to instantiate `allocator_traits<A>` unless `A` meets
the allocator requirements (<a href="https://eel.is/c++draft/library#allocator.requirements.general-3.sentence-2">[allocator.requirements]/3</a>),
and the allocator requirements require that `A::allocate` must not be deleted!

We could solve this conundrum in any of the following ways:

- Declare by fiat: "All specializations of `allocator` meet the allocator requirements,
    regardless of whether they provide `allocate` and `deallocate` member functions."
    (But what about program-defined types that derive from `allocator`?)

- Change the effects of `allocator<T>::allocate` to permit it to Do Something Else on
    freestanding implementations. (But this makes it untrustworthy. This is a bad idea.)

- Change the allocator requirements to permit `allocate` and `deallocate` to be missing
    on freestanding implementations (only).

We've chosen the third option, as it has the fewest obvious downsides.
We do not propose to change the allocator requirements on hosted implementations.


# Implementation experience # {#experience}

Arthur has implemented [[#wording]] in [[QuuxplusoneSG14]]. This includes extensive
unit tests verifying that:

- The proposed `inplace_vector<T, N, std::allocator<T>>` is an exact drop-in replacement
    for the original `inplace_vector<T, N>`, with all the same properties w.r.t.
    sizeof, alignof, triviality, and noexcept.

- The proposed `inplace_vector<T, N, Alloc>` works correctly with `std::pmr::polymorphic_allocator<T>`.

- The proposed `inplace_vector<T, N, Alloc>` works correctly with Boost.Interprocess.

- The proposed `inplace_vector<T, N, Alloc>` works correctly with the `Tiny::Alloc<T>` depicted above.

## Notes on allocator propagation ## {#pocma}

The STL uses allocators for allocation/deallocation and for construction/destruction. So the happy path
for STL containers is when the allocator sticks alongside the value of the data pointer (which must be deallocated)
and alongside the lifetimes of the element objects (which must be destroyed).

Containers that store their elements on the heap want POCCA/POCMA/POCS to be `true`: they'll
simply swap the allocator alongside the data pointer.
When POCCA/POCMA/POCS is `false`, those containers are unhappy: their constant-time move operations
become linear-time and throwing, and their `swap` (which refuses to become throwing) requires that the two
allocators be equal, on pain of UB.

`inplace_vector` stores its element objects inside itself, alongside the allocator.
This means that `inplace_vector` wants POCCA/POCMA/POCS to be `false`!
Its move operations *by default* are linear-time. For example, move-assigning into `v1`
from `v2` requires move-assigning each element of `v1` and move-constructing new elements beyond those.
Each element of `v1` is itself an object that was constructed via `allocator_traits<A>::construct(a1, ...)`
and must therefore be destroyed by `allocator_traits<A>::destroy(a1, ...)`. Therefore, as long as `v1` has
any elements, `v1` must never forget about `a1`. When POCCA/POCMA/POCS is `false`, this is easy and natural.
When POCCA/POCMA/POCS is `true`, `inplace_vector` is unhappy: its copy-assignment, move-assignment, and `swap`
require for correctness that the two allocators be equal, on pain of UB.

```cpp
    template<class T>
    struct CountingAlloc {
        using value_type = T;
        std::set<void*> *objs_;
        CountingAlloc(std::set<void*> *objs) : objs_(objs) {}
        bool operator==(const CountingAlloc&) const = default;
        void construct(auto *p, auto&&... args) const {
            assert(objs_->find(p) == objs_->end());
            std::construct_at(p, decltype(args)(args)...);
            objs_->insert(p);
        }
        void destroy(auto *p) const {
            assert(objs_->find(p) != objs_->end());
            std::destroy_at(p);
            objs_->erase(p);
        }
        using propagate_on_container_copy_assignment = std::true_type;
    };

    std::set<void*> mr1, mr2;
    std::inplace_vector<int, 5, CountingAlloc<int>> v1({1}, &mr1);
    std::inplace_vector<int, 5, CountingAlloc<int>> v2({2,3}, &mr2);
    v1 = v2;
      // The above line has UB because POCCA=true and &mr1 != &mr2
    v1.clear(); v2.clear();
    assert(mr1.empty() && mr2.empty());
```

<table>
<tr><th>Operation</th><th>Heap-storage `vector`</th><th>`inplace_vector`</th></tr>
<tr><th>Move construction</th><td>
  Non-allocating and O(1)
</td><td>
  Non-allocating and O(n)
</td></tr>
<tr><th>Copy construction</th><td>
  O(n)
</td><td>
  non-allocating and O(n)
</td></tr>
<tr><th>Move assignment</th><td>
  Non-allocating and O(1) by default.
  If `!POCMA` and `!is_always_equal`, it becomes allocating and O(n)
</td><td>
  Non-allocating and O(n).
  If `POCMA` and `!is_always_equal`, it may have UB
</td></tr>
<tr><th>Copy assignment</th><td>
  O(n)
</td><td>
  Non-allocating and O(n).
  If `POCCA` and `!is_always_equal`, it may have UB
</td></tr>
<tr><th>Swap</th><td>
  Non-allocating, `noexcept`, and O(1).
  If `!POCS` and `!is_always_equal`, it may have UB
</td><td>
  Non-allocating and O(n).
  If `POCS` and `!is_always_equal`, it may have UB
</td></tr>
</table>

We follow the Lakos rule and make each special member function `noexcept(false)` whenever
it may have UB.

Theoretically, we could special-case the preconditions to make it *not* UB to swap two vectors
with unequal propagating allocators *if* one or both vectors are empty — because then
there's no insurmountable physical difficulty with `CountingAlloc`.
However, that idea would complicate the spec, make more work for vendors, and make the UB condition
less legible to users. So we don't do that.


## Notes on noexceptness ## {#noexceptness}

We expect that in practice, STL vendors will take approximately the same approach to noexceptness
which `sg14::inplace_vector` has taken. This approach is:

```cpp
    static constexpr bool CopyCtorIsNoexcept =
        ((std::is_nothrow_copy_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, const T&>::value) || (N == 0)) &&
        sg14::aaipv::propagate_on_container_copy_construction<Alloc>::value;

    static constexpr bool MoveCtorIsNoexcept =
        ((std::is_nothrow_move_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value) || (N == 0));

    static constexpr bool CopyAssignIsNoexcept =
        ((std::is_nothrow_copy_constructible_v<T> &&
          std::is_nothrow_copy_assignable_v<T> &&
          std::is_nothrow_destructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, const T&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
        (std::allocator_traits<Alloc>::is_always_equal::value || !std::allocator_traits<Alloc>::propagate_on_container_copy_assignment::value);

    static constexpr bool MoveAssignIsNoexcept =
        ((std::is_nothrow_move_constructible_v<T> &&
          std::is_nothrow_move_assignable_v<T> &&
          std::is_nothrow_destructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
        (std::allocator_traits<Alloc>::is_always_equal::value || !std::allocator_traits<Alloc>::propagate_on_container_move_assignment::value);

    static constexpr bool SwapIsNoexcept =
        ((std::is_nothrow_swappable_v<T> &&
          std::is_nothrow_move_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
         (std::allocator_traits<Alloc>::is_always_equal::value || !std::allocator_traits<Alloc>::propagate_on_container_swap::value);
```

Here `sg14::aaipv::propagate_on_container_copy_construction<Alloc>` is `true` iff
`select_on_container_copy_construction` is defaulted to simply copy the allocator (which cannot throw);
`sg14::aaipv::has_trivial_construct<Alloc, T, Args...>` is `true` iff `construct(p, args...)` is defaulted
to simply call `std::construct(p, args...)`; and `sg14::aaipv::has_trivial_destroy<Alloc, T>` is `true` iff `destroy(p)` is
defaulted to simply call `std::destroy_at(p)`. STL vendors might reasonably choose to further specialize these
helpers for `std::allocator` and `std::pmr::polymorphic_allocator`.

However, for wording purposes, we can't use these helpers because they aren't standardized: we don't have any
easy way to invoke them in the wording. So our proposed wording assumes that each helper trait is always-`false`,
with the understanding that STL vendors are always allowed to strengthen noexcept guarantees — and we hope that they will do so!

At the same time, we want to provide a *stronger* noexcept guarantee on copy-construction and copy-assignment
than the current draft standard does. In the current draft standard, these assertions are permitted to fail:

```cpp
    struct S { S(const S&) noexcept; S& operator=(const S&) noexcept; ~S(); };
    static_assert(std::is_nothrow_copy_constructible_v<std::inplace_vector<S>>);
    static_assert(std::is_nothrow_copy_assignable_v<std::inplace_vector<S>>);
```

(A real-world example of such an `S` is `std::shared_ptr<int>`.) We don't like this.
Therefore, our updated exception-specifications require that `inplace_vector<T>` be nothrow copy-constructible
and nothrow copy-assignable whenever `T` is, at least when using the default allocator.

Our exception-specifications don't mention the copy/move/equality operations on `Alloc` itself,
because <a href="https://eel.is/c++draft/allocator.requirements">[allocator.requirements]</a> forbids these
operations to throw (on pain of UB).

We expect that at least some STL vendors will make these operations `noexcept` when `N == 0`, as a special case;
but again that idea would complicate the spec, for no obvious benefit to users. So we don't mandate that special case,
leaving it up to the vendor to strengthen the noexcept guarantee if they choose to.


# Proposed wording # {#wording}

## Feature-test macros ## {#wording-ftm}

Since `inplace_vector` hasn't shipped yet, we think we don't need a feature-test macro for its changes.
But if LWG decides we need one, then we should simply bump the value of `__cpp_lib_inplace_vector` from `202406L` to `YYYYMML`.

The changes to make `allocator` partially freestanding, and the corresponding changes
to permit `allocator_traits` to be meaningfully used with a freestanding `allocator`,
should receive a feature-test macro.
We propose simply to bump the value of `__cpp_lib_freestanding_memory` from `202306L` to `YYYYMML`.
This situation seems to fall under [[P2198]]'s subsection labeled "Detect C++20 (or older) feature that is now partially required in freestanding";
but we still don't know what would be the best approach.

## [memory.syn] ## {#wording-memory.syn}

Modify <a href="https://eel.is/c++draft/memory.syn">[memory.syn]</a> as follows:

<small><blockquote>
<pre>
<i>// [default.allocator], the default allocator</i>
template&lt;class T> class allocator;                                              <ins>// partially freestanding</ins>
template&lt;class T, class U>
  constexpr bool operator==(const allocator&lt;T>&, const allocator&lt;U>&) noexcept; <ins>// freestanding</ins>
</pre>
</blockquote></small>

## [default.allocator] ## {#wording-default.allocator}

Modify <a href="https://eel.is/c++draft/default.allocator">[default.allocator]/1</a> as follows:

<small><blockquote>
<pre>
namespace std {
  template&lt;class T> class allocator {
  public:
    using value_type                             = T;
    using size_type                              = size_t;
    using difference_type                        = ptrdiff_t;
    using propagate_on_container_move_assignment = true_type;

    constexpr allocator() noexcept;
    constexpr allocator(const allocator&) noexcept;
    template&lt;class U> constexpr allocator(const allocator&lt;U>&) noexcept;
    constexpr ~allocator();
    constexpr allocator& operator=(const allocator&) = default;

    constexpr T* allocate(size_t n);                              <ins>// freestanding-deleted</ins>
    constexpr allocation_result&lt;T*> allocate_at_least(size_t n);  <ins>// freestanding-deleted</ins>
    constexpr void deallocate(T* p, size_t n);                    <ins>// freestanding-deleted</ins>
  };
}
</pre>
</blockquote></small>

## [allocator.requirements.general] ## {#wording-allocator.requirements.general}

Modify <a href="https://eel.is/c++draft/allocator.requirements.general">[allocator.requirements.general]</a> as follows:

<small><blockquote>
<p>1․ The library describes a standard set of requirements for allocators, which are class-type objects
that encapsulate the information about an allocation model. This information includes the knowledge of
pointer types, the type of their difference, the type of the size of objects in this allocation model,
as well as the memory allocation and deallocation primitives for it. All of the string types ([strings]),
containers ([containers]) (except `array` <del>and `inplace_vector`</del>), string buffers and string streams ([input.output]),
and `match_results` are parameterized in terms of allocators.

<p>[...]

<p>3․ The class template `allocator_traits` ([allocator.traits]) supplies a uniform interface to all allocator types.
This subclause describes the requirements on allocator types and thus on types used to instantiate `allocator_traits`.
A requirement is optional if a default for a given type or expression is specified.
Within the standard library `allocator_traits` template, an optional requirement that is not supplied by an allocator
is replaced by the specified default type or expression.

<p>[...]

<p><pre>
a.allocate(n)
</pre>
<p class="p">35․ *Result:* `XX::pointer`
<p class="p">36․ *Effects:* Memory is allocated for an array of `n` `T` and such an object is created but array elements are not constructed.
<p class="p">[<i>Example 1:</i> When reusing storage denoted by some pointer value `p`, `launder(reinterpret_cast<T*>(new (p) byte[n * sizeof(T)]))`
can be used to implicitly create a suitable array object and obtain a pointer to it. <i>— end example</i>]
<p class="p">37․ *Throws:* `allocate` may throw an appropriate exception.
<p class="p">38․ [<i>Note 3:</i> It is intended that `a.allocate` be an efficient means of allocating a single object of type `T`,
even when `sizeof(T)` is small. That is, there is no need for a container to maintain its own free list. <i>— end note</i>]
<p class="p">39․ *Remarks:* If `n == 0`, the return value is unspecified.
<p class="p"><ins>x․ Default: On freestanding implementations, `(std::unreachable(), XX::pointer())`.
[<i>Note:</i> This default ensures that `allocator<T>` meets the allocator requirements
even though `allocate` is a freestanding deleted function ([freestanding.item]). <i>— end note</i>]</ins>

<p>[...]

<p><pre>
a.deallocate(p, n)
</pre>
<p class="p">47․ *Result:* (not used)
<p class="p">48․ *Preconditions:*
<ul>
<li>(48.1) If `p` is memory that was obtained by a call to `a.allocate_at_least`, let `ret` be the value returned
and `req` be the value passed as the first argument of that call. `p` is equal to `ret.ptr` and `n` is a value
such that `req` ≤ `n` ≤ `ret.count`.</li>
<li>(48.2) Otherwise, `p` is a pointer value obtained from `allocate`. `n` equals the value passed as the first argument
to the invocation of `allocate` which returned `p`.
</ul>
`p` has not been invalidated by an intervening call to `deallocate`.
<p class="p">49․ *Throws:* Nothing.
<p class="p"><ins>x․ *Remarks:* Default: On freestanding implementations, `std::unreachable()`.
[<i>Note:</i> This default ensures that `allocator<T>` meets the allocator requirements
even though `deallocate` is a freestanding deleted function ([freestanding.item]). <i>— end note</i>]</ins>
</blockquote></small>

## [allocator.traits.members] ## {#wording-allocator.traits.members}

Modify <a href="https://eel.is/c++draft/allocator.traits#members">[allocator.traits.members]</a> as follows:

<small><blockquote>
<p><pre>
static constexpr pointer allocate(Alloc& a, size_type n);
</pre>
<p class="p"><ins>x․ *Mandates:* `a.allocate(n)` is well-formed.</ins>
<p class="p">1․ *Returns:* `a.allocate(n)`.
<p><pre>
static constexpr pointer allocate(Alloc& a, size_type n, const_void_pointer hint);
</pre>
<p class="p">2․ *Returns:* `a.allocate(n, hint)` if that expression is well-formed; otherwise, `a.allocate(n)`.
<p><pre>
static constexpr allocation_result&lt;pointer, size_type> allocate_at_least(Alloc& a, size_type n);
</pre>
<p class="p">3․ *Returns:* `a.allocate_at_least(n)` if that expression is well-formed; otherwise, `{a.allocate(n), n}`.
<p><pre>
static constexpr void deallocate(Alloc& a, pointer p, size_type n);
</pre>
<p class="p"><ins>x․ *Mandates:* `a.deallocate(p, n)` is well-formed.</ins>
<p class="p">4․ *Effects:* Calls `a.deallocate(p, n)`.
<p class="p">5․ *Throws:* Nothing.
</blockquote></small>

## [container.alloc.reqmts] ## {#wording-container.alloc.reqmts}

Modify <a href="https://eel.is/c++draft/container.requirements#container.alloc.reqmts">[container.alloc.reqmts]</a> as follows:

<small><blockquote>
<p>1․ Except for `array` <del>and `inplace_vector`</del>, all of the containers defined in [containers], [stacktrace.basic],
[basic.string], and [re.results] meet the additional requirements of an <i>allocator-aware container</i>, as described below.
<p>[...]
</blockquote></small>

## [inplace.vector.syn] ## {#wording-inplace.vector.syn}

Modify <a href="https://eel.is/c++draft/inplace.vector.syn">[inplace.vector.syn]</a> as follows:

<small><blockquote>
<p><b>24.3.7 Header `<inplace_vector>` synopsis [inplace.vector.syn]</b>
<p><pre>
<i>// mostly freestanding</i>
#include &lt;compare>              <i>// see [compare.syn]</i>
#include &lt;initializer_list>     <i>// see [initializer.list.syn]</i>

namespace std {
  <i>// [inplace.vector], class template inplace_vector</i>
  template&lt;class T, size_t N<ins>, class Allocator</ins>> class inplace_vector; <i>// partially freestanding</i>
&nbsp;
  <i>// [inplace.vector.erasure], erasure</i>
  template&lt;class T, size_t N, <ins>class Allocator,</ins> class U = T>
    constexpr typename inplace_vector&lt;T, N<ins>, Allocator</ins>>::size_type
      erase(inplace_vector&lt;T, N<ins>, Allocator</ins>>& c, const U& value);
  template&lt;class T, size_t N, <ins>class Allocator,</ins> class Predicate>
    constexpr typename inplace_vector&lt;T, N<ins>, Allocator</ins>>::size_type
      erase_if(inplace_vector&lt;T, N<ins>, Allocator</ins>>& c, Predicate pred);
}
</pre>
</blockquote></small>

## [inplace.vector] ## {#wording-inplace.vector}

Modify <a href="https://eel.is/c++draft/inplace.vector">[inplace.vector]</a> as follows:

<small><blockquote>
<p><b>24.3.14 Class template `inplace_vector` [inplace.vector]</b>
<p><b>24.3.14.1 Overview [inplace.vector.overview]</b>
<p>1․ An `inplace_vector` is a contiguous container. Its capacity is fixed and its elements are stored within the `inplace_vector` object itself.
<p>2․ An `inplace_vector` meets all of the requirements of a container ([container.reqmts]), of a reversible container ([container.rev.reqmts]),
<ins>of an allocator-aware container ([container.alloc.reqmts]),</ins>
of a contiguous container, and of a sequence container, including most of the optional sequence container requirements ([sequence.reqmts]).
The exceptions are the `push_front`, `prepend_range`, `pop_front`, and `emplace_front` member functions, which are not provided.
Descriptions are provided here only for operations on `inplace_vector` that are not described in one of these tables or for operations where there is additional semantic information.
<p>3․ For any `N`, `inplace_vector<T, N<ins>, allocator&lt;T></ins>>::iterator` and `inplace_vector<T, N<ins>, allocator&lt;T></ins>>::const_iterator`
meet the constexpr iterator requirements.
<p>4․ For any `N` > 0 <ins>and any `Allocator`</ins>, if `is_trivial_v<T>` is `false`,
then no `inplace_vector<T, N<ins>, Allocator</ins>>` member functions are usable in constant expressions.
<p>5․ Any member function of `inplace_vector<T, N<ins>, Allocator</ins>>` that would cause the size to exceed `N` throws an exception of type `bad_alloc`.
<p>6․ Let `IV` denote a specialization of `inplace_vector<T, N<ins>, allocator&lt;T></ins>>`. If `N` is zero, then `IV` is both trivial and empty. Otherwise:
<ul>
  <li>(6.1) If `is_trivially_copy_constructible_v<T>` is `true`, then `IV` has a trivial copy constructor.</li>
  <li>(6.2) If `is_trivially_move_constructible_v<T>` is `true`, then `IV` has a trivial move constructor.</li>
  <li>(6.3) If `is_trivially_destructible_v<T>` is `true`, then:
  <ul>
    <li>(6.3.1) `IV` has a trivial destructor.</li>
    <li>(6.3.2) If `is_trivially_copy_constructible_v<T> && is_trivially_copy_assignable_v<T>` is `true`, then `IV` has a trivial copy assignment operator.</li>
    <li>(6.3.3) If `is_trivially_move_constructible_v<T> && is_trivially_move_assignable_v<T>` is `true`, then `IV` has a trivial move assignment operator.</li>
  </ul></li>
</ul>

<p><pre>
namespace std {
  template&lt;class T, size_t N<ins>, class Allocator = allocator&lt;T></ins>>
  class inplace_vector {
  public:
    <i>// types:</i>
    using value_type             = T;
    <ins>using value_type             = Allocator;</ins>
    using pointer                = <del>T*</del> <ins>typename allocator_traits&lt;Allocator>::pointer</ins>;
    using const_pointer          = <del>const T*</del> <ins>typename allocator_traits&lt;Allocator>::const_pointer</ins>;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = <del>size_t</del> <ins><i>implementation-defined</i></ins>; <ins><i>// see [container.requirements]</i></ins>
    using difference_type        = <del>ptrdiff_t</del> <ins><i>implementation-defined</i></ins>; <ins><i>// see [container.requirements]</i></ins>
    using iterator               = <i>implementation-defined</i>; <i>// see [container.requirements]</i>
    using const_iterator         = <i>implementation-defined</i>; <i>// see [container.requirements]</i>
    using reverse_iterator       = std::reverse_iterator&lt;iterator>;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator>;
&nbsp;
    <i>// [inplace.vector.cons], construct/copy/destroy</i>
    constexpr inplace_vector() noexcept;
    constexpr explicit inplace_vector(size_type n);                         // freestanding-deleted
    constexpr inplace_vector(size_type n, const T& value);                  // freestanding-deleted
    template&lt;class InputIterator>
      constexpr inplace_vector(InputIterator first, InputIterator last);    // freestanding-deleted
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr inplace_vector(from_range_t, R&& rg);                       // freestanding-deleted
    constexpr inplace_vector(const inplace_vector& <ins>rhs</ins>)
      <ins>noexcept(<i>see below</i>)</ins>;
    constexpr inplace_vector(inplace_vector&& <ins>rhs</ins>)
      <del>noexcept(N == 0 || is_nothrow_move_constructible_v&lt;T>)</del> <ins>noexcept(<i>see below</i>)</ins>;
    constexpr inplace_vector(initializer_list&lt;T> il);                       // freestanding-deleted
    constexpr ~inplace_vector();
    constexpr inplace_vector& operator=(const inplace_vector& <del>other</del> <ins>rhs</ins>)
      <ins>noexcept(<i>see below</i>)</ins>;
    constexpr inplace_vector& operator=(inplace_vector&& <del>other</del> <ins>rhs</ins>)
      <del>noexcept(N == 0 || (is_nothrow_move_assignable_v&lt;T> &&</del>
                          <del>is_nothrow_move_constructible_v&lt;T>))</del>
      <ins>noexcept(<i>see below</i>)</ins>;
    constexpr inplace_vector& operator=(initializer_list&lt;T>);               // freestanding-deleted
    template&lt;class InputIterator>
      constexpr void assign(InputIterator first, InputIterator last);       // freestanding-deleted
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr void assign_range(R&& rg);                                  // freestanding-deleted
    constexpr void assign(size_type n, const T& u);                         // freestanding-deleted
    constexpr void assign(initializer_list&lt;T> il);                          // freestanding-deleted
&nbsp;
    <ins><i>// [inplace.vector.cons.alloc], constructors with allocators</i></ins>
    <ins>constexpr explicit inplace_vector(const Allocator&);</ins>
    <ins>constexpr inplace_vector(size_type n, const Allocator&);</ins>                               <ins>// freestanding-deleted</ins>
    <ins>constexpr inplace_vector(size_type n, const T& value, const Allocator&);</ins>               <ins>// freestanding-deleted</ins>
    <ins>template&lt;class InputIterator></ins>
      <ins>constexpr inplace_vector(InputIterator first, InputIterator last, const Allocator&);</ins> <ins>// freestanding-deleted</ins>
    <ins>template&lt;<i>container-compatible-range</i>&lt;T> R></ins>
      <ins>constexpr inplace_vector(from_range_t, R&& rg, const Allocator&);</ins>                    <ins>// freestanding-deleted</ins>
    <ins>constexpr inplace_vector(const inplace_vector&, const Allocator&);</ins>
    <ins>constexpr inplace_vector(inplace_vector&&, const Allocator&);</ins>
    <ins>constexpr inplace_vector(initializer_list&lt;T> il, const Allocator&);</ins>                 <ins>// freestanding-deleted</ins>
&nbsp;
    <i>// iterators</i>
    constexpr iterator               begin()         noexcept;
    constexpr const_iterator         begin()   const noexcept;
    constexpr iterator               end()           noexcept;
    constexpr const_iterator         end()     const noexcept;
    constexpr reverse_iterator       rbegin()        noexcept;
    constexpr const_reverse_iterator rbegin()  const noexcept;
    constexpr reverse_iterator       rend()          noexcept;
    constexpr const_reverse_iterator rend()    const noexcept;
&nbsp;
    constexpr const_iterator         cbegin()  const noexcept;
    constexpr const_iterator         cend()    const noexcept;
    constexpr const_reverse_iterator crbegin() const noexcept;
    constexpr const_reverse_iterator crend()   const noexcept;
&nbsp;
    <i>// [inplace.vector.capacity] size/capacity</i>
    constexpr bool empty() const noexcept;
    constexpr size_type size() const noexcept;
    static constexpr size_type max_size() noexcept;
    static constexpr size_type capacity() noexcept;
    constexpr void resize(size_type sz);                                    // freestanding-deleted
    constexpr void resize(size_type sz, const T& c);                        // freestanding-deleted
    static constexpr void reserve(size_type n);                             // freestanding-deleted
    static constexpr void shrink_to_fit() noexcept;
&nbsp;
    <i>// element access</i>
    constexpr reference       operator[](size_type n);
    constexpr const_reference operator[](size_type n) const;
    constexpr reference       at(size_type n);                              // freestanding-deleted
    constexpr const_reference at(size_type n) const;                        // freestanding-deleted
    constexpr reference       front();
    constexpr const_reference front() const;
    constexpr reference       back();
    constexpr const_reference back() const;
&nbsp;
    <i>// [inplace.vector.data], data access</i>
    constexpr       T* data()       noexcept;
    constexpr const T* data() const noexcept;
&nbsp;
    <i>// [inplace.vector.modifiers], modifiers</i>
    template&lt;class... Args>
      constexpr reference emplace_back(Args&&... args);                     // freestanding-deleted
    constexpr reference push_back(const T& x);                              // freestanding-deleted
    constexpr reference push_back(T&& x);                                   // freestanding-deleted
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr void append_range(R&& rg);                                  // freestanding-deleted
    constexpr void pop_back();
&nbsp;
    template&lt;class... Args>
      constexpr <del>pointer</del> <ins>T*</ins> try_emplace_back(Args&&... args);
    constexpr <del>pointer</del> <ins>T*</ins> try_push_back(const T& x);
    constexpr <del>pointer</del> <ins>T*</ins> try_push_back(T&& x);
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr ranges::borrowed_iterator_t&lt;R> try_append_range(R&& rg);
&nbsp;
    template&lt;class... Args>
      constexpr reference unchecked_emplace_back(Args&&... args);
    constexpr reference unchecked_push_back(const T& x);
    constexpr reference unchecked_push_back(T&& x);
&nbsp;
    template&lt;class... Args>
      constexpr iterator emplace(const_iterator position, Args&&... args);  // freestanding-deleted
    constexpr iterator insert(const_iterator position, const T& x);         // freestanding-deleted
    constexpr iterator insert(const_iterator position, T&& x);              // freestanding-deleted
    constexpr iterator insert(const_iterator position, size_type n,         // freestanding-deleted
                              const T& x);
    template&lt;class InputIterator>
      constexpr iterator insert(const_iterator position,                    // freestanding-deleted
                                InputIterator first, InputIterator last);
    template&lt;<i>container-compatible-range</i>&lt;T> R>
      constexpr iterator insert_range(const_iterator position, R&& rg);     // freestanding-deleted
    constexpr iterator insert(const_iterator position,                      // freestanding-deleted
                              initializer_list&lt;T> il);
    constexpr iterator erase(const_iterator position);
    constexpr iterator erase(const_iterator first, const_iterator last);
    constexpr void swap(inplace_vector& x)
      <del>noexcept(N == 0 || (is_nothrow_swappable_v&lt;T> &&</del>
                          <del>is_nothrow_move_constructible_v&lt;T>))</del>
      <ins>noexcept(<i>see below</i>)</ins>;
    constexpr void clear() noexcept;
&nbsp;
    constexpr friend bool operator==(const inplace_vector& x,
                                     const inplace_vector& y);
    constexpr friend <i>synth-three-way-result</i>&lt;T>
      operator&lt;=>(const inplace_vector& x, const inplace_vector& y);
    constexpr friend void swap(inplace_vector& x, inplace_vector& y)
      <del>noexcept(N == 0 || (is_nothrow_swappable_v&lt;T> &&</del>
                          <del>is_nothrow_move_constructible_v&lt;T>))</del>
      <ins>noexcept(x.swap(y))</ins>
      { x.swap(y); }
  };
};
</pre>

<p><b>24.3.14.2. Constructors [inplace.vector.cons]</b>
<p><pre>
constexpr explicit inplace_vector(size_type n);
</pre>
<p class="p">1․ *Preconditions:* `T` is <i>`Cpp17DefaultInsertable`</i> into `inplace_vector`.
<p class="p">2․ *Effects:* Constructs an `inplace_vector` with `n` default-inserted elements.
<p class="p">3․ *Complexity:* Linear in `n`.
<p><pre>
constexpr inplace_vector(size_type n, const T& value);
</pre>
<p class="p">4․ *Preconditions:* `T` is <i>`Cpp17CopyInsertable`</i> into `inplace_vector`.
<p class="p">5․ *Effects:* Constructs an `inplace_vector` with `n` copies of `value`.
<p class="p">6․ *Complexity:* Linear in `n`.
<p><pre>
template&lt;class InputIterator>
  constexpr inplace_vector(InputIterator first, InputIterator last);
</pre>
<p class="p">7․ *Effects:* Constructs an `inplace_vector` equal to the range `[first, last)`.
<p class="p">8․ *Complexity:* Linear in `distance(first, last)`.
<p><pre>
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr inplace_vector(from_range_t, R&& rg);
</pre>
<p class="p">9․ *Effects:* Constructs an `inplace_vector` object with the elements of the range `rg`.
<p class="p">10․ *Complexity:* Linear in `ranges::distance(rg)`.

<p><pre>
<ins>constexpr inplace_vector(const inplace_vector& rhs)</ins>
  <ins>noexcept(<i>see below</i>);</ins>
</pre>
<p class="p"><ins>11․ *Remarks:* When `allocator_type` is `allocator<value_type>`, the exception specification is equivalent to:</ins>
<div style="margin: 0.5em 2em;"><pre>
<ins>is_nothrow_copy_constructible_v&lt;value_type></ins>
</pre></div>

<p><pre>
<ins>constexpr inplace_vector(inplace_vector&& rhs)</ins>
  <ins>noexcept(<i>see below</i>);</ins>
</pre>
<p class="p"><ins>12․ *Remarks:* When `allocator_type` is `allocator<value_type>`, the exception specification is equivalent to:</ins>
<div style="margin: 0.5em 2em;"><pre>
<ins>is_nothrow_move_constructible_v&lt;value_type></ins>
</pre></div>

<p><pre>
<ins>constexpr inplace_vector& operator=(const inplace_vector& rhs)</ins>
  <ins>noexcept(<i>see below</i>);</ins>
</pre>
<p class="p"><ins>13․ *Preconditions:* `allocator_traits<allocator_type>::propagate_on_container_copy_assignment::value` is `false`
or `rhs.get_allocator() == this->get_allocator()`.</ins>
<p class="p"><ins>14․ *Remarks:* When `allocator_type` is `allocator<value_type>`, the exception specification is equivalent to:</ins>
<div style="margin: 0.5em 2em;"><pre>
<ins>is_nothrow_copy_assignable_v&lt;value_type> && is_nothrow_copy_constructible_v&lt;value_type></ins>
</pre></div>

<p><pre>
<ins>constexpr inplace_vector& operator=(inplace_vector&& rhs)</ins>
  <ins>noexcept(<i>see below</i>);</ins>
</pre>
<p class="p"><ins>15․ *Preconditions:* `allocator_traits<allocator_type>::propagate_on_container_move_assignment::value` is `false`
or `rhs.get_allocator() == this->get_allocator()`.</ins>
<p class="p"><ins>16․ *Remarks:* When `allocator_type` is `allocator<value_type>`, the exception specification is equivalent to:</ins>
<div style="margin: 0.5em 2em;"><pre>
<ins>is_nothrow_move_assignable_v&lt;value_type> && is_nothrow_move_constructible_v&lt;value_type></ins>
</pre></div>

<p><ins><b>24.3.14.x. Constructors with allocators [inplace.vector.cons.alloc]</b></ins>
<p><pre>
<ins>constexpr inplace_vector(const inplace_vector& rhs, const Allocator&);</ins>
</pre>
<p class="p"><ins>1․ *Effects:* Constructs an `inplace_vector` with the elements of `rhs`, using the specified allocator.</ins>
<p class="p"><ins>2․ *Complexity:* Linear in `rhs.size()`.</ins>
<p><pre>
<ins>constexpr inplace_vector(inplace_vector&& rhs, const Allocator&);</ins>
</pre>
<p class="p"><ins>3․ *Effects:* Constructs an `inplace_vector` with the elements that `rhs` had before the construction,
using the specified allocator.</ins>
<p class="p"><ins>4․ *Complexity:* Linear in `rhs.size()`.</ins>

<p><b>24.3.14.3 Size and capacity [inplace.vector.capacity]</b>
<p><pre>
static constexpr size_type capacity() noexcept;
static constexpr size_type max_size() noexcept;
</pre>
<p class="p">1․ *Returns:* `N`.
<p><pre>
constexpr void resize(size_type sz);
</pre>
<p class="p">2․ *Preconditions:* `T` is <i>`Cpp17DefaultInsertable`</i> into `inplace_vector`.
<p class="p">3․ *Effects:* If `sz < size()`, erases the last `size() - sz` elements from the sequence. Otherwise, appends `sz - size()` default-inserted elements to the sequence.
<p class="p">4․ *Remarks:* If an exception is thrown, there are no effects on `*this`.
<p><pre>
constexpr void resize(size_type sz, const T& c);
</pre>
<p class="p">5․ *Preconditions:* `T` is <i>`Cpp17CopyInsertable`</i> into `inplace_vector`.
<p class="p">6․ *Effects:* If `sz < size()`, erases the last `size() - sz` elements from the sequence. Otherwise, appends `sz - size()` copies of `c` to the sequence.
<p class="p">7․ *Remarks:* If an exception is thrown, there are no effects on `*this`.

<p><b>24.3.14.4 Data [inplace.vector.data]</b>
<p><pre>
constexpr       T* data()       noexcept;
constexpr const T* data() const noexcept;
</pre>
<p class="p">1․ *Returns:* A pointer such that [`data()`, `data() + size()`) is a valid range.
For a non-empty `inplace_vector`, <nobr>`data() == addressof(front())`</nobr> is `true`.
<p class="p">2․ *Complexity:* Constant time.

<p><b>24.3.14.5 Modifiers [inplace.vector.modifiers]</b>
<p><pre>
constexpr iterator insert(const_iterator position, const T& x);
constexpr iterator insert(const_iterator position, T&& x);
constexpr iterator insert(const_iterator position, size_type n, const T& x);
template&lt;class InputIterator>
  constexpr iterator insert(const_iterator position, InputIterator first, InputIterator last);
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr iterator insert_range(const_iterator position, R&& rg);
constexpr iterator insert(const_iterator position, initializer_list&lt;T> il);
&nbsp;
template&lt;class... Args>
  constexpr iterator emplace(const_iterator position, Args&&... args);
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr void append_range(R&& rg);
</pre>
<p class="p">1․ Let `n` be value of `size()` before this call for the `append_range` overload, and `distance(begin, position)` otherwise.
<p class="p">2․ *Complexity:* Linear in the number of elements inserted plus the distance to the end of the vector.
<p class="p">3․ *Remarks:* If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or
move assignment operator of `T` or by any `InputIterator` operation, there are no effects.
Otherwise, if an exception is thrown, then `size()` ≥ `n` and elements in the range `begin()` + [`0`, `n`) are not modified.
<p><pre>
constexpr reference push_back(const T& x);
constexpr reference push_back(T&& x);
template&lt;class... Args>
  constexpr reference emplace_back(Args&&... args);
</pre>
<p class="p">4․ *Returns:* `back()`.
<p class="p">5․ *Throws:* `bad_alloc` or any exception thrown by initialization of inserted element.
<p class="p">6․ *Complexity:* Constant.
<p class="p">7․ *Remarks:* If an exception is thrown, there are no effects on `*this`.
<p><pre>
template&lt;class... Args>
  constexpr <del>pointer</del> <ins>T*</ins> try_emplace_back(Args&&... args);
constexpr <del>pointer</del> <ins>T*</ins> try_push_back(const T& x);
constexpr <del>pointer</del> <ins>T*</ins> try_push_back(T&& x);
</pre>
<p class="p"> 8․ Let `vals` denote a pack:
<ul>
  <li>(8.1) `std::forward<Args>(args)...` for the first overload,</li>
  <li>(8.2) `x` for the second overload,</li>
  <li>(8.3) `std::move(x)` for the third overload.</li>
</ul>
<p class="p">9․ *Preconditions:* `value_type` is <i>`Cpp17EmplaceConstructible`</i> into `inplace_vector` from `vals...`.
<p class="p">10․ *Effects:* If `size() < capacity()` is `true`, appends an object of type `T` direct-non-list-initialized with `vals...`. Otherwise, there are no effects.
<p class="p">11․ *Returns:* `nullptr` if `size() == capacity()` is `true`, otherwise `addressof(back())`.
<p class="p">12․ *Throws:* Nothing unless an exception is thrown by initialization of inserted element.
<p class="p">13․ *Complexity:* Constant.
<p class="p">14․ *Remarks:* If an exception is thrown, there are no effects on `*this`.
<p><pre>
template&lt;<i>container-compatible-range</i>&lt;T> R>
  constexpr ranges::borrowed_iterator_t&lt;R> try_append_range(R&& rg);
</pre>
<p class="p">15․ *Preconditions:* `value_type` is <i>`Cpp17EmplaceConstructible`</i> into `inplace_vector` from `*ranges::begin(rg)`.
<p class="p">16․ *Effects:* Appends copies of initial elements in `rg` before `end()`, until all elements are inserted or `size() == capacity() is true`.
Each iterator in the range `rg` is dereferenced at most once.
<p class="p">17․ *Returns:* An iterator pointing to the first element of `rg` that was not inserted into `*this`, or `ranges::end(rg)` if no such element exists.
<p class="p">18․ *Complexity:* Linear in the number of elements inserted.
<p class="p">19․ *Remarks:* Let `n` be the value of `size()` prior to this call. If an exception is thrown after the insertion of `k` elements, then `size()` equals `n+k`,
elements in the range `begin()` + [`0`, `n`) are not modified, and elements in the range `begin()` + [`n`, `n+k`) correspond to the inserted elements.
<p><pre>
template&lt;class... Args>
  constexpr reference unchecked_emplace_back(Args&&... args);
</pre>
<p class="p">20․ *Preconditions:* `size() < capacity()` is `true`.
<p class="p">21․ *Effects:* Equivalent to: `return *try_emplace_back(std::forward<Args>(args)...);`
<p><pre>
constexpr reference unchecked_push_back(const T& x);
constexpr reference unchecked_push_back(T&& x);
</pre>
<p class="p">22․ *Preconditions:* `size() < capacity()` is `true`.
<p class="p">23․ *Effects:* Equivalent to: `return *try_push_back(std::forward<decltype(x)>(x));`
<p><pre>
static constexpr void reserve(size_type n);
</pre>
<p class="p">24․ *Effects:* None.
<p class="p">25․ *Throws:* `bad_alloc` if `n > capacity()` is `true`.
<p><pre>
static constexpr void shrink_to_fit() noexcept;
</pre>
<p class="p">26․ *Effects:* None.
<p><pre>
constexpr iterator erase(const_iterator position);
constexpr iterator erase(const_iterator first, const_iterator last);
constexpr void pop_back();
</pre>
<p class="p">27․ *Effects:* Invalidates iterators and references at or after the point of the erase.
<p class="p">28․ *Throws:* Nothing unless an exception is thrown by the assignment operator or move assignment operator of `T`.
<p class="p">29․ *Complexity:* The destructor of `T` is called the number of times equal to the number of the elements erased,
but the assignment operator of `T` is called the number of times equal to the number of elements after the erased elements.

<p class="note"><b>DRAFTING NOTE:</b>
The *Precondition* element below is modeled on <a href="https://eel.is/c++draft/container.requirements#container.reqmts-65">[container.reqmts]/65</a>.
The exception specification is modeled on <a href="https://eel.is/c++draft/optional.swap#5">[optional.swap]/5</a>.

<p><pre>
<ins>constexpr void swap(inplace_vector& x) noexcept(<i>see below</i>);</ins>
</pre>
<p class="p"><ins>x․ *Effects:* Exchanges the contents of `a` and `b`.</ins>
<p class="p"><ins>x․ *Remarks:* When `allocator_type` is `allocator<value_type>`, the exception specification is equivalent to:</ins>
<div style="margin: 0.5em 2em;"><pre>
<ins>is_nothrow_swappable_v&lt;value_type> && is_nothrow_move_constructible_v&lt;value_type></ins>
</pre></div>
<p class="p"><ins>x․
If `allocator_traits<allocator_type>::propagate_on_container_swap::value` is `true`, then
`allocator_type` shall meet the <i>`Cpp17Swappable`</i> requirements,
and the behavior is undefined unless `a.get_allocator() == b.get_allocator()`.
Otherwise, the allocators shall not be swapped.</ins>

<p><b>24.3.14.6 Erasure [inplace.vector.erasure]</b>
<p><pre>
template&lt;class T, size_t N, <ins>class Allocator,</ins> class U = T>
  constexpr <del>size_t</del> <ins>typename inplace_vector&lt;T, N, Allocator>::size_type</ins>
    erase(inplace_vector&lt;T, N<ins>, Allocator</ins>>& c, const U& value);
</pre>
<p class="p">1․ *Effects:* Equivalent to:
<div style="margin: 0.5em 2em;"><pre>
    auto it = remove(c.begin(), c.end(), value);
    auto r = distance(it, c.end());
    c.erase(it, c.end());
    return r;
</pre></div>
<p><pre>
template&lt;class T, size_t N, <ins>class Allocator,</ins> class Predicate>
  constexpr <del>size_t</del> <ins>typename inplace_vector&lt;T, N, Allocator>::size_type</ins>
    erase_if(inplace_vector&lt;T, N<ins>, Allocator</ins>>& c, Predicate pred);
</pre>
<p class="p">2․ *Effects:* Equivalent to:
<div style="margin: 0.5em 2em;"><pre>
    auto it = remove_if(c.begin(), c.end(), pred);
    auto r = distance(it, c.end());
    c.erase(it, c.end());
    return r;
</pre></div>
</blockquote>
</small>

<pre class=biblio>
{
  "P0843": {
    "title": "inplace_vector",
    "authors": [
      "Gonzalo Brito Gadeschi", "Timur Doumler", "Nevin Liber", "David Sankel"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0843r14.html",
    "date": "June 2024"
  },
  "P1642": {
    "title": "Freestanding Library: Easy [utilities], [ranges], and [iterators]",
    "authors": [
      "Ben Craig"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1642r11.html",
    "date": "July 2022"
  },
  "P2198": {
    "title": "Freestanding Feature-Test Macros and Implementation-Defined Extensions",
    "authors": [
      "Ben Craig"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2198r7.html",
    "date": "December 2022"
  },
  "QuuxplusoneSG14": {
    "title": "Quuxplusone/SG14: Allocator-aware in-place vector (future > C++20)",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://github.com/Quuxplusone/SG14?tab=readme-ov-file#allocator-aware-in-place-vector-future--c20",
    "date": "August 2024"
  }
}
</pre>
