<pre class='metadata'>
Title: auto& operator=(X&&)
Shortname: D2952
Revision: 0
!Draft Revision: 7
Audience: EWG
Status: D
Group: WG21
URL:
!Current Source: <a href="https://github.com/Quuxplusone/draft/blob/gh-pages/d2952-auto-operators.bs">github.com/Quuxplusone/draft/blob/gh-pages/d2952-auto-operators.bs</a>
!Current: <a href="https://rawgit.com/Quuxplusone/draft/gh-pages/d2952-auto-operators.html">rawgit.com/Quuxplusone/draft/gh-pages/d2952-auto-operators.html</a>
Editor: Arthur O'Dwyer, arthur.j.odwyer@gmail.com
Editor: Matthew Taylor, mjtaylor214@hotmail.com
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract:
  Current C++ forbids explicitly defaulted functions to have placeholder return types such as <code>auto&</code>,
  except for C++20's <code>operator&lt;=&gt;</code>. We remove this syntactic restriction
  in cases where the deduced return type would be the same as the expected one.
  This allows more consistency and less repetition when declaring defaulted functions.
Date: 2023-07-23
</pre>

<style>
hilite  {background-color: #FFFF00; font-weight: bold;}
ins  {background-color: #CCFFCC; text-decoration: underline;}
del  {background-color: #FFCACA; text-decoration: line-through;}
</style>

# Changelog # {#changelog}

- R0:

    - Initial revision.


# Motivation # {#motivation}

Current C++ permits `=default` to appear only on certain signatures, with certain return types.
The current wording prohibits the use of placeholder types such as `auto&` to express these return
types, with the single exception of C++20's `operator<=>`. This leads to redundant repetition,
such as in this real code from libc++'s test suite:

```cpp
struct ForwardDiffView {
  [...]
  ForwardDiffView(ForwardDiffView&&) = default;
  ForwardDiffView(const ForwardDiffView&) = default;
  ForwardDiffView& operator=(ForwardDiffView&&) = default;
  ForwardDiffView& operator=(const ForwardDiffView&) = default;
  [...]
};
```

We'd prefer to write the following, but the language doesn't currently permit it:

```cpp
struct ForwardDiffView {
  [...]
  ForwardDiffView(ForwardDiffView&&) = default;
  ForwardDiffView(const ForwardDiffView&) = default;
  auto& operator=(ForwardDiffView&&) = default; // ill-formed C++23
  auto& operator=(const ForwardDiffView&) = default; // ill-formed C++23
  [...]
};
```

The status quo is inconsistent between non-defaulted and defaulted functions,
making it unnecessarily tedious to upgrade to `=default`:

```cpp
  auto& operator=(const MyClass& rhs) { i = rhs.i; return *this; } // well-formed
  auto& operator=(const MyClass& rhs) = default;                   // ill-formed, must say 'MyClass&'
```

And the comparison operators are inconsistent among themselves: `operator<=>`
can deduce `strong_ordering`, but the others (including `operator==`) cannot deduce `bool`.

```cpp
  auto operator<=>(const MyClass& rhs) const = default; // well-formed
  auto operator<(const MyClass& rhs) const = default;  // ill-formed, must say 'bool'

  auto operator==(const MyClass& rhs) const { return i == rhs.i; } // well-formed
  auto operator==(const MyClass& rhs) const = default; // ill-formed, must say 'bool'
```

The current ill-formedness of these declarations comes from overly restrictive wording in the standard,
such as <a href="https://eel.is/c++draft/class.eq">[class.eq]</a>
specifically requiring that a defaulted equality
operator must have a *declared* return type of `bool`, instead of simply specifying that its return type
must *be* `bool`.
We believe that these declarations should not be ill-formed. The meaning of each of the examples above
is intuitively clear; the placeholder return type correctly matches the type which the defaulted body
will actually return. We propose to loosen the current restrictions and permit these declarations to
be well-formed.

Note that this proposal does *not* seek to change the valid return types of these functions
(or any other aspect of their semantics). We propose a purely syntactic change to expand the
range of allowed declaration *syntax*, not semantics. (But we do one drive-by clarification
which we believe matches EWG's original intent:
if an empty class's defaulted `operator<=>` returns a non-comparison-category type,
it should be defaulted as deleted.)

# Proposal # {#proposal}

We propose that a defaulted function declaration with a placeholder return type should have its
type deduced (<a href="https://eel.is/c++draft/dcl.spec.auto.general#3.sentence-4">[dcl.spec.auto.general]</a>)
as if from a fictional return statement that returns:

* a prvalue of type `bool`, in the case of `operator==`, `operator!=`, `operator<`, `operator>`, `operator<=`, or `operator>=`
* a prvalue of type `Q`, in the case of `operator<=>`; where `Q` is the common comparison type of <i>R</i><sub>0</sub>, <i>R</i><sub>1</sub>,... <i>R</i><sub>n-1</sub>
* an lvalue of type `C`, in the case of `operator=` for a class or union type `C`

Then, the deduced return type is compared to the type(s) required by the standard. If the types match, the
declaration is well-formed. Otherwise it's ill-formed.

For the copy-assignment operator, our proposal gives the following behavior:

```cpp
struct MyClass {
  auto& operator=(const MyClass&) = default;          // Proposed OK: deduces MyClass&
  decltype(auto) operator=(const MyClass&) = default; // Proposed OK: deduces MyClass&
  auto&& operator=(const MyClass&) = default;         // Proposed OK: deduces MyClass&
  const auto& operator=(const MyClass&) = default;    // Still ill-formed: deduces const MyClass&
  auto operator=(const MyClass&) = default;           // Still ill-formed: deduces MyClass
  auto* operator=(const MyClass&) = default;          // Still ill-formed: deduction fails
};
```

For `operator==`, our proposal gives the following behavior:

```cpp
struct MyClass {
  auto operator==(const MyClass&) const = default;           // Proposed OK: deduces bool
  decltype(auto) operator==(const MyClass&) const = default; // Proposed OK: deduces bool
  auto&& operator==(const MyClass&) const = default;         // Still ill-formed: deduces bool&&
  auto& operator==(const MyClass&) const = default;          // Still ill-formed: deduction fails
};
```

## "Return type" versus "declared return type" ## {#declared-type}

Today, vendors unanimously reject `auto& operator=(const A&) = default`.
But we can't find any wording in <a href="https://eel.is/c++draft/class.copy.assign">[class.copy.assign]</a>
or <a href="https://eel.is/c++draft/dcl.fct.def.default">[dcl.fct.def.default]</a> that directly justifies
this behavior. It seems that vendors are interpreting e.g. <a href="https://eel.is/c++draft/dcl.fct.def.default#2.5">[dcl.fct.def.default]/2.5</a>'s
"[if] the return type of F<sub>1</sub> differs from the return type of F<sub>2</sub>"
to mean "the *declared* return type of F<sub>1</sub>," even though newer sections such as
<a href="https://eel.is/c++draft/class.compare">[class.compare]</a> consistently distinguish
the "declared return type" from the [actual] return type.

We tentatively propose to leave <a href="https://eel.is/c++draft/dcl.fct.def.default">[dcl.fct.def.default]</a> alone,
and simply add an example that indicates the (new) intent of the (existing) wording: that it should
now be interpreted as talking about the assignment operator's *actual* return type,
not its *declared* (placeholder) return type.


## "Defaulted as deleted" ## {#defaulted-as-deleted}

The current wording for comparison operators is crafted so that the following `Container` is well-formed.
Its `operator<=>` is defaulted as deleted (so that operator is unusable), but the instantiation
of class `Container<mutex>` itself is OK. We need to preserve this in our rewriting.
([Godbolt.](https://godbolt.org/z/jcPf1Ge9W))
```cpp
template<class T>
struct Container {
  T t;
  auto operator<=>(const Container&) const = default;
};

Container<std::mutex> cm;
  // OK, <=> is deleted

struct Weird { int operator<=>(Weird) const; };
Container<Weird> cw;
  // OK, <=> is deleted because
  // Weird's operator<=> returns a non-comparison-category type
```

Similarly for dependent return types:
```cpp
template<class R>
struct C {
  int i;
  R operator<=>(const C&) const = default;
};
static_assert(!std::three_way_comparable<C<int>>);
static_assert(std::three_way_comparable<C<std::strong_ordering>>);
```

Therefore we can't just say "`operator<=>` *shall* have a return type which is a comparison category type";
we must say that if the return type is not a comparison category type then the operator is defaulted as deleted.

## "Deducing `this`" and CWG2586 ## {#deducing-this}

Before [[CWG2586]], defaulted functions were never allowed to have explicit object parameters.
But the resolution of that issue (which has been adopted for C++23) permits explicit object parameters.
This is not a problem for the comparison operators. But it constrains the wordings we can choose for
`operator=`: we can't say "the return type is deduced as if from `return *this`" because there might not
be a `*this`.

There's a quirk with rvalue-ref-qualified assignment operators. (Not *move* assignment, but
assignment where the *destination* object is explicitly rvalue-ref-qualified.)

* `auto&& operator=(const B&) && { return *this; }` deduces an lvalue reference; but
* `auto&& operator=(this B&& self, const B&) { return self; }` deduces an rvalue reference.

Nonetheless, a *defaulted* assignment operator always returns an lvalue reference
(<a href="https://eel.is/c++draft/class.copy.assign#2">[class.copy.assign]/2</a>,
<a href="https://eel.is/c++draft/dcl.fct.def.default#2.5">[dcl.fct.def.default]/2.5</a>),
regardless of whether it's declared using explicit object syntax.

```cpp
struct A {
  A& operator=(const A&) && = default; // OK today
  A&& operator=(const A&) && = default; // Error, return type isn't A&
  decltype(auto) operator=(const A&) && { return *this; } // OK, deduces A&
  decltype(auto) operator=(const A&) && = default; // Proposed OK, deduces A&
};
struct B {
  B& operator=(this B&& self, const B&) { return self; } // Error, self is an rvalue
  B&& operator=(this B&& self, const B&) { return self; } // OK
  decltype(auto) operator=(this B&& self, const B&) { return self; } // OK, deduces B&&
  B& operator=(this B& self, const B&) = default; // OK, deduces B&
  B& operator=(this B&& self, const B&) = default; // OK
  B&& operator=(this B&& self, const B&) = default; // Error, return type isn't B&
  decltype(auto) operator=(this B&& self, const B&) = default; // Proposed OK, deduces B&
};
```

Defaulted rvalue-ref-qualified assignment operators are weird, and Arthur would (orthogonally)
like to ban them; but P2952 doesn't need to do anything special with them. Assignment operators
always return lvalue references, so we'll deduce an lvalue reference — done.


## Existing corner cases ## {#corner-cases}

There is vendor divergence in some corner cases. Here is a table of the divergences we found,
plus our opinion as to the conforming behavior, and how it affects this proposal.

<small><table>
<tr><th>URL</th><th>Code</th><th>Clang</th><th>GCC</th><th>MSVC</th><th>EDG</th><th>Correct</th></tr>
<tr><td><a href="https://godbolt.org/z/3EqYc43xh">link</a></td><td><pre>const bool operator==(const C&) const = default;</pre></td>
    <td>✗</td><td>✗</td><td>✗</td><td bgcolor="#FFCACA">✓</td><td><a href="https://eel.is/c++draft/class.eq#1.sentence-1">✗</a></td></tr>
<tr><td><a href="https://godbolt.org/z/hx9vvorsn">link</a></td><td><pre>friend bool operator==(const C, const C) = default;</pre></td>
    <td>✓</td><td bgcolor="#FFCACA">✗</td><td>✓</td><td>✓</td><td><a href="https://eel.is/c++draft/class.compare#default-1.sentence-1">✓</a></td></tr>
<tr><td><a href="https://godbolt.org/z/aPWEs5xnb">link</a></td><td><pre>struct U { U(std::strong_ordering); };
struct C {
  U operator<=>(const C&) const = default;
};</pre></td>
    <td>✓</td><td>✓</td><td bgcolor="#FFCACA">✗</td><td bgcolor="#FFCACA">deleted</td><td>Today: ✓<br>Proposed: deleted</td></tr>
<tr><td><a href="https://godbolt.org/z/ePnnvvdsz">link</a></td><td><pre>struct U { U(std::strong_ordering); operator int(); };
struct C {
  int i;
  U operator<=>(const C&) const = default;
};</pre></td>
    <td bgcolor="#FFCACA">✓</td><td bgcolor="#FFCACA">✓</td><td bgcolor="#FFCACA">✗</td><td>deleted</td><td><a href="https://eel.is/c++draft/class.compare#class.spaceship-2.2.sentence-2">deleted</a></td></tr>
<tr><td><a href="https://godbolt.org/z/T6bnsMqWo">link</a></td><td><pre>struct C {
  int i;
  const std::strong_ordering&
    operator<=>(const C&) const = default;
};</pre></td>
    <td bgcolor="#FFCACA">ICE</td><td>deleted</td><td bgcolor="#FFCACA">✓</td><td>deleted</td><td>deleted</td></tr>
<tr><td><a href="https://godbolt.org/z/W3eW1Tdb9">link</a></td><td><pre>struct C {
  const std::strong_ordering&
    operator<=>(const C&) const = default;
};</pre></td>
    <td bgcolor="#FFCACA">ICE</td><td>✓</td><td>✓</td><td bgcolor="#FFCACA">deleted</td><td>Today: ✓<br>Proposed: deleted</td></tr>
<tr><td><a href="https://godbolt.org/z/KTTGMjWox">link</a></td><td><pre>struct W {
  const std::strong_ordering
    operator<=>(const W&) const;
};
struct C {
  W w;
  auto operator<=>(const C&) const = default;
};</pre></td>
    <td bgcolor="#FFCACA">✓</td><td bgcolor="#FFCACA">✗</td><td bgcolor="#FFCACA">✓</td><td>deleted</td><td><a href="https://eel.is/c++draft/class.compare#class.spaceship-2.1.sentence-2">deleted</a></td></tr>
<tr><td><a href="https://godbolt.org/z/3T4b9YM6r">link</a></td><td><pre>struct W {
  const std::strong_ordering
    operator<=>(const W&) const;
};
struct C {
  W w;
  std::strong_ordering
    operator<=>(const C&) const = default;
};</pre></td>
    <td bgcolor="#FFCACA">✓</td><td bgcolor="#FFCACA">✓</td><td bgcolor="#FFCACA">✓</td><td bgcolor="#FFCACA">✓</td><td><a href="https://eel.is/c++draft/class.compare#class.spaceship-2.2.sentence-2">deleted</a></td></tr>
<tr><td><a href="https://godbolt.org/z/G3ddGeex8">link</a><td><pre>auto operator<=>(const M&) const
  noexcept(false) = default;</pre></td>
    <td>✓</td><td>✓</td><td bgcolor="#FFCACA">noexcept</td><td bgcolor="#FFCACA">inconsistent</td><td><a href="https://eel.is/c++draft/class.compare#default-note-1">✓</a></td>
<tr><td><a href="https://godbolt.org/z/WezedYYE3">link</a></td><td><pre>C& operator=(C&) = default;</pre></td>
    <td>✓</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td></tr>
<tr><td><a href="https://godbolt.org/z/hxc9za5KT">link</a></td><td><pre>C& operator=(const C&&) = default;</pre></td>
    <td>deleted</td><td bgcolor="#FFCACA">✗</td><td bgcolor="#FFCACA">✗</td><td>deleted</td><td><a href="https://eel.is/c++draft/dcl.fct.def.default#2.6">deleted</a></td></tr>
<tr><td><a href="https://godbolt.org/z/ojM541bTM">link</a></td><td><pre>C& operator=(const C&) const = default;</pre></td>
    <td bgcolor="#FFCACA">✗</td><td>deleted</td><td bgcolor="#FFCACA">✗</td><td>deleted</td><td><a href="https://eel.is/c++draft/dcl.fct.def.default#2.6">deleted</a></td></tr>
<tr><td><a href="https://godbolt.org/z/hchco3rcK">link</a></td><td><pre>C& operator=(const C&) && = default;</pre></td>
    <td>✓</td><td>✓</td><td>✓</td><td>✓</td><td><a href="https://eel.is/c++draft/dcl.fct.def.default#2.1">✓</a></td></tr>
<tr><td><a href="https://godbolt.org/z/5P6EKrGjo">link</a></td><td><pre>C&& operator=(const C&) && = default;</pre></td>
    <td>✗</td><td>✗</td><td>✗</td><td>✗</td><td><a href="https://eel.is/c++draft/dcl.fct.def.default#2.5">✗</a></td></tr>
</table></small>

## Impact on existing code ## {#impact}

There should be little effect on existing code, since this proposal mainly allows syntax that was ill-formed before.
As shown in [[#corner-cases]], we do propose to change some very arcane examples, e.g.
```cpp
struct C {
  const std::strong_ordering&
    operator<=>(const C&) const = default;
    // Today: Well-formed, non-deleted
    // Tomorrow: Well-formed, deleted
};
```


# Implementation experience # {#experience}

None yet.

# Proposed wording # {#wording}

## [class.eq] ## {#wording-class.eq}

Note: The phrase "equality operator function" (<a href="https://eel.is/c++draft/over.binary">[over.binary]</a>)
covers both `==` or `!=`. But `!=` is not covered by [class.eq]; it's covered by [class.compare.secondary] below.

Modify <a href="https://eel.is/c++draft/class.eq">[class.eq]</a> as follows:

<small><blockquote>
<del>1․ A defaulted equality operator function ([over.binary]) shall have a declared return type `bool`.</del>

2․ A defaulted `==` operator function for a class `C` is defined as deleted unless, for each `x`<sub><i>i</i></sub>
in the expanded list of subobjects for an object `x` of type `C`, `x`<sub><i>i</i></sub> `== x`<sub><i>i</i></sub> is usable
([class.compare.default]).

3․ The return value `V` of a defaulted `==` operator function with parameters `x` and `y` is determined by comparing corresponding elements
`x`<sub><i>i</i></sub> and `y`<sub><i>i</i></sub> in the expanded lists of subobjects for `x` and `y` (in increasing index order)
until the first index <i>i</i> where `x`<sub><i>i</i></sub> and `y`<sub><i>i</i></sub> <ins>,</ins> <del>yields a result value which,
when</del> contextually converted to `bool`, yields `false`. If no such index exists, `V` is `true`. Otherwise, `V` is `false`.

<ins>x․ A defaulted `==` operator function shall have the return type `bool`. If its declared return type
contains a placeholder type, its return type is deduced as if from `return true;`.</ins>

4․ [<i>Example 1:</i>
<pre>
struct D {
  int i;
  friend bool operator==(const D& x, const D& y) = default;
      // OK, returns x.i == y.i
};
</pre>
— <i>end example</i>]
</blockquote></small>

## [class.spaceship] ## {#wording-class.spaceship}

Note: There are only three "comparison category types" in C++, and `strong_ordering::equal` is implicitly convertible
to all three of them. The status quo already effectively forbids `<=>` to return a non-comparison-category type,
since either `R` is deduced as a common comparison type (which is a comparison category type by definition), or else
a synthesized three-way comparison of type `R` must exist (which means `R` must be a comparison category type),
or else the sequence `x`<sub><i>i</i></sub> must be empty (in which case there are no restrictions on `R` except
that it be constructible from `strong_ordering::equal`). We strengthen the wording to directly mandate that the
return type be a comparison category type, even in the empty case.

Modify <a href="https://eel.is/c++draft/class.spaceship">[class.spaceship]</a> as follows:

<small><blockquote>
[...]

2․ Let `R` be the declared return type of a defaulted three-way comparison operator function, and let 
`x`<sub><i>i</i></sub> be the elements of the expanded list of subobjects for an object `x` of type `C`.

— (2.1) If `R` <del>is `auto`,</del> <ins>contains a placeholder type,</ins> then let
<i>cv<sub>i</sub></i> `R`<sub><i>i</i></sub> be the type of the expression
`x`<sub><i>i</i></sub> `<=> x`<sub><i>i</i></sub>. The operator function is defined as deleted if that expression is not usable
or if `R`<sub><i>i</i></sub> is not a comparison category type ([cmp.categories.pre]) for any <i>i</i>.
The return type is deduced as <ins>if from `return Q(std::strong_ordering::equal);`, where `Q` is</ins> the
common comparison type (see below) of `R`<sub>0</sub>, `R`<sub>1</sub>, ..., `R`<sub>n-1</sub>.

— (2.2) Otherwise, <del>`R` shall not contain a placeholder type. If</del> <ins>if</ins> the synthesized three-way comparison of type `R`
between any objects `x`<sub><i>i</i></sub> and `x`<sub><i>i</i></sub> is not defined, the operator function is
defined as deleted.

3․ The return value `V` <del>of type `R`</del> of the defaulted three-way comparison operator function with parameters `x` and `y` <del>of
the same type</del> is determined by comparing corresponding elements `x`<sub><i>i</i></sub> and `y`<sub><i>i</i></sub>
in the expanded lists of subobjects for `x` and `y` (in increasing index order) until the first index <i>i</i>
where the synthesized three-way comparison of type `R` between `x`<sub><i>i</i></sub> and `y`<sub><i>i</i></sub>
yields a result value `v`<sub><i>i</i></sub> where `v`<sub><i>i</i></sub> `!= 0`, contextually converted to `bool`,
yields `true`; `V` is a copy of `v`<sub><i>i</i></sub>.
If no such index exists, `V` is <del>`static_cast<R>(`</del>`std::strong_ordering::equal`<del>`)`</del>.

<ins>x․ A defaulted three-way comparison operator function which is not deleted shall have a return type which is a comparison category type.
[<i>Note:</i> A reference type is not a comparison category type. —<i>end note</i>]</ins>

4․ The <i>common comparison type</i> `U` of a possibly-empty list of <i>n</i> comparison category types
`T`<sub>0</sub>, `T`<sub>1</sub>, ..., `T`<sub>n-1</sub> is defined as follows:

[...]
</blockquote></small>

## [class.compare.secondary] ## {#wording-class.compare.secondary}

Modify <a href="https://eel.is/c++draft/class.compare.secondary">[class.compare.secondary]</a> as follows:

<small><blockquote>
1․ A <i>secondary comparison operator</i> is a relational operator ([expr.rel]) or the `!=` operator.
<del>A defaulted operator function ([over.binary]) for a secondary comparison operator `@` shall have a declared return type `bool`.</del>

2․ <del>The</del> <ins>A defaulted secondary comparison</ins> operator function with parameters `x` and `y` is defined as deleted if

— (2.1) overload resolution ([over.match]), as applied to `x @ y`, does not result in a usable candidate, or

— (2.2) the candidate selected by overload resolution is not a rewritten candidate.

Otherwise, the operator function yields `x @ y`. The defaulted operator function is not considered as a candidate
in the overload resolution for the `@` operator.

<ins>x․ A defaulted secondary comparison operator function shall have the return type `bool`. If its declared return type
contains a placeholder type, its return type is deduced as if from `return true;`.</ins>

3․ [<i>Example 1</i>:
<pre>
struct HasNoLessThan { };

struct C {
  friend HasNoLessThan operator<=>(const C&, const C&);
  bool operator<(const C&) const = default; // OK, function is deleted
};
</pre>
— <i>end example</i>]
</blockquote></small>

## [class.copy.assign] ## {#wording-class.copy.assign}

Modify <a href="https://eel.is/c++draft/class.copy.assign">[class.copy.assign]</a> as follows:

<small><blockquote>
14․ The implicitly-defined copy/move assignment operator for a class returns <ins>an lvalue
reference to</ins> the object for which the assignment operator is invoked, that is,
the object assigned to.
<p><ins>15․ If a defaulted copy/move assignment operator's declared return type contains a
placeholder type, its return type is deduced as if from `return r;`, where `r` is an lvalue
reference to the object for which the assignment operator is invoked.</ins>
<p><ins>16․ [<i>Example:</i></ins>
<pre>
<ins>struct A {</ins>
  <ins>decltype(auto) operator=(A&&) = default;</ins>
    <ins><i>// Return type is A&</i></ins>
<ins>};</ins>
<ins>struct B {</ins>
  <ins>auto operator=(B&&) = default;</ins>
    <ins><i>// error: Return type is B, which violates [dcl.fct.def.default]/2.5</i></ins>
<ins>};</ins>
</pre>
<ins>—<i>end example</i>]</ins>
</blockquote></small>

<pre class=biblio>
{
  "CWG2586": {
    "title": "Explicit object parameter for assignment and comparison",
    "authors": [
      "Barry Revzin"
    ],
    "href": "https://cplusplus.github.io/CWG/issues/2586.html",
    "date": "May–July 2022"
  },
  "P2953": {
    "title": "Forbid defaulting rvalue-ref-qualified assignment operators",
    "authors": [
      "Arthur O'Dwyer"
    ],
    "href": "https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2953r0.html",
    "date": "August 2023"
  }
}
</pre>
